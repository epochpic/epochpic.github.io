<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Basic examples | EPOCH</title><link>/quickstart/basic_examples.html</link><atom:link href="/quickstart/basic_examples/index.xml" rel="self" type="application/rss+xml"/><description>Basic examples</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><image><url>/images/logo_hub4b4d6a0f57638acebb5550a80c8c030_9243_300x300_fit_lanczos_2.png</url><title>Basic examples</title><link>/quickstart/basic_examples.html</link></image><item><title>Lasers</title><link>/quickstart/basic_examples/laser.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/laser.html</guid><description>&lt;p>EPOCH can support laser sources on the boundaries, with a wide array of spatial
and temporal profiles. These examples provide basic input decks for simulating
lasers in vacuum. General documentation on the EPOCH laser block can be found
&lt;a href="/documentation/input_deck/input_deck_laser.html">here&lt;/a>.&lt;/p>
&lt;h2 id="simple-plane-wave">Simple plane wave&lt;/h2>
&lt;p>This input deck provides the most basic form of laser. We use uniform spatial
and temporal profiles, and inspect the Poynting flux in the simulation window.
As a typical rule of thumb, allow 20 cells per wavelength to get a good
resolution.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 200
ny = 400
t_end = 100e-15
x_min = 0
x_max = 10e-6
y_min = -10e-6
y_max = 10e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e18
lambda = 1.0e-6
end:laser
begin:output
dt_snapshot = 10 * femto
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="simple_laser.png" alt="Uniform laser">&lt;/p>
&lt;p>As we have specified a time-averaged intensity of $10^{18} \text{ Wcm}^{-2}$, we
expect the Poytning flux to range 0 to $2\times 10^{18} \text{ Wcm}^{-2}$, which
we can see here. Note that, because our laser profile reaches the $y_{min}$ and
$y_{max}$ boundaries, some noise has been introduced here. In practice, these
boundary effects are less of an issue, as simulations are expected to mainly
deal with laser pulses.&lt;/p>
&lt;h2 id="laser-pulse">Laser pulse&lt;/h2>
&lt;p>Using the maths parser, we can create a laser pulse which has a Gaussian profile
in time and space for the intensity distribution, $I$:&lt;/p>
&lt;p>$ I(y,t) \propto e^{-(y-y_0)^2/2\sigma_y^2} e^{-(t-t_0)^2/2\sigma_t^2}$&lt;/p>
&lt;p>where we consider a 2D simulation with an $x$ propagating laser.&lt;/p>
&lt;p>Let the full-width-at-half-maximum of the
spatial and temporal profiles be 5 $\mu m$ and 40 fs respectively for the
intensity $I$ distribution. The relationship between $\sigma$ and the $fwhm$
for a Gaussian distribution is:&lt;/p>
&lt;p>$\sigma = \frac{fwhm}{2\sqrt{2 \ln(2)}}$&lt;/p>
&lt;p>However, the profile
keys in the laser block describe modifications to the boundary electric fields,
$E$, and as $I \propto E^2$, the $E$ profile must satisfy&lt;/p>
&lt;p>$ E(y,t) \propto e^{-((y-y_0)/2\sigma_y)^2} e^{-((t-t_0)/2\sigma_t)^2}$&lt;/p>
&lt;p>The EPOCH
&lt;a href="/documentation/code_details/maths_parser.html">maths parser&lt;/a> provides
a special &lt;code>gauss(x,x_0,w)&lt;/code> command for use in the input.deck, which sets a
profile of the form:&lt;/p>
&lt;p>$e^{-(x-x_0)^2/w^2}$&lt;/p>
&lt;p>Hence, we may use this &lt;code>gauss&lt;/code> function to model the electric field profiles if
we set&lt;/p>
&lt;p>$w = \frac{fwhm}{\sqrt{2\ln(2)}}$&lt;/p>
&lt;p>where $fwhm$ refers to the &lt;em>intensity&lt;/em> distribution.&lt;/p>
&lt;p>We can let the spatial profile peak at $y=0$. We don&amp;rsquo;t want the laser to peak at
$t=0$, as this would ignore the rising intensity. Instead, let us start when the
laser pulse is 10% of its maximum value - the half-width-at-10%-maximum,
$hw0.1m$. For a Gaussian beam, this is:&lt;/p>
&lt;p>$hw0.1m = \frac{fwhm}{2} \sqrt{\frac{\ln(10)}{\ln(2)}}$&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 700
ny = 400
t_end = 100e-15
x_min = 0
x_max = 35e-6
y_min = -10e-6
y_max = 10e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:constant
t_fwhm = 40.0e-15
y_fwhm = 5.0e-6
w_t = t_fwhm / sqrt(2*loge(2))
w_y = y_fwhm / sqrt(2*loge(2))
t_hw01m = 0.5 * t_fwhm * sqrt(loge(10)/loge(2))
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e18
lambda = 1.0e-6
profile = gauss(y,0,w_y)
t_profile = gauss(time,t_hw01m,w_t)
end:laser
begin:output
dt_snapshot = 10 * femto
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="laser_pulse.png" alt="Gaussian pulse">&lt;/p>
&lt;p>Here we see that the laser $fwhm$ in $x$ and $y$ are 12 $\mu m$ and 5 $\mu m$
respectively, where the $x$ $fwhm$ corresponds to a temporal FWHM of 40 fs, as
expected. Also, because there is little contact between the pulse and the
boundaries, we do not have any numerical boundary disturbance.&lt;/p>
&lt;h2 id="angled_laser_pulse">Angled laser pulse&lt;/h2>
&lt;p>A Gaussian laser pulse like the one in the previous example may be injected at
an angle into an EPOCH simulation. This is achieved by defining the spatial and
temporal laser envelopes in a rotated co-ordinate system (temporal envelope is
equivalent to an envelope in the laser-propagation direction). In this example,
the parameters &lt;code>y_rot&lt;/code> and &lt;code>t_rot&lt;/code> will describe the transverse and longitudinal
co-ordinates in the rotated co-ordinate system. Transformations are required
for both the profile and the phase of the laser.&lt;/p>
&lt;p>EPOCH uses the provided intensity to set $B$ values parallel to the boundary -
on &lt;code>x_min&lt;/code>, this sets $B_y$ and $B_z$. EPOCH sets these fields assuming the
laser travels perpendicular to the boundary, but this will over-estimate the $B$
fields in our rotated co-ordinate system, as part of the magnetic field will
also oscillate in the boundary normal direction. To correct for this, an
additional &lt;code>cos(theta)&lt;/code> parameter is required for intensity in the &lt;code>laser&lt;/code>
block.&lt;/p>
&lt;p>Finally, we must also be careful about the time when the peak laser intensity
enters the simulation. In the previous example, we set this to the half-time at
10% maximum, such that the laser started at 10% of its maximum intensity and
then increased to full. In a rotated laser, the wave-front corresponding to
the peak intensity arrives earlier on one of the laser edges than the other. Let
us set the injection time such that this &amp;ldquo;early edge&amp;rdquo; starts at 10% of the
maximum intensity. We will define the $y$ position of this &amp;ldquo;early edge&amp;rdquo; to be
the half-width at 10% maximum for the spatial profile. This way, we will
sufficiently model the full envelope, regardless of the injection angle.&lt;/p>
&lt;p>Here we provide an input deck which specifies a point on the laser path, and an
injection angle. Two constant blocks are provided: the first is for users to
set laser parameters, and the second derives parameters in the rotated
co-ordinate system.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 500
ny = 500
t_end = 200e-15
x_min = 0
x_max = 25e-6
y_min = 0e-6
y_max = 25e-6
stdout_frequency = 50
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:constant
t_fwhm = 40.0e-15 # Temporal FWHM
y_fwhm = 5.0e-6 # Spatial FWHM
y_foc = 5.0e-6 # y co-ord on laser path
x_foc = 10.0e-6 # x co-ord on laser path
las_theta_deg = -45 # Laser angle to boundary normal
I_peak_Wcm2 = 1.0e19 # Peak cycle-averaged intensity
las_lambda = 1.0e-6 # Laser wavelength
end:constant
begin:constant
las_theta = las_theta_deg * pi / 180.
y0 = y_foc - (x_foc - x_min) * tan(las_theta)
y_rot = y*cos(las_theta)
y0_rot = y0*cos(las_theta)
w_y = y_fwhm / sqrt(2*loge(2))
y_hw01m = 0.5 * y_fwhm * sqrt(loge(10)/loge(2))
w_t = t_fwhm / sqrt(2*loge(2))
t_hw01m = 0.5 * t_fwhm * sqrt(loge(10)/loge(2))
t_rot = time - (y-y0_rot)*sin(las_theta)/c
t_hw01m_rot = t_hw01m + abs(y_hw01m * sin(las_theta) / c)
I_peak_rot = I_peak_Wcm2 * cos(las_theta)
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = I_peak_rot
lambda = las_lambda
profile = gauss(y_rot, y0_rot, w_y) * gauss(t_rot, t_hw01m_rot, w_t)
phase = -2 * pi * (y-y0_rot) * sin(las_theta) / las_lambda
end:laser
begin:output
dt_snapshot = t_end / 10
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>Here, we see the Poynting flux corresponds to a rotated Gaussian pulse. The
expected laser trajectory is marked with a dashed line for comparison. We see
that the wavelength, along with the spatial and temporal FWHM are as expected.&lt;/p>
&lt;p>&lt;img src="angled_injection.png" alt="Rotated Gaussian pulse">&lt;/p>
&lt;h2 id="focussing_a_gaussian_beam">Focussing a Gaussian Beam&lt;/h2>
&lt;p>A laser can be driven on the boundary so that it focusses on a given
spot. Basic details of how to do this are
&lt;a href="https://en.wikipedia.org/wiki/Gaussian_beam" target="_blank" rel="noopener">here&lt;/a>. To summarise, using
the paraxial approximation, the electric fields for a $x$-propagating,
$y$-polarised Gaussian beam take the form:&lt;/p>
&lt;p>$\pmb{E}(r,x) = E_0 \frac{w_0}{w(x)} e^{-r^2/w(x)^2} e^{-i(kx + k\frac{r^2}{2R_c(x)}-\psi(x))} \hat{\pmb{y}}$&lt;/p>
&lt;p>where&lt;/p>
&lt;ul>
&lt;li>$r$ is the radial distance from the laser propagation axis&lt;/li>
&lt;li>$x$ is axial distance along the wave, with $x=0$ at the focus&lt;/li>
&lt;li>$E_0$ is the peak electric field amplitude at the focus&lt;/li>
&lt;li>$w(x)$ is the beam-waist at $x$ (radial distance where field strength drops by $e^{-1}$)&lt;/li>
&lt;li>$w_0$ is $w(x=0)$&lt;/li>
&lt;li>$k$ is the laser wave-vector&lt;/li>
&lt;li>$R_c(x)$ is the radius of curvature at $x$&lt;/li>
&lt;li>$\psi(x)$ is the Gouy phase correction&lt;/li>
&lt;/ul>
&lt;p>If the fields on the simulation boundary are of this form,
then the fields will propagate according to this equation, and
a focal spot will be formed. Note that this propagation is only expected
provided the paraxial approximation is satisfied. This implies that, for vacuum propagation, the laser
wavelength, $\lambda$ is much smaller than the beam-waist: $\lambda &amp;laquo; w_0$.&lt;/p>
&lt;p>The following deck
gives an example for a laser attached to x_min. Two constant blocks are provided:
the first gives the user control over the focused laser properties, and the
second derives variables to be used in the laser block. The user only needs to
touch the first, which sets the intensity full-width-at-half-maximum (related to
beam-waist), the peak, cycle-averaged intensity, the laser wave-length and the
distance from the $x_{min}$ boundary to the focal point.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 2400
ny = 1200
t_end = 100e-15
x_min = 0
x_max = 20e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:constant
I_fwhm = 2.0e-6 # FWHM of laser intensity
I_peak_Wcm2 = 1.0e15 # 0.5 * eps0 * c * E_peak^2
las_lambda = 1.0e-6 # Laser wavelength
foc_dist = 5.0e-6 # Boundary to focal point distance
end:constant
begin:constant
las_k = 2.0 * pi / las_lambda
w0 = I_fwhm / sqrt(2.0 * loge(2.0)) # Beam Waist
ray_rang = pi * w0^2 / las_lambda # Rayleigh range
w_boundary = w0 * sqrt(1.0 + (foc_dist/ray_rang)^2) # Waist on boundary
I_boundary = I_peak_Wcm2 * (w0 / w_boundary)^2 # Intens. on boundary
rad_curve = foc_dist * (1.0 + (ray_rang/foc_dist)^2) # Boundary curv. rad.
gouy = atan(-foc_dist/rad_curve) # Boundary Gouy shift
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = I_boundary
lambda = las_lambda
phase = las_k * y^2 / (2.0 * rad_curve) - gouy
profile = gauss(y, 0, w_boundary)
end:laser
begin:output
name = o1
dt_snapshot = 10 * femto
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="FocussedBeam.png" alt="The focussed beam">&lt;/p>
&lt;p>In this example, EPOCH correctly reproduces the focal point position,
laser wavelength, and radial FWHM at the focus - however, the peak
intensity is only $0.88\times 10^{15} \text{ Wcm}^{-2}$. This
intensity reduction from target is due to the tight focal spot,
with $w_0\approx 1.7$ μm being close to $\lambda = 1.0$ μm.&lt;/p>
&lt;p>The deck is based on the laser test deck supplied with EPOCH, with a
modified laser and longer runtime. Other classes of beam (Bessel etc)
can be created similarly.&lt;/p></description></item><item><title>Particle loading</title><link>/quickstart/basic_examples/particle_load.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/particle_load.html</guid><description>&lt;p>Particles in EPOCH belong to particle species which can be controlled by the
&lt;a href="/documentation/input_deck/input_deck_species.html">species block&lt;/a>. In these
examples, we show how to load macro-particles in various configurations.
These macro-particle objects
behave as single particles in the code, but represent many real particles
for the current solver. The examples on this page set up simulations in epoch2d,
but they may be modified for use in the 1d or 3d codes.&lt;/p>
&lt;h2 id="uniform-load">Uniform load&lt;/h2>
&lt;p>This basic input deck sets up a uniform density of electrons over the full
simulation window. We create 10 macro-particles per cell, for a density of
$10^{24}\text{ m}^{-3}$. The cell sizes are $dx = dy = 50\text{ nm}$ and
$dz = 1 \text{ m}$, since cell sizes in omitted dimensions default to 1 metre.
Hence, we expect $2.5\times 10^9$ real electrons per cell, so each
macro-electron should represent around $2.5\times 10^8$ real electrons.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 25e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
npart = 50 * nx * ny
density = 1.0e24
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="uniform_load.png" alt="Uniform density">&lt;/p>
&lt;h2 id="basic-target">Basic target&lt;/h2>
&lt;p>The shape of the target can be controlled by using
&lt;a href="/documentation/code_details/maths_parser.html">maths parser&lt;/a> expressions in the
density key. For example, a $5 \text{ }\mu\text{m}$ target slab can be defined
according to&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 25e-6
stdout_frequency = 100
npart = 50 * (5.0e-6/(x_max-x_min)) * nx * ny
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
frac = 0.8
density = if (x gt 15.0e-6, 1.0e24, 0)
density = if (x gt 20.0e-6, 0, density(Electron))
temp_ev = 1000
end:species
begin:species
name = Carbon
mass = 22033.0
charge = 6.0
frac = 0.2
density = density(Electron) / 6
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="basic_target.png" alt="Uniform density">&lt;/p>
&lt;p>This target contains both electrons, and fully ionised carbon ions. The number
of macro-particles loaded has been set to ensure there are 50 particles per
cell, accounting for the fact most cells are in vacuum. The &lt;code>if&lt;/code> command in
EPOCH uses an if-else format, such that the line:&lt;/p>
&lt;pre>&lt;code> density = if (x gt 20.0e-6, 0, density(Electron))
&lt;/code>&lt;/pre>
&lt;p>means that for cells with $x&amp;gt;20\text{ }\mu\text{m}$, set the density to 0, and
in all other cells, set the density to what it was already (no change).&lt;/p>
&lt;h2 id="rotated-target">Rotated target&lt;/h2>
&lt;p>Let us take the basic target, and rotate it about the point
$(15.0,12.5)\text{ }\mu\text{m}$. To do this, we can set new functions in a
&lt;a href="/documentation/input_deck/input_deck_constant.html">constant block&lt;/a> to help.&lt;/p>
&lt;p>We may use a rotation transformation&lt;/p>
&lt;p>$x' = x\cos(\theta) + y\sin(\theta)$&lt;/p>
&lt;p>$y' = -x\sin(\theta) + y\cos(\theta)$&lt;/p>
&lt;p>to obtain $x$ and $y$ co-ordinates in a rotated co-ordinate system, which makes
the writing of the input.deck more straightforward. An example input.deck is
provided:&lt;/p>
&lt;pre>&lt;code>begin:constant
x0 = 15.0e-6
y0 = 12.5e-6
theta = 30.0 / 180.0 * pi
x_rot = (x-x0)*cos(theta) + (y-y0)*sin(theta)
y_rot = -(x-x0)*sin(theta) + (y-y0)*cos(theta)
end:constant
begin:control
nx = 500
ny = 500
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 25e-6
stdout_frequency = 100
npart = 50 * (5.0e-6/(x_max-x_min)) * nx * ny / sin(theta)
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
frac = 0.8
density = if (x_rot gt 0.0, 1.0e24, 0)
density = if (x_rot gt 5.0e-6, 0, density(Electron))
temp_ev = 1000
end:species
begin:species
name = Carbon
mass = 22033.0
charge = 6.0
frac = 0.2
density = density(Electron) / 6
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="rotated_target.png" alt="Uniform density">&lt;/p>
&lt;p>By creating the &lt;code>x_rot&lt;/code>, &lt;code>y_rot&lt;/code> variables, we can define objects in a rotated
co-ordinate system. In this new system, the &lt;code>x0&lt;/code>, &lt;code>y0&lt;/code> point is the origin, and
&lt;code>theta&lt;/code> is the rotation amount in radians. The number of loaded macro-particles
has been increased by &lt;code>1 / sin(theta)&lt;/code> to account for the fact that more cells
contain particles than in the non-rotated case.&lt;/p>
&lt;h2 id="periodic-structure">Periodic structure&lt;/h2>
&lt;p>We may use a certain trick in the
&lt;a href="/documentation/code_details/maths_parser.html">maths parser&lt;/a> to generate
repeating structures. If we wished to add strucutre to the front surface of a
target, where the repeated unit had a size of $y_r$, then a variable &lt;code>y_f&lt;/code>&lt;/p>
&lt;pre>&lt;code>y_f = (y / y_r) - floor(y / y_r)
&lt;/code>&lt;/pre>
&lt;p>would continuously repeat from 0 to 1 in each periodic window. This can be used
to create a repeating strucutre.&lt;/p>
&lt;p>For example, if the user wished to add a stack of half-spheres to the front of
the target, they may use:&lt;/p>
&lt;pre>&lt;code>begin:constant
x_front = 15.0e-6
circle_radius = 2.0e-6
y_r = 2.0 * circle_radius
y_f = 2.0*((y / y_r) - floor(y / y_r))-1.0
end:constant
begin:control
nx = 500
ny = 500
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 25e-6
stdout_frequency = 100
npart = 50 * (5.0e-6/(x_max-x_min)) * nx * ny
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
frac = 0.8
density = if ((x-x_front)^2 + (y_f * circle_radius)^2 lt circle_radius^2,\
1.0e24, 0)
density = if (x gt x_front and x lt (x_front + 5.0e-6), \
1.0e24, density(Electron))
temp_ev = 1000
end:species
begin:species
name = Carbon
mass = 22033.0
charge = 6.0
frac = 0.2
density = density(Electron) / 6
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="structured_target.png" alt="Uniform density">&lt;/p>
&lt;p>Note: due to the target complexity, I have not tried to force 50 macro-particles
per cell in this simulation.&lt;/p>
&lt;h2 id="load-density-from-file">Load density from file&lt;/h2>
&lt;p>Sometimes a density distribution can be too complicated to set up using the
EPOCH maths parser. In this case, EPOCH can read a binary file where the
density in each cell is specified.&lt;/p>
&lt;p>Binary files can be written by many coding languages. In this example, I used
MATLAB to write a sinusoidal density profile to file, using the code provided
here. Note the order of numbers being written - we perform a full line of $x$
values first, before moving onto the second line at the next $y$.&lt;/p>
&lt;pre>&lt;code class="language-matlab">nx = 500;
ny = 100;
fileID = fopen('density.bin','w');
for iy = 1:ny
for ix = 1:nx
density = abs(sin(ix/20));
fwrite(fileID,density,'double');
end
end
fclose(fileID);
&lt;/code>&lt;/pre>
&lt;p>An input deck was created to read this binary, where I have specified the full
path to the binary file position&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 100
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
npart = 5 * nx * ny
density = '/home/examples/density.bin'
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>This yielded the desired output for the density profile&lt;/p>
&lt;p>&lt;img src="density_from_file.png" alt="Density loaded from binary file">&lt;/p>
&lt;h2 id="momentum-distributions">Momentum distributions&lt;/h2>
&lt;p>While the &lt;code>density&lt;/code> key in EPOCH can be used to set up macro-particle positions,
the &lt;code>temperature&lt;/code> and &lt;code>drift&lt;/code> keys provide momentum distributions. The
&lt;code>temperature&lt;/code> key samples a momentum from a relativistic Maxwell-Jüttner
distribution, and &lt;code>drift&lt;/code> applies a Lorentz boost to these momenta.&lt;/p>
&lt;p>The user may also specify their own momentum distribution, using &lt;code>dist_fn&lt;/code>.
A functional form for the momentum distribution can be written in the
input deck, and
EPOCH can sample momenta from this distribution. As an example, say we wanted a
linearly-increasing distribution for the momentum x-component, from $p_x=0$ to
$p_x = p_{max}$&lt;/p>
&lt;pre>&lt;code>dist_fn = px / p_max
&lt;/code>&lt;/pre>
&lt;p>where the maximum value of &lt;code>dist_fn&lt;/code> has been set to 1. When sampling, EPOCH
will generate $p_x$, $p_y$ and $p_z$ values within a user-chosen range, and
substitute these into the &lt;code>dist_fn&lt;/code> expression yielding a number between 0 and
1. This number corresponds to the probability of keeping the sampled momenta,
or choosing a new set, which is sampled using a uniformly-distributed random
number.&lt;/p>
&lt;p>As an example, the following input deck initialises 3 species. One using only
temperature, one with the same temperature and drift, and the last using
a user-defined function.&lt;/p>
&lt;p>&lt;img src="momentum.png" alt="Momentum distributions">&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 25e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron_temp
mass = 1.0
charge = -1.0
npart = 5 * nx * ny
density = 1.0e24
temp_ev = 1000
end:species
begin:species
name = Electron_temp_drift
mass = 1.0
charge = -1.0
npart = 5 * nx * ny
density = 1.0e24
temp_ev = 1000
drift_x = 1.0e-22
end:species
begin:species
name = Electron_user
mass = 1.0
charge = -1.0
npart = 5 * nx * ny
density = 1.0e24
dist_fn = px / 1.0e-22
dist_fn_px_range = (0, 1.0e-22)
end:species
begin:output
dt_snapshot = t_end
px = always
weight = always
end:output
&lt;/code>&lt;/pre>
&lt;h2 id="load-particles-from-file">Load particles from file&lt;/h2>
&lt;p>If the user requires spatial and momentum distributions too complicated for the
previous methods, then they may perform the ultimate brute-force technique.
Using the
&lt;a href="/documentation/input_deck/input_deck_particle_file.html">particles_from_file block&lt;/a>
the user is able to manually specify the position, momentum and weight of each
macro-particle at the start of the simulation.&lt;/p>
&lt;p>As an example, let us set up a simple simulation where particles
above $y=0$ have
momentum $p_x = 10^{-23}\text{ kgm/s}$, and where $p_x = -10^{-23}\text{ kgm/s}$
below $y=0$. We will also force a uniform density of macro-particles over the
simulation window, and assign each macro-particle a weight of 10. The particle
files to achieve this were written by the following MATLAB code&lt;/p>
&lt;pre>&lt;code class="language-MATLAB">% Simulation parameters
part_count = 1.0e5;
x_min = 0;
x_max = 25.0e-6;
y_min = -5.0e-6;
y_max = 5.0e-6;
px0 = 1.0e-23;
% Set particle properties
x_vals = (x_max - x_min) * rand(1,part_count) + x_min;
y_vals = (y_max - y_min) * rand(1,part_count) + y_min;
w_vals = 10 * ones(1,part_count);
px_vals = px0 * ones(1,part_count);
px_vals(y_vals&amp;lt;0) = -px0;
% Write files
x_file = fopen('x.bin','w');
y_file = fopen('y.bin','w');
w_file = fopen('w.bin','w');
px_file = fopen('px.bin','w');
for i = 1:part_count
fwrite(x_file,x_vals(i),'double');
fwrite(y_file,y_vals(i),'double');
fwrite(w_file,w_vals(i),'double');
fwrite(px_file,px_vals(i),'double');
end
fclose(x_file);
fclose(y_file);
fclose(w_file);
fclose(px_file);
&lt;/code>&lt;/pre>
&lt;p>To load these macro-particles into the simulation, the following input.deck was
used&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 200
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
end:species
begin:particles_from_file
species = Electron
x_data = &amp;quot;/home/examples/x.bin&amp;quot;
y_data = &amp;quot;/home/examples/y.bin&amp;quot;
w_data = &amp;quot;/home/examples/w.bin&amp;quot;
px_data = &amp;quot;/home/examples/px.bin&amp;quot;
end:particles_from_file
begin:output
dt_snapshot = t_end
distribution_functions = always
end:output
begin:dist_fn
name = y_px
ndims = 2
dumpmask = always
direction1 = dir_y
direction2 = dir_px
resolution2 = 100
range2 = (-2.0e-23, 2.0e-23)
include_species:Electron
end:dist_fn
&lt;/code>&lt;/pre>
&lt;p>Here, we have provided the full paths to the particle file locations.
To visualise the distribution of macro-particles in position and momentum
space, we output a distribution function to obtain the expected figure.&lt;/p>
&lt;p>&lt;img src="particles_from_file.png" alt="particles_from_file phase space">&lt;/p>
&lt;h2 id="self-heating">Self-heating&lt;/h2>
&lt;p>Low resolution PIC codes can result in self-heating, where macro-particles can
gain energy non-physically. To measure its effect, we can simulate a small
portion of the simulation and assign periodic boundary conditions. Self-heating
can be reduced by using:&lt;/p>
&lt;ul>
&lt;li>Smaller cell sizes&lt;/li>
&lt;li>More marcro-particles per cell&lt;/li>
&lt;li>Current smoothing (see
&lt;a href="/documentation/input_deck/input_deck_species.html">control block&lt;/a>)&lt;/li>
&lt;li>Higher order macro-particle shapes
(see
&lt;a href="/documentation/basic_usage/compiler_flags.html">pre-compiler flags&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>Let us construct a test example, where we wish to find simulation parameters to
prevent self-heating in a system with electron density $10^{28} \text{ m}^{-3}$
and temperature $1 \text{ keV}$. By omitting an ion species, EPOCH will assume the
presence of a neutralising immobile proton population, at the same density as
the initial electron population. An input deck has been provided for this test,
and we can repeat the test for different cell-sizes, particles per cell,
macro-particle shapes and current-smoothing status.&lt;/p>
&lt;pre>&lt;code>begin:constant
cell_size = 50.0e-9
parts_per_cell = 10
end:constant
begin:control
nx = 10
ny = 10
t_end = 300.0e-15
x_min = 0
x_max = nx * cell_size
y_min = 0
y_max = ny * cell_size
stdout_frequency = 100
smooth_currents = T
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
npart = parts_per_cell * nx * ny
density = 1.0e28
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end/20
temperature = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="self_heat.png" alt="Uniform density">&lt;/p>
&lt;p>As there is no source of energy in this simulation, any temperature increase
must be non-physical. Here we see that as cell-size decreases, or particles per
cell increases, the self-heating is reduced. Switching on current smoothing, or
switching to a higher order macro-particle shape (B-spline) also reduces
self-heating. All these features come at a cost of a greater runtime, so it is
up to the user to decide how much self-heating mitigation is required.&lt;/p></description></item><item><title>Injectors</title><link>/quickstart/basic_examples/injectors.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/injectors.html</guid><description>&lt;p>It is possible to add macro-particles to the simulation window after the initial
macro-particle load using the
&lt;a href="/documentation/input_deck/input_deck_injector.html">injector block&lt;/a>.
This can be done to simulate a particle
beam passing through a boundary, or to replace macro-particles on the boundary
of a flowing plasma volume. EPOCH provides support for two styles of injectors,
one which is specified by plasma properties, and the other which reads particles
from files.&lt;/p>
&lt;h2 id="basic-plasma-injector">Basic plasma injector&lt;/h2>
&lt;p>To demonstrate the basic injector syntax, we have created a simple example. Here
we inject macro-electrons through the &lt;code>x_min&lt;/code> boundary, such that all electrons
have the same momentum, and the macro-particle weights are chosen to ensure the
injected density is $10^{10} \text{ m}^{-3}$. No macro-particles are initially
loaded into the simulation window.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 200
t_end = 20.0e-15
x_min = 0
x_max = 25e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
end:species
begin:injector
boundary = x_min
species = Electron
number_density = 1.0e10
drift_x = 1.0e-20
npart_per_cell = 10
end:injector
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="basic_injector.png" alt="Basic injector">&lt;/p>
&lt;p>This figure shows macro-particles have been injected through the &lt;code>x_min&lt;/code>
boundary,
with weights set to match the desired density.&lt;/p>
&lt;h2 id="flowing-plasma-injector">Flowing plasma injector&lt;/h2>
&lt;p>If we set up a problem where a flowing plasma fills the simulation window, then
the plasma will start to flow through a boundary after the initial load. As
this happens, macro-particles will exit the simulation on one side, leaving a
vacuum on the other side. If we added an injector to the vacuum side, then we
can introduce a source of new macro-particles to replace the lost
macro-particles. To do this, we can set the temperature and number density of
the injector to match that of the initial plasma.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 200
t_end = 20.0e-15
x_min = 0
x_max = 25e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
npart = nx * ny * 10
drift_x = 1.0e-20
temp_ev = 1.0e3
number_density = 1.0e10
end:species
begin:injector
boundary = x_min
species = Electron
number_density = 1.0e10
drift_x = 1.0e-20
temp_ev = 1.0e3
npart_per_cell = 10
end:injector
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="flowing_plasma.png" alt="Flowing plasma number density">&lt;/p>
&lt;p>Here we see that the plasma density is still uniform, even though the plasma
is drifting towards &lt;code>x_max&lt;/code>. Particles above $6\text{ }\mu\text{m}$ were loaded
at the start of the simulation, and those below have been replaced with
injectors. No sign of discontinuity on the injector/initial macro-particle
boundary is present.&lt;/p>
&lt;h2 id="particle-bunch-injection">Particle bunch injection&lt;/h2>
&lt;p>The profile of the injector can be modified to introduce spatial and temporal
variation, which would be useful for describing injected particle bunches.
We can set a Gaussian profile using the &lt;code>gauss(x,x0,w)&lt;/code> function in the
&lt;a href="/documentation/code_details/maths_parser.html">maths parser&lt;/a>, which represents&lt;/p>
&lt;p>$e^{-(x-x_0)^2/w^2}$&lt;/p>
&lt;p>In this formula, $w$ is related to the Gaussian full-width-at-half-maximum
according to&lt;/p>
&lt;p>$w = \frac{fwhm}{2\sqrt{\ln 2}}$&lt;/p>
&lt;p>For the temporal profile, let us simulate the full-width-at-10%-maximum. This
means the peak should arrive in the simulation at the half-width-at-10%-maximum
time, given by&lt;/p>
&lt;p>$hw0.1m = \frac{fwhm}{2} \sqrt{\frac{\ln(10)}{\ln(2)}}$&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 200
t_end = 20.0e-15
x_min = 0
x_max = 25e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
end:species
begin:constant
x_fwhm = 1.0e-6
y_fwhm = 1.0e-6
t_fwhm = x_fwhm / c
w_t = t_fwhm / (2.0 * sqrt(loge(2)))
w_y = y_fwhm / (2.0 * sqrt(loge(2)))
t_hw01m = 0.5 * t_fwhm * sqrt(loge(10) / loge(2))
end:constant
begin:injector
boundary = x_min
species = Electron
number_density = 1.0e10 * gauss(y,0,w_y) * gauss(time,t_hw01m,w_t)
number_density_min = 1.0e9
t_start = 0
t_end = 2.0 * t_hw01m
drift_x = 1.0e-20
temp_ev = 1.0e3
npart_per_cell = 10
end:injector
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="bunch_injector.png" alt="Injected bunch">&lt;/p>
&lt;p>The injected pulse is seen to have the desired properties. Note that we have
introduced a threshold density for macro-particle injection with&lt;/p>
&lt;pre>&lt;code>number_density_min = 1.0e9
&lt;/code>&lt;/pre>
&lt;p>This line ensures that profiled densities below this value will not load
macro-particles into the simulation. This prevents the code from loading too
many low-weight macro-particles which would slow down the code.&lt;/p>
&lt;h2 id="file-injectors">File injectors&lt;/h2>
&lt;p>If the in-built density, temperature and drift do not provide the desired
injection behaviour, or if you&amp;rsquo;re trying to inject specific particles from a
different simulation, then you may find file-injectors useful. Here the user
can specify the injection time, position and momentum of each injected
macro-particle from file. Unlike other file-packages in EPOCH, the
file-injectors read from simple text files.&lt;/p>
&lt;p>For this simple example, let us inject a macro-electron of weight 10 into a
2D simulation window each femtosecond. The momenta of these macro-particles will
be set such that they are highly relativistic, with a speed close to $c$. To
check if they have been injected correctly, let us insert a particle probe
one micron from the injection boundary. Let us also use the &lt;code>-DPROBE_TIME&lt;/code>
compiler flag to see the exact time macro-particles pass the probe. See the
section on
&lt;a href="/documentation/basic_usage/compiler_flags.html">compiler flags&lt;/a>
for help with switching on the probe-time capability.&lt;/p>
&lt;p>We need to use separate files for each macro-particle variable, and particles
must be listed in chronological order of injection. For this demonstration, the
files contain:&lt;/p>
&lt;p>inject_t.txt&lt;/p>
&lt;pre>&lt;code>1.0e-15
2.0e-15
3.0e-15
4.0e-15
5.0e-15
6.0e-15
7.0e-15
8.0e-15
9.0e-15
10.0e-15
&lt;/code>&lt;/pre>
&lt;p>inject_w.txt&lt;/p>
&lt;pre>&lt;code>10
10
10
10
10
10
10
10
10
10
&lt;/code>&lt;/pre>
&lt;p>inject_y.txt&lt;/p>
&lt;pre>&lt;code>0
0
0
0
0
0
0
0
0
0
&lt;/code>&lt;/pre>
&lt;p>inject_px.txt&lt;/p>
&lt;pre>&lt;code>1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
&lt;/code>&lt;/pre>
&lt;p>and the input.deck reads:&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 200
t_end = 20.0e-15
x_min = 0
x_max = 25e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
end:species
begin:injector
boundary = x_min
species = Electron
inject_from_file = T
y_data = &amp;quot;inject_y.txt&amp;quot;
px_data = &amp;quot;inject_px.txt&amp;quot;
w_data = &amp;quot;inject_w.txt&amp;quot;
t_data = &amp;quot;inject_t.txt&amp;quot;
end:injector
begin:output
dt_snapshot = t_end
particle_probes = always
end:output
begin:probe
name = Electron_probe
point = (1.0e-6, 0.0)
normal = (1.0, 0.0)
ek_min = 0.0
ek_max = -1.0
include_species:Electron
dumpmask = always
end:probe
&lt;/code>&lt;/pre>
&lt;p>For injector files, the code will look in the same directory as the input.deck
file. The full path is not required like in other file-reading blocks. If we
open &lt;code>0001.sdf&lt;/code> (possibly using the GetDataSDF.m function in
&lt;code>epoch/SDF/Matlab&lt;/code>), we see the times each macro-particle passes the probe. We
can label each macro-particle by its line in the injector files, and we can
obtain a probe-time vs file-line plot&lt;/p>
&lt;p>&lt;img src="file_injector.png" alt="File injector times">&lt;/p>
&lt;p>Due to the position of the probe, and the speed of the macro-particles, we
expect these probe times to be 3.337 fs after the particle injection time. This
matches the behaviour seen in the probe data, which shows that the file
injectors are working as intended.&lt;/p></description></item><item><title>Ionisation</title><link>/quickstart/basic_examples/ionisation.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/ionisation.html</guid><description>&lt;p>Particles within an EPOCH simulation have the option to be ionised through
either field ionisation, or electron-impact collisional ionisation. The keys
required to set up ionisation are found in multiple blocks, and a summary may be
found in the
&lt;a href="/documentation/input_deck/input_deck_species.html">species block&lt;/a>
documentation. This page provides simple demos for the ionisation packages.&lt;/p>
&lt;p>In general, the user defines an initial ion species, and the code automatically
generates species for the ionised states. During ionisation, a bound electron is
released from an ion, and added to an electron species as a macro-particle.&lt;/p>
&lt;h2 id="field-ionisation">Field ionisation&lt;/h2>
&lt;p>In field ionisation, ions are created in the presence of strong laser fields. In
this 1D input deck, a laser moves from the &lt;code>x_min&lt;/code> boundary towards a block of
neutral carbon. EPOCH can identify the ion species as neutral carbon, as the
&lt;code>charge&lt;/code> and &lt;code>atomic_no&lt;/code> have been specified in the
&lt;a href="/documentation/input_deck/input_deck_species.html">species block&lt;/a>.&lt;/p>
&lt;p>The species
block also tells EPOCH that the &lt;code>Carbon&lt;/code> species can be ionised since the
&lt;code>ionise = T&lt;/code> line is provided. The number of possible ionisation states has been
manually cut-off at 3 by the &lt;code>ionise_limit&lt;/code> key. When an ionisation occurs, a
new macro-electron is generated and assigned to a species which will be
automatically generated, as specified by &lt;code>unique_electron_species = T&lt;/code>.&lt;/p>
&lt;p>Once the ionisation keys in the species block have been activated, we need to
tell EPOCH what kind of ionisation should occur. Here, we switch on the field
ionisation process using the
&lt;a href="/documentation/input_deck/input_deck_control.html">control block&lt;/a> key
&lt;code>field_ionisation&lt;/code>.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 128
npart = 20 * nx
t_end = 42.4e-15
x_min = 0
x_max = 4.0e-6
field_ionisation = T
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
end:boundaries
begin:laser
boundary = x_min
intensity = 3.0e15 * 1.0e4
lambda = 800.0e-9
t_profile = 1
t_end = 10.7e-15
end:laser
begin:species
name = Carbon
charge = 0
atomic_no = 6
mass = 1836.2 * 16.0
frac = 1
rho = if ((x lt 3.30e-6) and (x gt 3.05e-6), 1.74e24, 0)
ionise = T
ionise_limit = 3
unique_electron_species = T
end:species
begin:output
dt_snapshot = t_end/100
number_density = always + species
end:output
&lt;/code>&lt;/pre>
&lt;p>Once the &lt;code>input.deck&lt;/code> directory has been selected, &lt;code>EPOCH&lt;/code> prints:&lt;/p>
&lt;pre>&lt;code> Name of species 1 is Carbon
Name of species 2 is Carbon1
Name of species 3 is electron_from_Carbon
Name of species 4 is Carbon2
Name of species 5 is electron_from_Carbon1
Name of species 6 is Carbon3
Name of species 7 is electron_from_Carbon2
Initial conditions complete and valid.
Redistributing. Balance: 0.254, after: 0.507 (pre-load balance)
Attempting to load particles
Loaded 2560 particles of species &amp;quot;Carbon&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Here we see that although only one species is present in the &lt;code>input.deck&lt;/code>, EPOCH
has generated species for Carbon with charge-states 1-3. If we had not included
&lt;code>ionise_limit&lt;/code>, we would have generated species up to fully ionised Carbon.
Also, by setting &lt;code>unique_electron_species = T&lt;/code>, the code has generated species
for electrons released by specific ions during ionisation. We also see no
macro-particles have been initially loaded into these automatically generated
species, as only Carbon has a specified density in the &lt;code>input.deck&lt;/code>.&lt;/p>
&lt;p>Once the simulation is complete, we can plot the number densities of each
species at different times. As can be seen below, the system originally starts
with only neutral carbon present, but ends with carbon ions of charge-state 2
and 3 after illumination by the laser.&lt;/p>
&lt;p>&lt;img src="field_ionise_space.png" alt="Spatial distribution of charge populations">&lt;/p>
&lt;p>We can also plot the fraction of carbon ions in each charge-state as a function
of time:&lt;/p>
&lt;p>&lt;img src="field_ionise_rate.png" alt="Charge populations over time for field ionisation">&lt;/p>
&lt;h2 id="collisional-ionisation">Collisional ionisation&lt;/h2>
&lt;p>In collisional ionisation, ions undergo ionisation through collisions with
electrons. In this simulation, the domain is filled with an equal number of electrons and
neutral carbon atoms, and collisional ionisation between the two species
generates carbon ions and ejected electrons.&lt;/p>
&lt;p>As in the field ionisation example, the &lt;code>Carbon&lt;/code> species uses
&lt;code>ionise = T&lt;/code> to identify the species as one which can ionise. Without
&lt;code>ionise_limit&lt;/code>, we allow ionisation up to fully-ionised carbon. In this example,
we create an empty electron species &lt;code>Ejected_electron&lt;/code>, which will be used to
store macro-electrons which are ejected from ions during ionisation.&lt;/p>
&lt;p>As collisional ionisation refers to ionisation when electrons hit ions, the code
needs to know which species are electron species. For the &lt;code>Electron_beam&lt;/code>
species, the line &lt;code>identify:electron&lt;/code> tells EPOCH the species can trigger
collisional ionisation. Also, EPOCH knows &lt;code>Ejected_elctron&lt;/code> is an electron
species, because it is identified as a species to populate with electrons
ejected in the ionisation process from carbon ions.&lt;/p>
&lt;p>Collisional ionisation is switched on using the &lt;code>collisional_ionisation=T&lt;/code> line
in the
&lt;a href="/documentation/input_deck/input_deck_collisions.html">collisions block&lt;/a>.
Note that this does not switch on Coulomb scatter collisions between species, as
this is a separate process from collisional ionisation.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 128
npart = 200 * nx
t_end = 300.0e-15
x_min = 0
x_max = 4.0e-6
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
end:boundaries
begin:collisions
collisional_ionisation = T
end:collisions
begin:species
name = Electron_beam
frac = 0.5
rho = 2.0e24
temp_ev = 80
identify:electron
end:species
begin:species
name = Carbon
charge = 0
atomic_no = 6
mass = 1836.2 * 16.0
frac = 0.5
rho = 2.0e24
ionise = T
electron_species = Ejected_electron
end:species
begin:species
name = Ejected_electron
frac = 0
charge = -1
mass = 1
end:species
begin:output
dt_snapshot = t_end/100
number_density = always + species
end:output
&lt;/code>&lt;/pre>
&lt;p>When we run this simulation, EPOCH prints the lines:&lt;/p>
&lt;pre>&lt;code> Name of species 1 is Electron_beam
Name of species 2 is Carbon
Name of species 3 is Ejected_electron
Name of species 4 is Carbon1
Name of species 5 is Carbon2
Name of species 6 is Carbon3
Name of species 7 is Carbon4
Name of species 8 is Carbon5
Name of species 9 is Carbon6
&lt;/code>&lt;/pre>
&lt;p>where the ionisation species Carbon1-Carbon6 have been automatically generated.
Initially these ionised carbon particle species contain no macro-particles.&lt;/p>
&lt;p>This simulation generates some Carbon1 ions and a small number of Carbon2. The
collisional ionisation cross section is too low here to ionise to the higher
charge states. A plot of the population fraction over time is given here:&lt;/p>
&lt;p>&lt;img src="coll_ionise_rate.png" alt="Charge populations over time for collisional ionisation">&lt;/p></description></item><item><title>Restart from SDF dump</title><link>/quickstart/basic_examples/restart_example.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/restart_example.html</guid><description>&lt;p>It can sometimes be useful to restart an &lt;strong>EPOCH&lt;/strong> simulation from an SDF file.
Supercomputers may often place limits on job length, or systems may be prone to
crashing, so code-restarts can help prevent CPU waste.&lt;/p>
&lt;p>Using the &lt;strong>EPOCH&lt;/strong>
&lt;a href="/documentation/input_deck/input_deck_output_block.html">output block&lt;/a>,
the user is able to force the code to write restart-dumps. These differ from
regular dumps, as they write all the particle and field properties required to
restart the simulation. These will quite often be large and slow files to write,
so there is a trade-off between simulation speed (no restarts) and safety (many
restart dumps).&lt;/p>
&lt;p>In this page we will simulate a basic laser injected into a vacuum, and run the
simulation with and without restarts.&lt;/p>
&lt;h2 id="no_restart">Simulation set-up&lt;/h2>
&lt;p>Here we provide the input deck for a basic 2D simulation where a plane wave
enters
the simulation window through the &lt;code>x_min&lt;/code> boundary. This creates an SDF file
containing the &lt;code>Ey&lt;/code> field every 10 fs. This is a lightweight diagnostic, and
is not sufficient to restart the whole simulation. A plot of the electric field
from the &lt;code>0010.sdf&lt;/code> file is also present, along with the MATLAB script which
created it (other post-processing tools are available). Instructions on running
EPOCH input decks are provided
&lt;a href="/quickstart.html">here&lt;/a>.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 100 * femto
x_min = 0.0
x_max = 10.0e-6
y_min = -5.0e-6
y_max = 5.0e-6
stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
lambda = 1.0e-6
profile = 1.0
t_profile = 1.0
end:laser
begin:output
dt_snapshot = 10.0e-15
ey = always
end:output
&lt;/code>&lt;/pre>
&lt;p>This code took 3 seconds to run on a 4 core laptop. For the MATLAB
post-processing, the contents of &lt;code>epoch/SDF/MATLAB&lt;/code> were copied into the
directory containing the SDF files and &lt;code>input.deck&lt;/code>, and a plot was generated
using this script:&lt;/p>
&lt;pre>&lt;code class="language-MatLab">% Extract data
data = GetDataSDF('0010.sdf');
% Format grid
x_edges = data.Electric_Field.Ey.grid.x;
y_edges = data.Electric_Field.Ey.grid.y;
x_centres = 0.5*(x_edges(2:end) + x_edges(1:end-1));
y_centres = 0.5*(y_edges(2:end) + y_edges(1:end-1));
[x_plot, y_plot] = meshgrid(x_centres, y_centres);
% Create and format plot
surf(x_plot*1.0e6, y_plot*1.0e6, data.Electric_Field.Ey.data','EdgeColor','none');
view(2);
xlabel('x [\mum]');
ylabel('y [\mum]');
cbar = colorbar;
cbar.Label.String = 'Ey [V/m]';
ax = gca;
ax.FontSize = 16;
title(sprintf('%g fs',data.time*1.0e15));
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="restart_example.png" alt="Ey field in basic example">&lt;/p>
&lt;h2 id="restarting-from-simulation-end">Restarting from simulation end&lt;/h2>
&lt;p>Now we have a basic script, let us run it in two simulations loading the second
from a restart-dump. In our first run, we will reduce the run-time to 50 fs, and
force the final dump to be restartable. We will start the second simulation from
the 50 fs restart-dump, and run to completion.&lt;/p>
&lt;p>For the first run, take the previous &lt;code>input.deck&lt;/code> and make some changes.
Firstly, change &lt;code>t_end&lt;/code> in the control block from &lt;code>100 * femto&lt;/code> to &lt;code>50 * femto&lt;/code>.
Next, add the following line to the output block:&lt;/p>
&lt;pre>&lt;code>force_final_to_be_restartable = T
&lt;/code>&lt;/pre>
&lt;p>When we run this simulation, we find that we generate output files from
&lt;code>0000.sdf&lt;/code> to &lt;code>0005.sdf&lt;/code>. If we inspect the file-sizes, we&amp;rsquo;ll see that
&lt;code>0005.sdf&lt;/code> has a size of 18 MB, while the rest have 2 MB - our restart-dump file
is much larger.&lt;/p>
&lt;p>For the restarted run, change &lt;code>t_end&lt;/code> in the control block back to
&lt;code>100 * femto&lt;/code>, and add the control block line:&lt;/p>
&lt;pre>&lt;code>restart_snapshot = 5
&lt;/code>&lt;/pre>
&lt;p>When running the restarted deck, &lt;strong>EPOCH&lt;/strong> will print the lines:&lt;/p>
&lt;pre>&lt;code> Loading snapshot for time 5.0012906556442301E-014
Input file contains 29 blocks
Load from restart dump OK
&lt;/code>&lt;/pre>
&lt;p>if run successfully. You&amp;rsquo;ll see the SDF files continue from where they left off,
and if we were to once again print the &lt;code>Ey&lt;/code> field at &lt;code>0010.sdf&lt;/code>, we once again
find what we had before:&lt;/p>
&lt;p>&lt;img src="restart_example.png" alt="Ey field in basic example">&lt;/p>
&lt;h2 id="restart-checkpoints">Restart checkpoints&lt;/h2>
&lt;p>The previous example assumed you could split your simulation up into obvious
chunks, but what if the nodes you run on have a tendency to crash? In this case,
it would make more sense to make multiple restart dumps. While this could be
achieved by replacing &lt;code>force_final_to_be_restartable&lt;/code> with &lt;code>restart_dump_every&lt;/code>
to make multiple restart dumps, you may want to separate your restart dumps from
your usual dumps. This can be done using multiple output blocks.&lt;/p>
&lt;p>The previous example has been extended to produce two sets out output files, one
labelled &lt;code>normal0000.sdf&lt;/code> to &lt;code>normal0010.sdf&lt;/code>, and the other labelled
&lt;code>restart0000.sdf&lt;/code> to &lt;code>restart0005.sdf&lt;/code>.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 100 * femto
x_min = 0.0
x_max = 10.0e-6
y_min = -5.0e-6
y_max = 5.0e-6
stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
lambda = 1.0e-6
profile = 1.0
t_profile = 1.0
end:laser
begin:output
name = normal
file_prefix = normal
dt_snapshot = 10.0e-15
ey = always
end:output
begin:output
name = restart
file_prefix = restart
restartable = T
dt_snapshot = 20.0e-15
end:output
&lt;/code>&lt;/pre>
&lt;p>As before, the &lt;code>normal&lt;/code> dumps only contain the &lt;code>Ey&lt;/code> data. However, because the
output block named &lt;code>restart&lt;/code> contains the &lt;code>restartable=T&lt;/code> flag, all these dumps
will be restart dumps. Once we have this, we can restart from any of the restart
SDF files. Because
these files now have a prefix, we must add a line like:&lt;/p>
&lt;pre>&lt;code>restart_snapshot = restart0004.sdf
&lt;/code>&lt;/pre>
&lt;p>to the control block, where we use the full file-name.&lt;/p>
&lt;h2 id="restart-at-end-of-the-cluster-job-allocation">Restart at end of the cluster job allocation&lt;/h2>
&lt;p>The issue with regular checkpoints is that it may be overkill for your job, and
any CPU time spent after the final checkpoint is wasted when you come to
restart. Also, writing a restart dump at the end of a simulation is less useful
when you run on supercomputers, as you don&amp;rsquo;t know where you&amp;rsquo;ll be at the end of
your maximum job time!&lt;/p>
&lt;p>In this case, you need a way to automatically stop the simulation as you near
the end of your allotted time, and &lt;em>then&lt;/em> write a restart dump so you can
continue later. This can be achieved using the &lt;code>STOP&lt;/code> file.&lt;/p>
&lt;p>While running, &lt;strong>EPOCH&lt;/strong> continuously scans the directory containing
&lt;code>input.deck&lt;/code> for a file with a filename &lt;code>STOP&lt;/code>. When this file appears,
&lt;strong>EPOCH&lt;/strong> completes the current time-step, writes a restart dump, ends the
simulation, and deletes the &lt;code>STOP&lt;/code> file. No lines need to be added to the
&lt;code>input.deck&lt;/code> in order to use the &lt;code>STOP&lt;/code> functionality.&lt;/p>
&lt;p>For example, if you were to submit an &lt;strong>EPOCH&lt;/strong> job on a super-computer with an
allocated time of 5 hours, and you wanted the code to stop at 4 hours 30 mins
(leaving you 30 minutes to write a restart dump), you could add the line:&lt;/p>
&lt;pre>&lt;code>(sleep 16200; touch STOP) &amp;amp;
&lt;/code>&lt;/pre>
&lt;p>to your job-script just before &lt;strong>EPOCH&lt;/strong> is run. This will create a background
process which will wait 16200 seconds, then create the &lt;code>STOP&lt;/code> file in the
working directory of the original command. If this is the same directory as your
input deck,
this will stop the code with (hopefully) enough time to write the restart dump.
You may want to check in advance how long a restart dump takes to write for your
project, to get the timing of the &lt;code>STOP&lt;/code> file appearence correct.&lt;/p></description></item></channel></rss>