<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Basic usage | EPOCH</title><link>/documentation/basic_usage.html</link><atom:link href="/documentation/basic_usage/index.xml" rel="self" type="application/rss+xml"/><description>Basic usage</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><image><url>/images/logo_hub4b4d6a0f57638acebb5550a80c8c030_9243_300x300_fit_lanczos_2.png</url><title>Basic usage</title><link>/documentation/basic_usage.html</link></image><item><title>FAQs</title><link>/documentation/basic_usage/faq.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/faq.html</guid><description>&lt;h2 id="is-this-manual-up-to-date">Is this manual up to date?&lt;/h2>
&lt;p>Whenever a new milestone version of &lt;strong>EPOCH&lt;/strong> is finalised, the version
number is changed and this manual is updated accordingly. The version
number of the manual should match the first two digits for that of the
&lt;strong>EPOCH&lt;/strong> source code. This version number is printed to screen when you
run the code. The line looks something like the following:&lt;/p>
&lt;pre>&lt;code> Welcome to EPOCH2D version 4.16.0 (commit v4.16.0-0-g69eb0fa6-clean)
&lt;/code>&lt;/pre>
&lt;p>Here, only the number &amp;ldquo;4.16&amp;rdquo; is important.&lt;/p>
&lt;p>Since version 3.1 of the manual, new additions and changes are mentioned
in the appendix.&lt;/p>
&lt;h2 id="what-is-epoch">What is &lt;strong>EPOCH&lt;/strong>?&lt;/h2>
&lt;p>&lt;strong>EPOCH&lt;/strong> is a plasma physics simulation code which uses the Particle in
Cell (PIC) method. In this method, collections of physical particles are
represented using a smaller number of pseudoparticles, and the fields
generated by the motion of these pseudoparticles are calculated using a
finite difference time domain technique on an underlying grid of fixed
spatial resolution. The forces on the pseudoparticles due to the
calculated fields are then used to update the pseudoparticle velocities,
and these velocities are then used to update the pseudoparticle
positions. This leads to a scheme which can reproduce the full range of
classical micro-scale behaviour of a collection of charged particles.&lt;/p>
&lt;h3 id="features-of-epoch">Features of &lt;strong>EPOCH&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>MPI parallelised, explicit, second-order, relativistic PIC code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dynamic load balancing option for making optimal use of all
processors when run in parallel.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MPI-IO based output, allowing restart on an arbitrary number of
processors.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Data analysis and visualisation options include ITT IDL, LLNL VisIt,
Mathworks MatLab and matplotlib in Python.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Control of setup and runs of &lt;strong>EPOCH&lt;/strong> through a customisable input
deck.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="the-origins-of-the-code">The origins of the code&lt;/h2>
&lt;p>The &lt;strong>EPOCH&lt;/strong> family of PIC codes is based on the older PSC code written
by Hartmut Ruhl and retains almost the same core algorithm for the field
updates and particle push routines. &lt;strong>EPOCH&lt;/strong> was written to add more
modern features and to structure the code in such a way that future
expansion of the code is made as easy as possible.&lt;/p>
&lt;h2 id="how_do_i_obtain_the_code">How do I obtain the code?&lt;/h2>
&lt;p>The latest version of &lt;strong>EPOCH&lt;/strong> can be found on GitHub at
&lt;a href="https://github.com/Warwick-Plasma/epoch">https://github.com/Warwick-Plasma/epoch&lt;/a>&lt;/p>
&lt;p>A tarred and gzipped archive (commonly referred to as a tarball) of the latest
release is always made available in the
&lt;a href="https://github.com/Warwick-Plasma/epoch/releases" target="_blank" rel="noopener">Releases&lt;/a> section&lt;/p>
&lt;p>Alternately, using git the code can be cloned using the following command.
Note that it is important to include the &amp;lsquo;&amp;lsquo;recursive&amp;rsquo;&amp;rsquo; flag in order to
download the SDF submodules..&lt;/p>
&lt;p>&lt;code>git clone &amp;ndash;recursive &lt;a href="https://github.com/Warwick-Plasma/epoch.git">https://github.com/Warwick-Plasma/epoch.git&lt;/a>&lt;/code>&lt;/p>
&lt;h2 id="what-normalisations-are-used-in-epoch">What normalisations are used in &lt;strong>EPOCH&lt;/strong>?&lt;/h2>
&lt;p>Since the idea from the start was that &lt;strong>EPOCH&lt;/strong> would be used by a
large number of different users and that it should be as easy as
possible to &amp;ldquo;plug in&amp;rdquo; different modules from different people into a
given copy of the code, it was decided to write &lt;strong>EPOCH&lt;/strong> in SI units.
There are a few places in the code where some quantities are given in
other units for convenience (for example charges are specified in
multiples of the electron charge), but the entire core of the code is
written in SI units.&lt;/p>
&lt;h2 id="what-are-those-_num-things-doing-everywhere">What are those &lt;code>_num&lt;/code> things doing everywhere?&lt;/h2>
&lt;p>Historically using the compiler auto-promotion of &lt;code>REAL&lt;/code> to
&lt;code>DOUBLE PRECISION&lt;/code> was unreliable, so &lt;strong>EPOCH&lt;/strong> uses &amp;ldquo;kind&amp;rdquo; tags to
specify the precision of the code. The &lt;code>_num&lt;/code> suffixes and the
associated definition of &lt;code>REAL&lt;/code>s as &lt;code>REAL(num)&lt;/code> are these &amp;ldquo;kind&amp;rdquo; tags in
operation. The &lt;code>_num&lt;/code> tags force numerical constants to match the
precision of the code, preventing errors due to precision conversion.
The important thing is that all numerical constants should be tagged
with an &lt;code>_num&lt;/code> tag and all &lt;code>REAL&lt;/code>s should be defined as &lt;code>REAL(num)&lt;/code>.&lt;/p>
&lt;h2 id="what-is-an-input-deck">What is an input deck?&lt;/h2>
&lt;p>An input deck is text file which can be used to set simulation
parameters for &lt;strong>EPOCH&lt;/strong> without needing to edit or recompile the source
code. It consists of a list of blocks which start as &lt;strong>begin:blockname&lt;/strong>
and end with &lt;strong>end:blockname&lt;/strong>. Within the body of each block is a list
of key/value pairs, one per line, with key and value separated by an
equals sign. Most aspects of a simulation can be controlled using an
input deck, such as the number of grid points in the simulation domain,
the initial distribution of particles and initial electromagnetic field
configuration. It is designed to be relatively easy to read and edit.
For most projects it should be possible to set up a simulation without
editing the source code at all. For more details, read the section
titled
&lt;a href="/documentation/input_deck/input_deck">&amp;ldquo;The EPOCH input deck&amp;rdquo;&lt;/a>&lt;/p>
&lt;h2 id="i-just-want-to-use-the-code-as-a-black-box-or-im-just-starting" class="-how-do-i-do-that">I just want to use the code as a black box, or I&amp;rsquo;m just starting. How do I do that?&lt;/h2>
&lt;p>Begin by reading
&lt;a href="/documentation/examples/basic_examples">the basic examples&lt;/a>.
There&amp;rsquo;s quite a lot to learn in order to get
started, so you should plan to read through all of this section. You
will also need to refer to
&lt;a href="/documentation/input_deck/input_deck">the input deck pages&lt;/a>.
Next, look at the code and have a play with some test problems. After
that re-read this section. This should be enough for testing simple
problems.&lt;/p>
&lt;h2 id="what-is-the-auto-loader">What is the auto-loader?&lt;/h2>
&lt;p>Throughout this document we will often refer to the &amp;ldquo;auto-loader&amp;rdquo; when
setting up the initial particle distribution. In the input deck it is
possible to specify a functional form for the density and temperature of
a particle species. &lt;strong>EPOCH&lt;/strong> will then place the particles to match the
density function and set the velocities of the particles so that they
match the Maxwellian thermal distribution for the temperature. The code
which performs this particle set up is called the &amp;ldquo;auto-loader&amp;rdquo;.&lt;/p>
&lt;p>At present, there is no way to specify a non-Maxwellian particle
distribution from within the input deck. In such cases, it is necessary
to edit and recompile the &lt;strong>EPOCH&lt;/strong> source code. The recommended method
for setting the initial particle properties is to use the
&amp;ldquo;&lt;code>manual_load&lt;/code>&amp;rdquo; function as described
&lt;a href="/documentation/code_details/using_epoch_in_practice#manually_overriding_particle_parameters_set_by_the_autoloader">here&lt;/a>.&lt;/p>
&lt;h2 id="what-is-a-maths-parser">What is a maths parser?&lt;/h2>
&lt;p>As previously mentioned, the behaviour of &lt;strong>EPOCH&lt;/strong> is controlled using
an input deck which contains a list of key/value pairs. The value part
of the pair is not restricted to simple constants but can be a complex
mathematical expression. It is evaluated at run time using a section of
code called the &amp;ldquo;maths parser&amp;rdquo;. There is no need for the end user to
know anything about this code. It is just there to enable the use of
mathematical expressions in the input deck. Further information about
this facility can be found
&lt;a href="/documentation/code_details/maths_parser">here&lt;/a>.&lt;/p>
&lt;h2 id="i-am-an-advanced-user-but-i-want-to-set-up-the-code-so-that-less-experienced-users-can-use-it" class="-how-do-i-do-that">I am an advanced user, but I want to set up the code so that less experienced users can use it. How do I do that?&lt;/h2>
&lt;p>See
&lt;a href="/documentation/code_details/using_epoch_in_practice#parameterising_input_decks">here&lt;/a>.&lt;/p>
&lt;h2 id="i-want-to-develop-an-addition-to-epoch" class="-how-do-i-do-that">I want to develop an addition to &lt;strong>EPOCH&lt;/strong>. How do I do that?&lt;/h2>
&lt;p>A slightly outdated developers manual exists which should be sufficient
to cover most aspects of the code functionality. However, the code is
written in a fairly modular and consistent manner, so reading through
that is the best source of information. If you get stuck then you can
post questions on the GitHub forums.&lt;/p>
&lt;h2 id="i-want-to-have-a-full-understanding-of-how-epoch-works" class="-how-do-i-do-that">I want to have a full understanding of how &lt;strong>EPOCH&lt;/strong> works. How do I do that?&lt;/h2>
&lt;p>If you really want to understand &lt;strong>EPOCH&lt;/strong> in full, the only way is to
read all of this manual and then read through the code. Most of it is
commented.&lt;/p>
&lt;h2 id="how-do-i-acknowledge-use-of-the-code">How do I acknowledge use of the code?&lt;/h2>
&lt;p>See
&lt;a href="/documentation/basic_usage/acknowledging_epoch">here&lt;/a>.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Code structure</title><link>/documentation/basic_usage/structure.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/structure.html</guid><description>&lt;p>When obtained, the EPOCH codes all have a similar structure. If the
tarred and gzipped archive (commonly referred to as a tarball) is
downloaded and unpacked into the user&amp;rsquo;s &lt;code>$HOME&lt;/code> directory, then the
extracted contents will consist of a directory named
&amp;ldquo;&lt;code>$HOME/epoch-4.12.0&lt;/code>&amp;rdquo; (with &amp;ldquo;4.12.0&amp;rdquo; substituted by the current version
number) and the subdirectories and files listed below.&lt;/p>
&lt;p>Alternatively, if the code is checked out from the GitHub git repository
with the command&lt;/p>
&lt;p>&lt;code>git clone --recursive https://github.com/Warwick-Plasma/epoch.git&lt;/code>&lt;/p>
&lt;p>then the directory will be &amp;ldquo;&lt;code>$HOME/epoch&lt;/code>&amp;rdquo;.&lt;/p>
&lt;p>Once the code has been obtained, the top-level directory will contain
the following 4 directories and several files&lt;/p>
&lt;ul>
&lt;li>epoch1d - Source code and other files required for the 1D version of
EPOCH.&lt;/li>
&lt;li>epoch2d - Source code and other files required for the 2D version of
EPOCH.&lt;/li>
&lt;li>epoch3d - Source code and other files required for the 3D version of
EPOCH.&lt;/li>
&lt;li>SDF - Source code for the SDF file format which is used to generate
output for EPOCH runs. This directory also includes various tools
and readers for working with SDF files.&lt;/li>
&lt;li>CHANGELOG - A brief overview of the change history for each released
version of EPOCH.&lt;/li>
&lt;li>CODING_STYLE - This document contains the conventions which must be
used for any code being submitted for inclusion in the EPOCH
project.&lt;/li>
&lt;li>LICENSE - A copy of the GPLv3 license which is used by the EPOCH
project.&lt;/li>
&lt;li>README.md - A brief overview of obtaining and using the EPOCH code.&lt;/li>
&lt;li>make_tarball.sh - This is a shell script which is used for creating
the tarred and gzipped archives of EPOCH which are posted to the
GitHub server each time a new release is made.&lt;/li>
&lt;li>test_all.sh - A regression test script used when testing the code.&lt;/li>
&lt;/ul>
&lt;p>The three EPOCH subdirectories all have a similar structure. Inside each
of the epoch{1,2,3}d directories, there are 3 sub-directories:&lt;/p>
&lt;ul>
&lt;li>src - The EPOCH source code.&lt;/li>
&lt;li>example_decks - A sample data directory containing example input
deck files.&lt;/li>
&lt;li>Data - This is an empty directory to use for running simulations.&lt;/li>
&lt;/ul>
&lt;p>there are also 3 files:&lt;/p>
&lt;ul>
&lt;li>Makefile - A standard makefile.&lt;/li>
&lt;li>Start.pro - An IDL script which starts the IDL visualisation
routines. Execute it using &amp;ldquo;idl Start&amp;rdquo;.&lt;/li>
&lt;li>unpack_source_from_restart - Restart dumps can be written to
contain a copy of the input decks and source code used to generate
them. This script can be used to unpack that information from a
given restart dump. It is run from the command line and must be
passed the name of the restart dump file.&lt;/li>
&lt;/ul></description></item><item><title>Compiling EPOCH</title><link>/documentation/basic_usage/compiling.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/compiling.html</guid><description>&lt;p>To compile EPOCH in the supplied state, you must first change to the
correct working directory. As explained in , the root directory for
EPOCH contains several subdirectories, including separate directories
for each of the 1D, 2D and 3D versions of the code. To compile the 2D
version of the code, you first switch to the &amp;ldquo;epoch2d&amp;rdquo; directory using
the command
&lt;strong>&lt;code>cd $HOME/epoch/epoch2d&lt;/code>&lt;/strong>
and then type
&lt;strong>&lt;code>make&lt;/code>&lt;/strong>
and the code will compile. There are certain options within the code
which are controlled by compiler preprocessors and are described in the
next section. When the code is compiled, it creates a new directory
called &amp;ldquo;bin&amp;rdquo; containing the compiled binary which will be called
&lt;code>epoch1d&lt;/code>, &lt;code>epoch2d&lt;/code> or &lt;code>epoch3d&lt;/code>. To run the code, just execute the
binary file by typing:
&lt;strong>&lt;code>./bin/epoch2d&lt;/code>&lt;/strong>
or whatever the correct binary is for the dimensionality of the code
that you have. You should be given a screen which begins with the EPOCH
logo, and then reads:&lt;/p>
&lt;pre>&lt;code>The code was compiled with no compile time options
Welcome to EPOCH2D version 4.12.0 (commit v4.12.0-0-gfd74a464-clean)
Code is running on 1 processing elements
Specify output directory
&lt;/code>&lt;/pre>
&lt;p>At this point, the user simply types in the name of the (already
existing) output directory and the code will read the input deck files
inside the specified directory and start running. To run the code in
parallel, just use the normal mpirun or mpiexec scripts supplied by your
MPI implementation. If you want the code to run unattended, then you
will need to pipe in the output directory name to be used. The method
for doing this varies between MPI implementations. For many MPI
implementations (such as recent versions of OpenMPI) this can be
achieved with the following:
&lt;strong>&lt;code>echo Data | mpirun -np 2 ./bin/epoch2d&lt;/code>&lt;/strong>
Some cluster setups accept the following instead:
&lt;strong>&lt;code>mpirun -np 2 ./bin/epoch2d &amp;lt; deck.file&lt;/code>&lt;/strong>
where &amp;ldquo;deck.file&amp;rdquo; is a file containing the name of the output directory.
Some cluster queueing systems do not allow the use of input pipes to
mpirun. In this case, there is usually a &amp;ldquo;-stdin&amp;rdquo; command line option to
specify an input file. See your cluster documentation for more details.&lt;/p>
&lt;p>As of version 4.2.12, EPOCH now checks for the existence of a file named
&amp;ldquo;USE_DATA_DIRECTORY&amp;rdquo; in the current working directory before it
prompts the user for a Data directory. If such a file exists, it reads
it to obtain the name of the data directory to use and does not prompt
the user. If no such file exists, it prompts for a data directory name
as before. This is useful for cluster setups in which it is difficult or
impossible to pipe in the directory name using a job script.&lt;/p>
&lt;p>The &amp;ldquo;Makefile&amp;rdquo; contains configurations for fort, gfortran, pgi, g95,
hector/archer and ibm (the compiler suite used on IBM&amp;rsquo;s BlueGene
machines). In order to compile using one of the listed configurations,
add the &amp;ldquo;&lt;code>COMPILER=&lt;/code>&amp;rdquo; option to the &amp;ldquo;&lt;code>make&lt;/code>&amp;rdquo; command. For example
&lt;strong>&lt;code>make COMPILER=gfortran&lt;/code>&lt;/strong>
will compile the code using the gfortran compiler and appropriate
compiler flags. The options are&lt;/p>
&lt;ul>
&lt;li>COMPILER=gfortran - GNU Fortran&lt;/li>
&lt;li>COMPILER=intel - Intel ifort&lt;/li>
&lt;li>COMPILER=pgi - Portland group compiler&lt;/li>
&lt;li>COMPILER=g95 - G95 compiler&lt;/li>
&lt;li>COMPILER=ibm - IBM AIX Fortran compiler for BlueGene&lt;/li>
&lt;li>COMPILER=hector - Cray compiler as used on hector and archer&lt;/li>
&lt;/ul>
&lt;p>As of version 4.11, it is now possible for the build system to
automatically detect the correct compiler to use. Typing
&lt;code>make COMPILER=auto&lt;/code> will cause the build system to guess which compiler
is in use. Note that this might not always work, so it is better to use
the correct value for &lt;code>COMPILER&lt;/code> if it is already known.&lt;/p>
&lt;p>You can also compile the code with debugging flags by adding
&amp;ldquo;&lt;code>MODE=debug&lt;/code>&amp;rdquo; and can compile using more than one processor by using
&amp;ldquo;&lt;code>-j&amp;lt;n&amp;gt;&lt;/code>&amp;rdquo;, where &amp;ldquo;&lt;code>&amp;lt;n&amp;gt;&lt;/code>&amp;rdquo; is the number of processors to use. Note that
this is just to speed up the compilation process; the resulting binary
can be run on any number of processors.&lt;/p></description></item><item><title>Compiler flags and preprocessor defines</title><link>/documentation/basic_usage/compiler_flags.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/compiler_flags.html</guid><description>&lt;p>As already stated, some features of the code are controlled by compiler
preprocessor directives. The flags for these preprocessor directives are
specified in &amp;ldquo;Makefile&amp;rdquo; and are placed on lines which look like the
following:&lt;/p>
&lt;pre>&lt;code>DEFINES += $(D)PER_SPECIES_WEIGHT
&lt;/code>&lt;/pre>
&lt;p>On most machines &lt;code>$(D)&lt;/code> just means &lt;code>-D&lt;/code> but the variable is required to
accommodate more exotic setups.&lt;/p>
&lt;p>Most of the flags provided in the &amp;ldquo;Makefile&amp;rdquo; are commented out by
prepending them with a &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; symbol (the &amp;ldquo;make&amp;rdquo; system&amp;rsquo;s comment
character). To turn on the effect controlled by a given preprocessor
directive, just uncomment the appropriate &amp;ldquo;DEFINES&amp;rdquo; line by deleting
this &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; symbol. The options currently controlled by the preprocessor
are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>PER_SPECIES_WEIGHT - By default, each pseudoparticle in the code
can represent a different number of real particles. Memory can be
saved by disabling this feature and have all of the pseudoparticles
in a species use the same particle weight. Many of the codes more
advanced features require per-particle weighting so it is enabled by
default. Use this flag to disable per- particle weighting if you
need to save on memory, but it this option is recommended only for
advanced users.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_TRACER_PARTICLES - This flag will disable the option to specify
one or more species as zero-current particles. Zero-current
particles move about as would a normal particle with the same charge
and mass, but they do not generate any current and are therefore
passive elements in the simulation. Zero-current particles should be
included in collisions to ensure they move identically to ordinary
particles. The implementation of zero-current particles requires an
additional &amp;ldquo;IF&amp;rdquo; clause in the particle push, so it has a slight
performance impact. If you do not require the feature then setting
this flag will give a slight performance improvement.
&lt;span style="color: red; font-weight: bold;">WARNING:&lt;/span> Since
the particles effectively have zero weight in terms of their
numerical heating properties, they do not always behave in the same
way that an ordinary particle with weight would behave and this can
sometimes lead to unexpected behaviour. If the purpose is merely to
track a subset of a particle species to use as output then a better
mechanism to use is &amp;ldquo;persistent subsets&amp;rdquo; (see
&lt;a href="/documentation/input_deck/input_deck_subset">here&lt;/a>). In version 5.0, this
flag will be and replaced with &amp;ldquo;ZERO_CURRENT_PARTICLES&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_PARTICLE_PROBES - For laser plasma interaction studies it can
sometimes be useful to be able to record information about particles
which cross a plane in the simulation. Since this requires the code
to check whether each particles has crossed the plane in the
particles pusher and also to store copies of particles until the
next output dump, it is a heavyweight diagnostic. If you don&amp;rsquo;t
require the diagnostic you can set this flag to disable it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PROBE_TIME - Paticle probes also output the time particles pass the probe.
Without this key, only the time of the SDF output dump will be available.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_SHAPE_TOPHAT - By default, the code uses a first order
b-spline (triangle) shape function to represent particles giving
third order particle weighting. Using this flag changes the particle
representation to that of a top-hat function (0th order b-spline
yielding a second order weighting).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_SHAPE_BSPLINE3 - This flag changes the particle
representation to that of a 3rd order b-spline shape function (5th
order weighting).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_ID - When this option is enabled, all particles are
assigned a unique identification number when writing particle data
to file. This number can then be used to track the progress of a
particle during the simulation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_ID4 - This does the same as the previous option except it
uses a 4-byte integer instead of an 8-byte one. Whilst this saves
storage space, care must be taken that the number does not overflow.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PHOTONS - This enables support for photon particle types in the
code. These are a pre-requisite for modelling synchrotron emission,
radiation reaction and pair production (see
&lt;a href="/documentation/input_deck/input_deck_qed">here&lt;/a>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TRIDENT_PHOTONS - This enables support for virtual photons which
are used by the Trident process for pair production.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BREMSSTRAHLUNG - Similar to photons, but for modelling bremsstrahlung
radiation instead of QED emission.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PREFETCH - This enables an Intel-specific code optimisation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARSER_DEBUG - The code outputs more detailed information whilst
parsing the input deck. This is a debug mode for code development.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_DEBUG - Each particle is additionally tagged with
information about which processor it is currently on, and which
processor it started on. This is a debug mode for code development.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MPI_DEBUG - This option installs an error handler for MPI calls
which should aid tracking down some MPI related errors.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SIMPLIFY_DEBUG - This option enables debugging code related to the
deck parser simplification routine.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_IO - This option disables all file I/O which can be useful when
doing benchmarking.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>COLLISIONS_TEST - This enables some routines for debugging the
collision routines. It completely alters the behaviour of the code.
This flag should never be enabled by the end user.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PER_PARTICLE_CHARGE_MASS - By default, the particle charge and
mass are specified on a per-species basis. With this flag enabled,
charge and mass become a per-particle property. This is a legacy
flag which will be removed soon.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARSER_CHECKING - Setting this flag adds code which checks for
valid values on evaluated deck expressions. This slows down the code
but may be required if floating point exceptions are enabled.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>WORK_DONE_INTEGRATED - This enables support for tracking the work
done on each particle by the electric field. Note that this
increases the size of each particle by 48 bytes. The information
gathered can be output to file using the &amp;ldquo;work_{x,y,z}&amp;rdquo; and
&amp;ldquo;work_{x,y,z}_total&amp;rdquo; dumpmasks. See
&lt;a href="/documentation/input_deck/input_deck_output_block#particle_variables">here&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DELTAF_METHOD - Compile the code to use the delta-f method to
represent particles rather than standard PIC. Note that this
completely changes the code behaviour and should not be enabled for
normal use. See
&lt;a href="/documentation/code_details/using_delta_f">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DELTAF_DEBUG - Add debug code for the delta-f method.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HC_PUSH - Use the push from
&lt;a href="https://doi.org/10.1063/1.4979989" target="_blank" rel="noopener">Higuera and
Cary&lt;/a> rather than the Boris push.
This is slightly slower than the Boris push but gives the correct
$\mathbf{E} \times \mathbf{B}$ velocity, improving performance for
highly relativistic simulations.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_USE_ISATTY - When printing the initial welcome message, EPOCH
makes use of the C-library&amp;rsquo;s isatty function. This requires
Fortran2003 features that might not be available on all platforms.
The flag allows this functionality to be disabled on platforms that
don&amp;rsquo;t support it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_MPI3 - This compiler flag allows the user to disable MPI-3
features such as the &amp;ldquo;MPI_TYPE_SIZE_X&amp;rdquo; routine. This allows the
code to be compiled against older versions of the MPI library. The
flag should only be enabled if the code fails to compile without it.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="changing-precompiler-directives">Changing precompiler directives&lt;/h1>
&lt;p>If a user has already compiled EPOCH, and would like to change the active
compiler flags, then the user may comment and uncomment different flags in the
Makefile (by adding or removing # at the start of the line), and recompiling the
code using the commands:&lt;/p>
&lt;pre>&lt;code class="language-perl">make clean
make COMPILER=gfortran -j4
&lt;/code>&lt;/pre>
&lt;p>Where in this example, the gfortran compiler has been chosen.&lt;/p>
&lt;h1 id="errors_for_unspecified_precompiler_directives">Errors for unspecified precompiler directives&lt;/h1>
&lt;p>If a user requests an option which the code has not been compiled to
support then the code will give an error or warning message as follows:&lt;/p>
&lt;pre>&lt;code> *** ERROR ***
Unable to set &amp;quot;use_qed=T&amp;quot; in the &amp;quot;qed&amp;quot; block.
Please recompile with the -DPHOTONS preprocessor flag.
&lt;/code>&lt;/pre>
&lt;h1 id="other_makefile_flags">Other Makefile flags&lt;/h1>
&lt;p>It is also possible to pass other flags to the compiler. In &amp;ldquo;Makefile&amp;rdquo;
there is a line which reads&lt;/p>
&lt;pre>&lt;code>FFLAGS = -O3 -fast
&lt;/code>&lt;/pre>
&lt;p>The two commands to the right are compiler flags and are passed
unaltered to the FORTRAN compiler. Change this line to add any
additional flags required by your compiler.&lt;/p>
&lt;p>By default, EPOCH will write a copy of the source code and input decks
into each restart dump. This can be very useful since a restart dump
contains an exact copy of the code which was used to generate it,
ensuring that you can always regenerate the data or continue running
from a restart. The output can be prevented by using &amp;ldquo;dump_source_code
= F&amp;rdquo; and &amp;ldquo;dump_input_deck = F&amp;rdquo; in the output block. However, the
functionality is difficult to build on some platforms so the Makefile
contains a line for bypassing this section of the build process. Just
below all the DEFINE flags there is the following line:&lt;/p>
&lt;pre>&lt;code>#ENCODED_SOURCE = epoch_source_info_dummy.o
&lt;/code>&lt;/pre>
&lt;p>Just uncomment this line and source code in restart dumps will be
permanently disabled.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Running EPOCH and basic control of EPOCH</title><link>/documentation/basic_usage/running.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/running.html</guid><description>&lt;p>When the code is run, the output is&lt;/p>
&lt;pre>&lt;code> d########P d########b .######b d####### d##P d##P
d########P d########### d########### .########## d##P d##P
---- ---- ---- ----- ---- ----- ---- -- P
d########P d####,,,####P ####. .#### d###P d############P
d########P d#########P #### .###P ####. d############P
d##P d##P #### d#### ####. d##P d##P
d########P d##P ###########P ##########P d##P d##P
d########P d##P d######P #######P d##P d##P
The code was compiled with no compile time options
Welcome to EPOCH2D version 4.12.0 (commit v4.12.0-0-gfd74a464-clean)
Code is running on 1 processing elements
Specify output directory
&lt;/code>&lt;/pre>
&lt;p>At which point the end user should simply type in the name of the
directory where the code output is to be placed. This directory must
also include the file which controls the code setup, specifies how to
set the initial conditions and controls the I/O. Writing an input deck
for EPOCH is fairly time consuming and so the code is supplied with some
example input decks which include all the necessary sections for the
code to run. Alternately, the code checks for the Data directory in a
file named &amp;ldquo;USE_DATA_DIRECTORY&amp;rdquo; before prompting at the command-line.
This allows the code to be run without waiting for input at the
command-line.&lt;/p></description></item><item><title>Acknowledging EPOCH</title><link>/documentation/basic_usage/acknowledging_epoch.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/acknowledging_epoch.html</guid><description>&lt;h2 id="how-do-i-acknowledge-use-of-the-code">How do I acknowledge use of the code?&lt;/h2>
&lt;p>There is a paper&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> which details many aspects of the &lt;strong>EPOCH&lt;/strong>
implementation and also includes useful information on current PIC
codes. This paper is OpenAccess so freely available to all. If using
EPOCH in your research output please use this as the reference for EPOCH
and ideally also acknowledge the UK grant which funded this work. The
BibTeX entry for this paper is as follows.&lt;/p>
&lt;pre>&lt;code class="language-bibtex">@article{Arber:2015hc,
author = {Arber, T D and Bennett, K and Brady, C S and Lawrence-Douglas,
A and Ramsay, M G and Sircombe, N J and Gillies, P and Evans,
R G and Schmitz, H and Bell, A R and Ridgers, C P},
title = {{Contemporary particle-in-cell approach to laser-plasma modelling}},
journal = {Plasma Physics and Controlled Fusion},
year = {2015},
volume = {57},
number = {11},
pages = {1--26},
month = nov
}
&lt;/code>&lt;/pre>
&lt;p>Acknowledgement: &amp;ldquo;This work was in part funded by the UK EPSRC grants
EP/G054950/1, EP/G056803/1, EP/G055165/1 and EP/ M022463/1.&amp;rdquo;&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>T D Arber, K Bennett, C S Brady, A Lawrence-Douglas, M G Ramsay, N
J Sircombe, P Gillies, R G Evans, H Schmitz, A R Bell,
&amp;ldquo;Contemporary particle-in-cell approach to laser-plasma
modelling,&amp;rdquo; Plasma Physics and Controlled Fusion, 2015.
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/57/11/113001/pdf" target="_blank" rel="noopener">link&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Library requirements for the EPOCH codes</title><link>/documentation/basic_usage/libraries.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/libraries.html</guid><description>&lt;p>The EPOCH codes are written using MPI for parallelism, but have no other
libraries or dependencies. Currently, the codes are written to only
require MPI1.2 compatible libraries, although this may change to require
full MPI2 compliance in the future. Current versions of both MPICH and
OpenMPI implement the MPI2 standard and are known to work with this
code. The SCALI MPI implementation is only compliant with the MPI1.2
specification and may loose support soon. There are no plans to write a
version of EPOCH which does not require the MPI libraries.&lt;/p>
&lt;p>The code is supplied with a standard GNU make Makefile, which is also
compatible with most other forms of the &lt;em>&lt;code>*make*&lt;/code>&lt;/em> utility.
In theory it is possible to compile the code without a
&lt;em>&lt;code>*make*&lt;/code>&lt;/em> utility, but it is much easier to compile the code
using the supplied makefile.&lt;/p></description></item></channel></rss>