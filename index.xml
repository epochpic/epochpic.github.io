<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>EPOCH</title><link>/</link><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><description>EPOCH</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate><image><url>/images/logo_hub4b4d6a0f57638acebb5550a80c8c030_9243_300x300_fit_lanczos_2.png</url><title>EPOCH</title><link>/</link></image><item><title>Lasers</title><link>/quickstart/basic_examples/laser.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/laser.html</guid><description>&lt;p>EPOCH can support laser sources on the boundaries, with a wide array of spatial
and temporal profiles. These examples provide basic input decks for simulating
lasers in vacuum. General documentation on the EPOCH laser block can be found
&lt;a href="/documentation/input_deck/input_deck_laser.html">here&lt;/a>.&lt;/p>
&lt;h2 id="simple-plane-wave">Simple plane wave&lt;/h2>
&lt;p>This input deck provides the most basic form of laser. We use uniform spatial
and temporal profiles, and inspect the Poynting flux in the simulation window.
As a typical rule of thumb, allow 20 cells per wavelength to get a good
resolution.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 200
ny = 400
t_end = 100e-15
x_min = 0
x_max = 10e-6
y_min = -10e-6
y_max = 10e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e18
lambda = 1.0e-6
end:laser
begin:output
dt_snapshot = 10 * femto
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="simple_laser.png" alt="Uniform laser">&lt;/p>
&lt;p>As we have specified a time-averaged intensity of $10^{18} \text{ Wcm}^{-2}$, we
expect the Poytning flux to range 0 to $2\times 10^{18} \text{ Wcm}^{-2}$, which
we can see here. Note that, because our laser profile reaches the $y_{min}$ and
$y_{max}$ boundaries, some noise has been introduced here. In practice, these
boundary effects are less of an issue, as simulations are expected to mainly
deal with laser pulses.&lt;/p>
&lt;h2 id="laser-pulse">Laser pulse&lt;/h2>
&lt;p>Using the maths parser, we can create a laser pulse which has a Gaussian profile
in time and space for the intensity distribution, $I$:&lt;/p>
&lt;p>$ I(y,t) \propto e^{-(y-y_0)^2/2\sigma_y^2} e^{-(t-t_0)^2/2\sigma_t^2}$&lt;/p>
&lt;p>where we consider a 2D simulation with an $x$ propagating laser.&lt;/p>
&lt;p>Let the full-width-at-half-maximum of the
spatial and temporal profiles be 5 $\mu m$ and 40 fs respectively for the
intensity $I$ distribution. The relationship between $\sigma$ and the $fwhm$
for a Gaussian distribution is:&lt;/p>
&lt;p>$\sigma = \frac{fwhm}{2\sqrt{2 \ln(2)}}$&lt;/p>
&lt;p>However, the profile
keys in the laser block describe modifications to the boundary electric fields,
$E$, and as $I \propto E^2$, the $E$ profile must satisfy&lt;/p>
&lt;p>$ E(y,t) \propto e^{-((y-y_0)/2\sigma_y)^2} e^{-((t-t_0)/2\sigma_t)^2}$&lt;/p>
&lt;p>The EPOCH
&lt;a href="/documentation/code_details/maths_parser.html">maths parser&lt;/a> provides
a special &lt;code>gauss(x,x_0,w)&lt;/code> command for use in the input.deck, which sets a
profile of the form:&lt;/p>
&lt;p>$e^{-(x-x_0)^2/w^2}$&lt;/p>
&lt;p>Hence, we may use this &lt;code>gauss&lt;/code> function to model the electric field profiles if
we set&lt;/p>
&lt;p>$w = \frac{fwhm}{\sqrt{2\ln(2)}}$&lt;/p>
&lt;p>where $fwhm$ refers to the &lt;em>intensity&lt;/em> distribution.&lt;/p>
&lt;p>We can let the spatial profile peak at $y=0$. We don&amp;rsquo;t want the laser to peak at
$t=0$, as this would ignore the rising intensity. Instead, let us start when the
laser pulse is 10% of its maximum value - the half-width-at-10%-maximum,
$hw0.1m$. For a Gaussian beam, this is:&lt;/p>
&lt;p>$hw0.1m = \frac{fwhm}{2} \sqrt{\frac{\ln(10)}{\ln(2)}}$&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 700
ny = 400
t_end = 100e-15
x_min = 0
x_max = 35e-6
y_min = -10e-6
y_max = 10e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:constant
t_fwhm = 40.0e-15
y_fwhm = 5.0e-6
w_t = t_fwhm / sqrt(2*loge(2))
w_y = y_fwhm / sqrt(2*loge(2))
t_hw01m = 0.5 * t_fwhm * sqrt(loge(10)/loge(2))
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e18
lambda = 1.0e-6
profile = gauss(y,0,w_y)
t_profile = gauss(time,t_hw01m,w_t)
end:laser
begin:output
dt_snapshot = 10 * femto
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="laser_pulse.png" alt="Gaussian pulse">&lt;/p>
&lt;p>Here we see that the laser $fwhm$ in $x$ and $y$ are 12 $\mu m$ and 5 $\mu m$
respectively, where the $x$ $fwhm$ corresponds to a temporal FWHM of 40 fs, as
expected. Also, because there is little contact between the pulse and the
boundaries, we do not have any numerical boundary disturbance.&lt;/p>
&lt;h2 id="angled_laser_pulse">Angled laser pulse&lt;/h2>
&lt;p>A Gaussian laser pulse like the one in the previous example may be injected at
an angle into an EPOCH simulation. This is achieved by defining the spatial and
temporal laser envelopes in a rotated co-ordinate system (temporal envelope is
equivalent to an envelope in the laser-propagation direction). In this example,
the parameters &lt;code>y_rot&lt;/code> and &lt;code>t_rot&lt;/code> will describe the transverse and longitudinal
co-ordinates in the rotated co-ordinate system. Transformations are required
for both the profile and the phase of the laser.&lt;/p>
&lt;p>EPOCH uses the provided intensity to set $B$ values parallel to the boundary -
on &lt;code>x_min&lt;/code>, this sets $B_y$ and $B_z$. EPOCH sets these fields assuming the
laser travels perpendicular to the boundary, but this will over-estimate the $B$
fields in our rotated co-ordinate system, as part of the magnetic field will
also oscillate in the boundary normal direction. To correct for this, an
additional &lt;code>cos(theta)&lt;/code> parameter is required for intensity in the &lt;code>laser&lt;/code>
block.&lt;/p>
&lt;p>Finally, we must also be careful about the time when the peak laser intensity
enters the simulation. In the previous example, we set this to the half-time at
10% maximum, such that the laser started at 10% of its maximum intensity and
then increased to full. In a rotated laser, the wave-front corresponding to
the peak intensity arrives earlier on one of the laser edges than the other. Let
us set the injection time such that this &amp;ldquo;early edge&amp;rdquo; starts at 1% of the
maximum intensity. We will define the $y$ position of this &amp;ldquo;early edge&amp;rdquo; to be
the half-width at 1% maximum for the spatial profile. This way, we will
sufficiently model the full envelope, regardless of the injection angle.&lt;/p>
&lt;p>Here we provide an input deck which specifies a point on the laser path, and an
injection angle. Two constant blocks are provided: the first is for users to
set laser parameters, and the second derives parameters in the rotated
co-ordinate system.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 500
ny = 500
t_end = 200e-15
x_min = 0
x_max = 25e-6
y_min = 0e-6
y_max = 25e-6
stdout_frequency = 50
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:constant
t_fwhm = 40.0e-15 # Temporal FWHM
y_fwhm = 5.0e-6 # Spatial FWHM
y_foc = 5.0e-6 # y co-ord on laser path
x_foc = 10.0e-6 # x co-ord on laser path
las_theta_deg = -45 # Laser angle to boundary normal
I_peak_Wcm2 = 1.0e19 # Peak cycle-averaged intensity
las_lambda = 1.0e-6 # Laser wavelength
end:constant
begin:constant
las_theta = las_theta_deg * pi / 180.
y0 = y_foc - (x_foc - x_min) * tan(las_theta)
y_rot = y*cos(las_theta)
y0_rot = y0*cos(las_theta)
w_y = y_fwhm / sqrt(2*loge(2))
y_hw001m = 0.5 * y_fwhm * sqrt(loge(100)/loge(2)) # Half-width 1% max
w_t = t_fwhm / sqrt(2*loge(2))
t_hw001m = 0.5 * t_fwhm * sqrt(loge(100)/loge(2)) # Half-width 1% max
t_rot = time - (y-y0)*sin(las_theta)/c
t_hw001m_rot = t_hw001m + abs(y_hw001m * sin(las_theta) / c)
I_peak_rot = I_peak_Wcm2 * cos(las_theta)
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = I_peak_rot
lambda = las_lambda
profile = gauss(y_rot, y0_rot, w_y) * gauss(t_rot, t_hw001m_rot, w_t)
phase = -2 * pi * (y-y0_rot) * sin(las_theta) / las_lambda
end:laser
begin:output
dt_snapshot = t_end / 10
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>Here, we see the Poynting flux corresponds to a rotated Gaussian pulse. The
expected laser trajectory is marked with a dashed line for comparison. We see
that the wavelength, along with the spatial and temporal FWHM are as expected.&lt;/p>
&lt;p>&lt;img src="angled_injection.png" alt="Rotated Gaussian pulse">&lt;/p>
&lt;h2 id="focussing_a_gaussian_beam">Focussing a Gaussian Beam&lt;/h2>
&lt;p>A laser can be driven on the boundary so that it focusses on a given
spot. Basic details of how to do this are
&lt;a href="https://en.wikipedia.org/wiki/Gaussian_beam" target="_blank" rel="noopener">here&lt;/a>. To summarise, using
the paraxial approximation, the electric fields for a $x$-propagating,
$y$-polarised Gaussian beam take the form:&lt;/p>
&lt;p>$\pmb{E}(r,x) = E_0 \frac{w_0}{w(x)} e^{-r^2/w(x)^2} e^{-i(kx + k\frac{r^2}{2R_c(x)}-\psi(x))} \hat{\pmb{y}}$&lt;/p>
&lt;p>where&lt;/p>
&lt;ul>
&lt;li>$r$ is the radial distance from the laser propagation axis&lt;/li>
&lt;li>$x$ is axial distance along the wave, with $x=0$ at the focus&lt;/li>
&lt;li>$E_0$ is the peak electric field amplitude at the focus&lt;/li>
&lt;li>$w(x)$ is the beam-waist at $x$ (radial distance where field strength drops by $e^{-1}$)&lt;/li>
&lt;li>$w_0$ is $w(x=0)$&lt;/li>
&lt;li>$k$ is the laser wave-vector&lt;/li>
&lt;li>$R_c(x)$ is the radius of curvature at $x$&lt;/li>
&lt;li>$\psi(x)$ is the Gouy phase correction&lt;/li>
&lt;/ul>
&lt;p>If the fields on the simulation boundary are of this form,
then the fields will propagate according to this equation, and
a focal spot will be formed. Note that this propagation is only expected
provided the paraxial approximation is satisfied. This implies that, for vacuum propagation, the laser
wavelength, $\lambda$ is much smaller than the beam-waist: $\lambda &amp;laquo; w_0$.&lt;/p>
&lt;p>The following deck
gives an example for a laser attached to x_min. Two constant blocks are provided:
the first gives the user control over the focused laser properties, and the
second derives variables to be used in the laser block. The user only needs to
touch the first, which sets the intensity full-width-at-half-maximum (related to
beam-waist), the peak, cycle-averaged intensity, the laser wave-length and the
distance from the $x_{min}$ boundary to the focal point.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 2400
ny = 1200
t_end = 100e-15
x_min = 0
x_max = 20e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:constant
I_fwhm = 2.0e-6 # FWHM of laser intensity
I_peak_Wcm2 = 1.0e15 # 0.5 * eps0 * c * E_peak^2
las_lambda = 1.0e-6 # Laser wavelength
foc_dist = 5.0e-6 # Boundary to focal point distance
end:constant
begin:constant
las_k = 2.0 * pi / las_lambda
w0 = I_fwhm / sqrt(2.0 * loge(2.0)) # Beam Waist
ray_rang = pi * w0^2 / las_lambda # Rayleigh range
w_boundary = w0 * sqrt(1.0 + (foc_dist/ray_rang)^2) # Waist on boundary
I_boundary = I_peak_Wcm2 * (w0 / w_boundary)^2 # Intens. on boundary
rad_curve = foc_dist * (1.0 + (ray_rang/foc_dist)^2) # Boundary curv. rad.
gouy = atan(-foc_dist/rad_curve) # Boundary Gouy shift
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = I_boundary
lambda = las_lambda
phase = las_k * y^2 / (2.0 * rad_curve) - gouy
profile = gauss(y, 0, w_boundary)
end:laser
begin:output
name = o1
dt_snapshot = 10 * femto
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="FocussedBeam.png" alt="The focussed beam">&lt;/p>
&lt;p>In this example, EPOCH correctly reproduces the focal point position,
laser wavelength, and radial FWHM at the focus - however, the peak
intensity is only $0.88\times 10^{15} \text{ Wcm}^{-2}$. This
intensity reduction from target is due to the tight focal spot,
with $w_0\approx 1.7$ μm being close to $\lambda = 1.0$ μm.&lt;/p>
&lt;p>The deck is based on the laser test deck supplied with EPOCH, with a
modified laser and longer runtime. Other classes of beam (Bessel etc)
can be created similarly.&lt;/p></description></item><item><title>Particle loading</title><link>/quickstart/basic_examples/particle_load.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/particle_load.html</guid><description>&lt;p>Particles in EPOCH belong to particle species which can be controlled by the
&lt;a href="/documentation/input_deck/input_deck_species.html">species block&lt;/a>. In these
examples, we show how to load macro-particles in various configurations.
These macro-particle objects
behave as single particles in the code, but represent many real particles
for the current solver. The examples on this page set up simulations in epoch2d,
but they may be modified for use in the 1d or 3d codes.&lt;/p>
&lt;h2 id="uniform-load">Uniform load&lt;/h2>
&lt;p>This basic input deck sets up a uniform density of electrons over the full
simulation window. We create 10 macro-particles per cell, for a density of
$10^{24}\text{ m}^{-3}$. The cell sizes are $dx = dy = 50\text{ nm}$ and
$dz = 1 \text{ m}$, since cell sizes in omitted dimensions default to 1 metre.
Hence, we expect $2.5\times 10^9$ real electrons per cell, so each
macro-electron should represent around $2.5\times 10^8$ real electrons.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 25e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
npart = 50 * nx * ny
density = 1.0e24
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="uniform_load.png" alt="Uniform density">&lt;/p>
&lt;h2 id="basic-target">Basic target&lt;/h2>
&lt;p>The shape of the target can be controlled by using
&lt;a href="/documentation/code_details/maths_parser.html">maths parser&lt;/a> expressions in the
density key. For example, a $5 \text{ }\mu\text{m}$ target slab can be defined
according to&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 25e-6
stdout_frequency = 100
npart = 50 * (5.0e-6/(x_max-x_min)) * nx * ny
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
frac = 0.8
density = if (x gt 15.0e-6, 1.0e24, 0)
density = if (x gt 20.0e-6, 0, density(Electron))
temp_ev = 1000
end:species
begin:species
name = Carbon
mass = 22033.0
charge = 6.0
frac = 0.2
density = density(Electron) / 6
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="basic_target.png" alt="Uniform density">&lt;/p>
&lt;p>This target contains both electrons, and fully ionised carbon ions. The number
of macro-particles loaded has been set to ensure there are 50 particles per
cell, accounting for the fact most cells are in vacuum. The &lt;code>if&lt;/code> command in
EPOCH uses an if-else format, such that the line:&lt;/p>
&lt;pre>&lt;code> density = if (x gt 20.0e-6, 0, density(Electron))
&lt;/code>&lt;/pre>
&lt;p>means that for cells with $x&amp;gt;20\text{ }\mu\text{m}$, set the density to 0, and
in all other cells, set the density to what it was already (no change).&lt;/p>
&lt;h2 id="rotated-target">Rotated target&lt;/h2>
&lt;p>Let us take the basic target, and rotate it about the point
$(15.0,12.5)\text{ }\mu\text{m}$. To do this, we can set new functions in a
&lt;a href="/documentation/input_deck/input_deck_constant.html">constant block&lt;/a> to help.&lt;/p>
&lt;p>We may use a rotation transformation&lt;/p>
&lt;p>$x' = x\cos(\theta) + y\sin(\theta)$&lt;/p>
&lt;p>$y' = -x\sin(\theta) + y\cos(\theta)$&lt;/p>
&lt;p>to obtain $x$ and $y$ co-ordinates in a rotated co-ordinate system, which makes
the writing of the input.deck more straightforward. An example input.deck is
provided:&lt;/p>
&lt;pre>&lt;code>begin:constant
x0 = 15.0e-6
y0 = 12.5e-6
theta = 30.0 / 180.0 * pi
x_rot = (x-x0)*cos(theta) + (y-y0)*sin(theta)
y_rot = -(x-x0)*sin(theta) + (y-y0)*cos(theta)
end:constant
begin:control
nx = 500
ny = 500
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 25e-6
stdout_frequency = 100
npart = 50 * (5.0e-6/(x_max-x_min)) * nx * ny / sin(theta)
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
frac = 0.8
density = if (x_rot gt 0.0, 1.0e24, 0)
density = if (x_rot gt 5.0e-6, 0, density(Electron))
temp_ev = 1000
end:species
begin:species
name = Carbon
mass = 22033.0
charge = 6.0
frac = 0.2
density = density(Electron) / 6
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="rotated_target.png" alt="Uniform density">&lt;/p>
&lt;p>By creating the &lt;code>x_rot&lt;/code>, &lt;code>y_rot&lt;/code> variables, we can define objects in a rotated
co-ordinate system. In this new system, the &lt;code>x0&lt;/code>, &lt;code>y0&lt;/code> point is the origin, and
&lt;code>theta&lt;/code> is the rotation amount in radians. The number of loaded macro-particles
has been increased by &lt;code>1 / sin(theta)&lt;/code> to account for the fact that more cells
contain particles than in the non-rotated case.&lt;/p>
&lt;h2 id="periodic-structure">Periodic structure&lt;/h2>
&lt;p>We may use a certain trick in the
&lt;a href="/documentation/code_details/maths_parser.html">maths parser&lt;/a> to generate
repeating structures. If we wished to add strucutre to the front surface of a
target, where the repeated unit had a size of $y_r$, then a variable &lt;code>y_f&lt;/code>&lt;/p>
&lt;pre>&lt;code>y_f = (y / y_r) - floor(y / y_r)
&lt;/code>&lt;/pre>
&lt;p>would continuously repeat from 0 to 1 in each periodic window. This can be used
to create a repeating strucutre.&lt;/p>
&lt;p>For example, if the user wished to add a stack of half-spheres to the front of
the target, they may use:&lt;/p>
&lt;pre>&lt;code>begin:constant
x_front = 15.0e-6
circle_radius = 2.0e-6
y_r = 2.0 * circle_radius
y_f = 2.0*((y / y_r) - floor(y / y_r))-1.0
end:constant
begin:control
nx = 500
ny = 500
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 25e-6
stdout_frequency = 100
npart = 50 * (5.0e-6/(x_max-x_min)) * nx * ny
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
frac = 0.8
density = if ((x-x_front)^2 + (y_f * circle_radius)^2 lt circle_radius^2,\
1.0e24, 0)
density = if (x gt x_front and x lt (x_front + 5.0e-6), \
1.0e24, density(Electron))
temp_ev = 1000
end:species
begin:species
name = Carbon
mass = 22033.0
charge = 6.0
frac = 0.2
density = density(Electron) / 6
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="structured_target.png" alt="Uniform density">&lt;/p>
&lt;p>Note: due to the target complexity, I have not tried to force 50 macro-particles
per cell in this simulation.&lt;/p>
&lt;h2 id="load-density-from-file">Load density from file&lt;/h2>
&lt;p>Sometimes a density distribution can be too complicated to set up using the
EPOCH maths parser. In this case, EPOCH can read a binary file where the
density in each cell is specified.&lt;/p>
&lt;p>Binary files can be written by many coding languages. In this example, I used
MATLAB to write a sinusoidal density profile to file, using the code provided
here. Note the order of numbers being written - we perform a full line of $x$
values first, before moving onto the second line at the next $y$.&lt;/p>
&lt;pre>&lt;code class="language-matlab">nx = 500;
ny = 100;
fileID = fopen('density.bin','w');
for iy = 1:ny
for ix = 1:nx
density = abs(sin(ix/20));
fwrite(fileID,density,'double');
end
end
fclose(fileID);
&lt;/code>&lt;/pre>
&lt;p>An input deck was created to read this binary, where I have specified the full
path to the binary file position&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 100
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
npart = 5 * nx * ny
density = '/home/examples/density.bin'
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>This yielded the desired output for the density profile&lt;/p>
&lt;p>&lt;img src="density_from_file.png" alt="Density loaded from binary file">&lt;/p>
&lt;h2 id="momentum-distributions">Momentum distributions&lt;/h2>
&lt;p>While the &lt;code>density&lt;/code> key in EPOCH can be used to set up macro-particle positions,
the &lt;code>temperature&lt;/code> and &lt;code>drift&lt;/code> keys provide momentum distributions. The
&lt;code>temperature&lt;/code> key samples a momentum from a relativistic Maxwell-Jüttner
distribution, and &lt;code>drift&lt;/code> applies a Lorentz boost to these momenta.&lt;/p>
&lt;p>The user may also specify their own momentum distribution, using &lt;code>dist_fn&lt;/code>.
A functional form for the momentum distribution can be written in the
input deck, and
EPOCH can sample momenta from this distribution. As an example, say we wanted a
linearly-increasing distribution for the momentum x-component, from $p_x=0$ to
$p_x = p_{max}$&lt;/p>
&lt;pre>&lt;code>dist_fn = px / p_max
&lt;/code>&lt;/pre>
&lt;p>where the maximum value of &lt;code>dist_fn&lt;/code> has been set to 1. When sampling, EPOCH
will generate $p_x$, $p_y$ and $p_z$ values within a user-chosen range, and
substitute these into the &lt;code>dist_fn&lt;/code> expression yielding a number between 0 and
1. This number corresponds to the probability of keeping the sampled momenta,
or choosing a new set, which is sampled using a uniformly-distributed random
number.&lt;/p>
&lt;p>As an example, the following input deck initialises 3 species. One using only
temperature, one with the same temperature and drift, and the last using
a user-defined function.&lt;/p>
&lt;p>&lt;img src="momentum.png" alt="Momentum distributions">&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = 0
y_max = 25e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron_temp
mass = 1.0
charge = -1.0
npart = 5 * nx * ny
density = 1.0e24
temp_ev = 1000
end:species
begin:species
name = Electron_temp_drift
mass = 1.0
charge = -1.0
npart = 5 * nx * ny
density = 1.0e24
temp_ev = 1000
drift_x = 1.0e-22
end:species
begin:species
name = Electron_user
mass = 1.0
charge = -1.0
npart = 5 * nx * ny
density = 1.0e24
dist_fn = px / 1.0e-22
dist_fn_px_range = (0, 1.0e-22)
end:species
begin:output
dt_snapshot = t_end
px = always
weight = always
end:output
&lt;/code>&lt;/pre>
&lt;h2 id="load-particles-from-file">Load particles from file&lt;/h2>
&lt;p>If the user requires spatial and momentum distributions too complicated for the
previous methods, then they may perform the ultimate brute-force technique.
Using the
&lt;a href="/documentation/input_deck/input_deck_particle_file.html">particles_from_file block&lt;/a>
the user is able to manually specify the position, momentum and weight of each
macro-particle at the start of the simulation.&lt;/p>
&lt;p>As an example, let us set up a simple simulation where particles
above $y=0$ have
momentum $p_x = 10^{-23}\text{ kgm/s}$, and where $p_x = -10^{-23}\text{ kgm/s}$
below $y=0$. We will also force a uniform density of macro-particles over the
simulation window, and assign each macro-particle a weight of 10. The particle
files to achieve this were written by the following MATLAB code&lt;/p>
&lt;pre>&lt;code class="language-MATLAB">% Simulation parameters
part_count = 1.0e5;
x_min = 0;
x_max = 25.0e-6;
y_min = -5.0e-6;
y_max = 5.0e-6;
px0 = 1.0e-23;
% Set particle properties
x_vals = (x_max - x_min) * rand(1,part_count) + x_min;
y_vals = (y_max - y_min) * rand(1,part_count) + y_min;
w_vals = 10 * ones(1,part_count);
px_vals = px0 * ones(1,part_count);
px_vals(y_vals&amp;lt;0) = -px0;
% Write files
x_file = fopen('x.bin','w');
y_file = fopen('y.bin','w');
w_file = fopen('w.bin','w');
px_file = fopen('px.bin','w');
for i = 1:part_count
fwrite(x_file,x_vals(i),'double');
fwrite(y_file,y_vals(i),'double');
fwrite(w_file,w_vals(i),'double');
fwrite(px_file,px_vals(i),'double');
end
fclose(x_file);
fclose(y_file);
fclose(w_file);
fclose(px_file);
&lt;/code>&lt;/pre>
&lt;p>To load these macro-particles into the simulation, the following input.deck was
used&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 200
t_end = 1.0e-15
x_min = 0
x_max = 25e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
end:species
begin:particles_from_file
species = Electron
x_data = &amp;quot;/home/examples/x.bin&amp;quot;
y_data = &amp;quot;/home/examples/y.bin&amp;quot;
w_data = &amp;quot;/home/examples/w.bin&amp;quot;
px_data = &amp;quot;/home/examples/px.bin&amp;quot;
end:particles_from_file
begin:output
dt_snapshot = t_end
distribution_functions = always
end:output
begin:dist_fn
name = y_px
ndims = 2
dumpmask = always
direction1 = dir_y
direction2 = dir_px
resolution2 = 100
range2 = (-2.0e-23, 2.0e-23)
include_species:Electron
end:dist_fn
&lt;/code>&lt;/pre>
&lt;p>Here, we have provided the full paths to the particle file locations.
To visualise the distribution of macro-particles in position and momentum
space, we output a distribution function to obtain the expected figure.&lt;/p>
&lt;p>&lt;img src="particles_from_file.png" alt="particles_from_file phase space">&lt;/p>
&lt;h2 id="self-heating">Self-heating&lt;/h2>
&lt;p>Low resolution PIC codes can result in self-heating, where macro-particles can
gain energy non-physically. To measure its effect, we can simulate a small
portion of the simulation and assign periodic boundary conditions. Self-heating
can be reduced by using:&lt;/p>
&lt;ul>
&lt;li>Smaller cell sizes&lt;/li>
&lt;li>More marcro-particles per cell&lt;/li>
&lt;li>Current smoothing (see
&lt;a href="/documentation/input_deck/input_deck_species.html">control block&lt;/a>)&lt;/li>
&lt;li>Higher order macro-particle shapes
(see
&lt;a href="/documentation/basic_usage/compiler_flags.html">pre-compiler flags&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>Let us construct a test example, where we wish to find simulation parameters to
prevent self-heating in a system with electron density $10^{28} \text{ m}^{-3}$
and temperature $1 \text{ keV}$. By omitting an ion species, EPOCH will assume the
presence of a neutralising immobile proton population, at the same density as
the initial electron population. An input deck has been provided for this test,
and we can repeat the test for different cell-sizes, particles per cell,
macro-particle shapes and current-smoothing status.&lt;/p>
&lt;pre>&lt;code>begin:constant
cell_size = 50.0e-9
parts_per_cell = 10
end:constant
begin:control
nx = 10
ny = 10
t_end = 300.0e-15
x_min = 0
x_max = nx * cell_size
y_min = 0
y_max = ny * cell_size
stdout_frequency = 100
smooth_currents = T
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
npart = parts_per_cell * nx * ny
density = 1.0e28
temp_ev = 1000
end:species
begin:output
dt_snapshot = t_end/20
temperature = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="self_heat.png" alt="Uniform density">&lt;/p>
&lt;p>As there is no source of energy in this simulation, any temperature increase
must be non-physical. Here we see that as cell-size decreases, or particles per
cell increases, the self-heating is reduced. Switching on current smoothing, or
switching to a higher order macro-particle shape (B-spline) also reduces
self-heating. All these features come at a cost of a greater runtime, so it is
up to the user to decide how much self-heating mitigation is required.&lt;/p></description></item><item><title>Injectors</title><link>/quickstart/basic_examples/injectors.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/injectors.html</guid><description>&lt;p>It is possible to add macro-particles to the simulation window after the initial
macro-particle load using the
&lt;a href="/documentation/input_deck/input_deck_injector.html">injector block&lt;/a>.
This can be done to simulate a particle
beam passing through a boundary, or to replace macro-particles on the boundary
of a flowing plasma volume. EPOCH provides support for two styles of injectors,
one which is specified by plasma properties, and the other which reads particles
from files.&lt;/p>
&lt;h2 id="basic-plasma-injector">Basic plasma injector&lt;/h2>
&lt;p>To demonstrate the basic injector syntax, we have created a simple example. Here
we inject macro-electrons through the &lt;code>x_min&lt;/code> boundary, such that all electrons
have the same momentum, and the macro-particle weights are chosen to ensure the
injected density is $10^{10} \text{ m}^{-3}$. No macro-particles are initially
loaded into the simulation window.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 200
t_end = 20.0e-15
x_min = 0
x_max = 25e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
end:species
begin:injector
boundary = x_min
species = Electron
number_density = 1.0e10
drift_x = 1.0e-20
npart_per_cell = 10
end:injector
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="basic_injector.png" alt="Basic injector">&lt;/p>
&lt;p>This figure shows macro-particles have been injected through the &lt;code>x_min&lt;/code>
boundary,
with weights set to match the desired density.&lt;/p>
&lt;h2 id="flowing-plasma-injector">Flowing plasma injector&lt;/h2>
&lt;p>If we set up a problem where a flowing plasma fills the simulation window, then
the plasma will start to flow through a boundary after the initial load. As
this happens, macro-particles will exit the simulation on one side, leaving a
vacuum on the other side. If we added an injector to the vacuum side, then we
can introduce a source of new macro-particles to replace the lost
macro-particles. To do this, we can set the temperature and number density of
the injector to match that of the initial plasma.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 200
t_end = 20.0e-15
x_min = 0
x_max = 25e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
npart = nx * ny * 10
drift_x = 1.0e-20
temp_ev = 1.0e3
number_density = 1.0e10
end:species
begin:injector
boundary = x_min
species = Electron
number_density = 1.0e10
drift_x = 1.0e-20
temp_ev = 1.0e3
npart_per_cell = 10
end:injector
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="flowing_plasma.png" alt="Flowing plasma number density">&lt;/p>
&lt;p>Here we see that the plasma density is still uniform, even though the plasma
is drifting towards &lt;code>x_max&lt;/code>. Particles above $6\text{ }\mu\text{m}$ were loaded
at the start of the simulation, and those below have been replaced with
injectors. No sign of discontinuity on the injector/initial macro-particle
boundary is present.&lt;/p>
&lt;h2 id="particle-bunch-injection">Particle bunch injection&lt;/h2>
&lt;p>The profile of the injector can be modified to introduce spatial and temporal
variation, which would be useful for describing injected particle bunches.
We can set a Gaussian profile using the &lt;code>gauss(x,x0,w)&lt;/code> function in the
&lt;a href="/documentation/code_details/maths_parser.html">maths parser&lt;/a>, which represents&lt;/p>
&lt;p>$e^{-(x-x_0)^2/w^2}$&lt;/p>
&lt;p>In this formula, $w$ is related to the Gaussian full-width-at-half-maximum
according to&lt;/p>
&lt;p>$w = \frac{fwhm}{2\sqrt{\ln 2}}$&lt;/p>
&lt;p>For the temporal profile, let us simulate the full-width-at-10%-maximum. This
means the peak should arrive in the simulation at the half-width-at-10%-maximum
time, given by&lt;/p>
&lt;p>$hw0.1m = \frac{fwhm}{2} \sqrt{\frac{\ln(10)}{\ln(2)}}$&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 200
t_end = 20.0e-15
x_min = 0
x_max = 25e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
end:species
begin:constant
x_fwhm = 1.0e-6
y_fwhm = 1.0e-6
t_fwhm = x_fwhm / c
w_t = t_fwhm / (2.0 * sqrt(loge(2)))
w_y = y_fwhm / (2.0 * sqrt(loge(2)))
t_hw01m = 0.5 * t_fwhm * sqrt(loge(10) / loge(2))
end:constant
begin:injector
boundary = x_min
species = Electron
number_density = 1.0e10 * gauss(y,0,w_y) * gauss(time,t_hw01m,w_t)
number_density_min = 1.0e9
t_start = 0
t_end = 2.0 * t_hw01m
drift_x = 1.0e-20
temp_ev = 1.0e3
npart_per_cell = 10
end:injector
begin:output
dt_snapshot = t_end
number_density = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="bunch_injector.png" alt="Injected bunch">&lt;/p>
&lt;p>The injected pulse is seen to have the desired properties. Note that we have
introduced a threshold density for macro-particle injection with&lt;/p>
&lt;pre>&lt;code>number_density_min = 1.0e9
&lt;/code>&lt;/pre>
&lt;p>This line ensures that profiled densities below this value will not load
macro-particles into the simulation. This prevents the code from loading too
many low-weight macro-particles which would slow down the code.&lt;/p>
&lt;h2 id="file-injectors">File injectors&lt;/h2>
&lt;p>If the in-built density, temperature and drift do not provide the desired
injection behaviour, or if you&amp;rsquo;re trying to inject specific particles from a
different simulation, then you may find file-injectors useful. Here the user
can specify the injection time, position and momentum of each injected
macro-particle from file. Unlike other file-packages in EPOCH, the
file-injectors read from simple text files.&lt;/p>
&lt;p>For this simple example, let us inject a macro-electron of weight 10 into a
2D simulation window each femtosecond. The momenta of these macro-particles will
be set such that they are highly relativistic, with a speed close to $c$. To
check if they have been injected correctly, let us insert a particle probe
one micron from the injection boundary. Let us also use the &lt;code>-DPROBE_TIME&lt;/code>
compiler flag to see the exact time macro-particles pass the probe. See the
section on
&lt;a href="/documentation/basic_usage/compiler_flags.html">compiler flags&lt;/a>
for help with switching on the probe-time capability.&lt;/p>
&lt;p>We need to use separate files for each macro-particle variable, and particles
must be listed in chronological order of injection. For this demonstration, the
files contain:&lt;/p>
&lt;p>inject_t.txt&lt;/p>
&lt;pre>&lt;code>1.0e-15
2.0e-15
3.0e-15
4.0e-15
5.0e-15
6.0e-15
7.0e-15
8.0e-15
9.0e-15
10.0e-15
&lt;/code>&lt;/pre>
&lt;p>inject_w.txt&lt;/p>
&lt;pre>&lt;code>10
10
10
10
10
10
10
10
10
10
&lt;/code>&lt;/pre>
&lt;p>inject_y.txt&lt;/p>
&lt;pre>&lt;code>0
0
0
0
0
0
0
0
0
0
&lt;/code>&lt;/pre>
&lt;p>inject_px.txt&lt;/p>
&lt;pre>&lt;code>1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
1.0e-20
&lt;/code>&lt;/pre>
&lt;p>and the input.deck reads:&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 200
t_end = 20.0e-15
x_min = 0
x_max = 25e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = open
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:species
name = Electron
mass = 1.0
charge = -1.0
end:species
begin:injector
boundary = x_min
species = Electron
inject_from_file = T
y_data = &amp;quot;inject_y.txt&amp;quot;
px_data = &amp;quot;inject_px.txt&amp;quot;
w_data = &amp;quot;inject_w.txt&amp;quot;
t_data = &amp;quot;inject_t.txt&amp;quot;
end:injector
begin:output
dt_snapshot = t_end
particle_probes = always
end:output
begin:probe
name = Electron_probe
point = (1.0e-6, 0.0)
normal = (1.0, 0.0)
ek_min = 0.0
ek_max = -1.0
include_species:Electron
dumpmask = always
end:probe
&lt;/code>&lt;/pre>
&lt;p>For injector files, the code will look in the same directory as the input.deck
file. The full path is not required like in other file-reading blocks. If we
open &lt;code>0001.sdf&lt;/code> (possibly using the GetDataSDF.m function in
&lt;code>epoch/SDF/Matlab&lt;/code>), we see the times each macro-particle passes the probe. We
can label each macro-particle by its line in the injector files, and we can
obtain a probe-time vs file-line plot&lt;/p>
&lt;p>&lt;img src="file_injector.png" alt="File injector times">&lt;/p>
&lt;p>Due to the position of the probe, and the speed of the macro-particles, we
expect these probe times to be 3.337 fs after the particle injection time. This
matches the behaviour seen in the probe data, which shows that the file
injectors are working as intended.&lt;/p></description></item><item><title>Ionisation</title><link>/quickstart/basic_examples/ionisation.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/ionisation.html</guid><description>&lt;p>Particles within an EPOCH simulation have the option to be ionised through
either field ionisation, or electron-impact collisional ionisation. The keys
required to set up ionisation are found in multiple blocks, and a summary may be
found in the
&lt;a href="/documentation/input_deck/input_deck_species.html">species block&lt;/a>
documentation. This page provides simple demos for the ionisation packages.&lt;/p>
&lt;p>In general, the user defines an initial ion species, and the code automatically
generates species for the ionised states. During ionisation, a bound electron is
released from an ion, and added to an electron species as a macro-particle.&lt;/p>
&lt;h2 id="field-ionisation">Field ionisation&lt;/h2>
&lt;p>In field ionisation, ions are created in the presence of strong laser fields. In
this 1D input deck, a laser moves from the &lt;code>x_min&lt;/code> boundary towards a block of
neutral carbon. EPOCH can identify the ion species as neutral carbon, as the
&lt;code>charge&lt;/code> and &lt;code>atomic_no&lt;/code> have been specified in the
&lt;a href="/documentation/input_deck/input_deck_species.html">species block&lt;/a>.&lt;/p>
&lt;p>The species
block also tells EPOCH that the &lt;code>Carbon&lt;/code> species can be ionised since the
&lt;code>ionise = T&lt;/code> line is provided. The number of possible ionisation states has been
manually cut-off at 3 by the &lt;code>ionise_limit&lt;/code> key. When an ionisation occurs, a
new macro-electron is generated and assigned to a species which will be
automatically generated, as specified by &lt;code>unique_electron_species = T&lt;/code>.&lt;/p>
&lt;p>Once the ionisation keys in the species block have been activated, we need to
tell EPOCH what kind of ionisation should occur. Here, we switch on the field
ionisation process using the
&lt;a href="/documentation/input_deck/input_deck_control.html">control block&lt;/a> key
&lt;code>field_ionisation&lt;/code>.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 128
npart = 20 * nx
t_end = 42.4e-15
x_min = 0
x_max = 4.0e-6
field_ionisation = T
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
end:boundaries
begin:laser
boundary = x_min
intensity = 3.0e15 * 1.0e4
lambda = 800.0e-9
t_profile = 1
t_end = 10.7e-15
end:laser
begin:species
name = Carbon
charge = 0
atomic_no = 6
mass = 1836.2 * 16.0
frac = 1
rho = if ((x lt 3.30e-6) and (x gt 3.05e-6), 1.74e24, 0)
ionise = T
ionise_limit = 3
unique_electron_species = T
end:species
begin:output
dt_snapshot = t_end/100
number_density = always + species
end:output
&lt;/code>&lt;/pre>
&lt;p>Once the &lt;code>input.deck&lt;/code> directory has been selected, &lt;code>EPOCH&lt;/code> prints:&lt;/p>
&lt;pre>&lt;code> Name of species 1 is Carbon
Name of species 2 is Carbon1
Name of species 3 is electron_from_Carbon
Name of species 4 is Carbon2
Name of species 5 is electron_from_Carbon1
Name of species 6 is Carbon3
Name of species 7 is electron_from_Carbon2
Initial conditions complete and valid.
Redistributing. Balance: 0.254, after: 0.507 (pre-load balance)
Attempting to load particles
Loaded 2560 particles of species &amp;quot;Carbon&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Here we see that although only one species is present in the &lt;code>input.deck&lt;/code>, EPOCH
has generated species for Carbon with charge-states 1-3. If we had not included
&lt;code>ionise_limit&lt;/code>, we would have generated species up to fully ionised Carbon.
Also, by setting &lt;code>unique_electron_species = T&lt;/code>, the code has generated species
for electrons released by specific ions during ionisation. We also see no
macro-particles have been initially loaded into these automatically generated
species, as only Carbon has a specified density in the &lt;code>input.deck&lt;/code>.&lt;/p>
&lt;p>Once the simulation is complete, we can plot the number densities of each
species at different times. As can be seen below, the system originally starts
with only neutral carbon present, but ends with carbon ions of charge-state 2
and 3 after illumination by the laser.&lt;/p>
&lt;p>&lt;img src="field_ionise_space.png" alt="Spatial distribution of charge populations">&lt;/p>
&lt;p>We can also plot the fraction of carbon ions in each charge-state as a function
of time:&lt;/p>
&lt;p>&lt;img src="field_ionise_rate.png" alt="Charge populations over time for field ionisation">&lt;/p>
&lt;h2 id="collisional-ionisation">Collisional ionisation&lt;/h2>
&lt;p>In collisional ionisation, ions undergo ionisation through collisions with
electrons. In this simulation, the domain is filled with an equal number of electrons and
neutral carbon atoms, and collisional ionisation between the two species
generates carbon ions and ejected electrons.&lt;/p>
&lt;p>As in the field ionisation example, the &lt;code>Carbon&lt;/code> species uses
&lt;code>ionise = T&lt;/code> to identify the species as one which can ionise. Without
&lt;code>ionise_limit&lt;/code>, we allow ionisation up to fully-ionised carbon. In this example,
we create an empty electron species &lt;code>Ejected_electron&lt;/code>, which will be used to
store macro-electrons which are ejected from ions during ionisation.&lt;/p>
&lt;p>As collisional ionisation refers to ionisation when electrons hit ions, the code
needs to know which species are electron species. For the &lt;code>Electron_beam&lt;/code>
species, the line &lt;code>identify:electron&lt;/code> tells EPOCH the species can trigger
collisional ionisation. Also, EPOCH knows &lt;code>Ejected_elctron&lt;/code> is an electron
species, because it is identified as a species to populate with electrons
ejected in the ionisation process from carbon ions.&lt;/p>
&lt;p>Collisional ionisation is switched on using the &lt;code>collisional_ionisation=T&lt;/code> line
in the
&lt;a href="/documentation/input_deck/input_deck_collisions.html">collisions block&lt;/a>.
Note that this does not switch on Coulomb scatter collisions between species, as
this is a separate process from collisional ionisation.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 128
npart = 200 * nx
t_end = 300.0e-15
x_min = 0
x_max = 4.0e-6
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
end:boundaries
begin:collisions
collisional_ionisation = T
end:collisions
begin:species
name = Electron_beam
frac = 0.5
rho = 2.0e24
temp_ev = 80
identify:electron
end:species
begin:species
name = Carbon
charge = 0
atomic_no = 6
mass = 1836.2 * 16.0
frac = 0.5
rho = 2.0e24
ionise = T
electron_species = Ejected_electron
end:species
begin:species
name = Ejected_electron
frac = 0
charge = -1
mass = 1
end:species
begin:output
dt_snapshot = t_end/100
number_density = always + species
end:output
&lt;/code>&lt;/pre>
&lt;p>When we run this simulation, EPOCH prints the lines:&lt;/p>
&lt;pre>&lt;code> Name of species 1 is Electron_beam
Name of species 2 is Carbon
Name of species 3 is Ejected_electron
Name of species 4 is Carbon1
Name of species 5 is Carbon2
Name of species 6 is Carbon3
Name of species 7 is Carbon4
Name of species 8 is Carbon5
Name of species 9 is Carbon6
&lt;/code>&lt;/pre>
&lt;p>where the ionisation species Carbon1-Carbon6 have been automatically generated.
Initially these ionised carbon particle species contain no macro-particles.&lt;/p>
&lt;p>This simulation generates some Carbon1 ions and a small number of Carbon2. The
collisional ionisation cross section is too low here to ionise to the higher
charge states. A plot of the population fraction over time is given here:&lt;/p>
&lt;p>&lt;img src="coll_ionise_rate.png" alt="Charge populations over time for collisional ionisation">&lt;/p></description></item><item><title>Antenna block</title><link>/documentation/input_deck/input_deck_antenna.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_antenna.html</guid><description>&lt;p>Antennae allow you to specify currents in the simulation domain that are
added to the self consistent currents from the core solver. You can
either specify the currents entirely manually or you can specify a
frequency and a profile for each current component. You can have as many
antennae as you want by specifying multiple antenna blocks.&lt;/p>
&lt;h1 id="example_deck">Example Deck&lt;/h1>
&lt;pre>&lt;code class="language-perl">begin:antenna
jx = if (r_xy lt micron, 1.0e-5, 0.0)
jy = if (r_xy lt micron, 1.0e-5, 0.0)
jz = if (r_xy lt micron, 1.0e-5, 0.0)
ranges = ((-micron, micron), (-micron, micron))
omega = 1.0e15
start_time = start
stop_time = end
end:antenna
&lt;/code>&lt;/pre>
&lt;h1 id="keys">Keys&lt;/h1>
&lt;ul>
&lt;li>&lt;code>jx&lt;/code> - Profile for current in x direction. If you do not specify the
omega key then you should include any time dependence manually. If
the omega key is specified any time variation in jx will be
multiplicatively combined with the sinusoidal variation from omega.
Can be time and space varying.&lt;/li>
&lt;li>&lt;code>jy&lt;/code> - Profile for current in y direction. If you do not specify the
omega key then you should include any time dependence manually. If
the omega key is specified any time variation in jy will be
multiplicatively combined with the sinusoidal variation from omega.
Can be time and space varying.&lt;/li>
&lt;li>&lt;code>jz&lt;/code> - Profile for current in z direction. If you do not specify the
omega key then you should include any time dependence manually. If
the omega key is specified any time variation in jz will be
multiplicatively combined with the sinusoidal variation from omega.
Can be time and space varying.&lt;/li>
&lt;li>&lt;code>ranges&lt;/code> - Array of (min,max) pairs for each dimension of your
simulation (1 pair for EPOCH1d, 2 pairs for EPOCH2D and 3 pairs for
EPOCH3D) showing the domain over which the antenna should operate.
Describes the region of space over which the current from the
antenna should be applied. The fields generated by that current will
propagate everywhere in the simulation domain. If ranges is not
present then the antenna will be applied to the whole domain.
Performance of the antenna block will be highest if you set the
smallest range possible.&lt;/li>
&lt;li>&lt;code>omega&lt;/code> - Optional frequency for the antenna. If this key is set then
the current will vary sinusoidally with the specified frequency.
This is faster to run than specifying a sinusoidal profile in the
jx, jy or jz keys but performs the same (for a frequency that
doesn&amp;rsquo;t change in time, see Time variability section). Can be time
varying, but not space varying&lt;/li>
&lt;li>&lt;code>start_time&lt;/code> - Time after which to start applying the antenna
currents. Can be &amp;ldquo;start&amp;rdquo; to apply from the start of the
simulation. If key is not present antenna runs from the start of the
simulation.&lt;/li>
&lt;li>&lt;code>stop_time&lt;/code> - Time after which to cease applying the antenna
currents. Can be &amp;ldquo;end&amp;rdquo; to apply until the end of the simulation.
If key is not present antenna runs until the end of the simulation.&lt;/li>
&lt;/ul>
&lt;h1 id="time_variability">Time variability&lt;/h1>
&lt;p>When you specify time variation for the jx, jy or jz keys this specifies
the &lt;strong>instantaneous&lt;/strong> current to be applied at each moment in time.&lt;/p>
&lt;p>When you specify time variation in the omega key this specifies the
frequency at this time, but this is applied to the phase state of the
antenna as an integral. So the sinusoid that is applied to the current
is $\sin\Bigl(\int_0^t\omega(t')dt'\Bigr)$. For constant $\omega$ this
reduces to $\sin(\omega t)$. This gives the correct behaviour for
chirped antennae&lt;/p>
&lt;h1 id="example_deck_1">Example deck&lt;/h1>
&lt;p>An example deck for this block can be found in
example_decks/antenna.deck. The deck should take 5-20 seconds to run.&lt;/p></description></item><item><title>FAQs</title><link>/documentation/basic_usage/faq.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/faq.html</guid><description>&lt;h2 id="is-this-manual-up-to-date">Is this manual up to date?&lt;/h2>
&lt;p>Whenever a new milestone version of &lt;strong>EPOCH&lt;/strong> is finalised, the version
number is changed and this manual is updated accordingly. The version
number of the manual should match the first two digits for that of the
&lt;strong>EPOCH&lt;/strong> source code. This version number is printed to screen when you
run the code. The line looks something like the following:&lt;/p>
&lt;pre>&lt;code> Welcome to EPOCH2D version 4.16.0 (commit v4.16.0-0-g69eb0fa6-clean)
&lt;/code>&lt;/pre>
&lt;p>Here, only the number &amp;ldquo;4.16&amp;rdquo; is important.&lt;/p>
&lt;p>Since version 3.1 of the manual, new additions and changes are mentioned
in the appendix.&lt;/p>
&lt;h2 id="what-is-epoch">What is &lt;strong>EPOCH&lt;/strong>?&lt;/h2>
&lt;p>&lt;strong>EPOCH&lt;/strong> is a plasma physics simulation code which uses the Particle in
Cell (PIC) method. In this method, collections of physical particles are
represented using a smaller number of pseudoparticles, and the fields
generated by the motion of these pseudoparticles are calculated using a
finite difference time domain technique on an underlying grid of fixed
spatial resolution. The forces on the pseudoparticles due to the
calculated fields are then used to update the pseudoparticle velocities,
and these velocities are then used to update the pseudoparticle
positions. This leads to a scheme which can reproduce the full range of
classical micro-scale behaviour of a collection of charged particles.&lt;/p>
&lt;h3 id="features-of-epoch">Features of &lt;strong>EPOCH&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>MPI parallelised, explicit, second-order, relativistic PIC code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dynamic load balancing option for making optimal use of all
processors when run in parallel.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MPI-IO based output, allowing restart on an arbitrary number of
processors.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Data analysis and visualisation options include ITT IDL, LLNL VisIt,
Mathworks MatLab and matplotlib in Python.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Control of setup and runs of &lt;strong>EPOCH&lt;/strong> through a customisable input
deck.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="the-origins-of-the-code">The origins of the code&lt;/h2>
&lt;p>The &lt;strong>EPOCH&lt;/strong> family of PIC codes is based on the older PSC code written
by Hartmut Ruhl and retains almost the same core algorithm for the field
updates and particle push routines. &lt;strong>EPOCH&lt;/strong> was written to add more
modern features and to structure the code in such a way that future
expansion of the code is made as easy as possible.&lt;/p>
&lt;h2 id="how_do_i_obtain_the_code">How do I obtain the code?&lt;/h2>
&lt;p>The latest version of &lt;strong>EPOCH&lt;/strong> can be found on GitHub at
&lt;a href="https://github.com/Warwick-Plasma/epoch">https://github.com/Warwick-Plasma/epoch&lt;/a>&lt;/p>
&lt;p>A tarred and gzipped archive (commonly referred to as a tarball) of the latest
release is always made available in the
&lt;a href="https://github.com/Warwick-Plasma/epoch/releases" target="_blank" rel="noopener">Releases&lt;/a> section&lt;/p>
&lt;p>Alternately, using git the code can be cloned using the following command.
Note that it is important to include the &amp;lsquo;&amp;lsquo;recursive&amp;rsquo;&amp;rsquo; flag in order to
download the SDF submodules..&lt;/p>
&lt;p>&lt;code>git clone &amp;ndash;recursive &lt;a href="https://github.com/Warwick-Plasma/epoch.git">https://github.com/Warwick-Plasma/epoch.git&lt;/a>&lt;/code>&lt;/p>
&lt;h2 id="what-normalisations-are-used-in-epoch">What normalisations are used in &lt;strong>EPOCH&lt;/strong>?&lt;/h2>
&lt;p>Since the idea from the start was that &lt;strong>EPOCH&lt;/strong> would be used by a
large number of different users and that it should be as easy as
possible to &amp;ldquo;plug in&amp;rdquo; different modules from different people into a
given copy of the code, it was decided to write &lt;strong>EPOCH&lt;/strong> in SI units.
There are a few places in the code where some quantities are given in
other units for convenience (for example charges are specified in
multiples of the electron charge), but the entire core of the code is
written in SI units.&lt;/p>
&lt;h2 id="what-are-those-_num-things-doing-everywhere">What are those &lt;code>_num&lt;/code> things doing everywhere?&lt;/h2>
&lt;p>Historically using the compiler auto-promotion of &lt;code>REAL&lt;/code> to
&lt;code>DOUBLE PRECISION&lt;/code> was unreliable, so &lt;strong>EPOCH&lt;/strong> uses &amp;ldquo;kind&amp;rdquo; tags to
specify the precision of the code. The &lt;code>_num&lt;/code> suffixes and the
associated definition of &lt;code>REAL&lt;/code>s as &lt;code>REAL(num)&lt;/code> are these &amp;ldquo;kind&amp;rdquo; tags in
operation. The &lt;code>_num&lt;/code> tags force numerical constants to match the
precision of the code, preventing errors due to precision conversion.
The important thing is that all numerical constants should be tagged
with an &lt;code>_num&lt;/code> tag and all &lt;code>REAL&lt;/code>s should be defined as &lt;code>REAL(num)&lt;/code>.&lt;/p>
&lt;h2 id="what-is-an-input-deck">What is an input deck?&lt;/h2>
&lt;p>An input deck is text file which can be used to set simulation
parameters for &lt;strong>EPOCH&lt;/strong> without needing to edit or recompile the source
code. It consists of a list of blocks which start as &lt;strong>begin:blockname&lt;/strong>
and end with &lt;strong>end:blockname&lt;/strong>. Within the body of each block is a list
of key/value pairs, one per line, with key and value separated by an
equals sign. Most aspects of a simulation can be controlled using an
input deck, such as the number of grid points in the simulation domain,
the initial distribution of particles and initial electromagnetic field
configuration. It is designed to be relatively easy to read and edit.
For most projects it should be possible to set up a simulation without
editing the source code at all. For more details, read the section
titled
&lt;a href="/documentation/input_deck/input_deck">&amp;ldquo;The EPOCH input deck&amp;rdquo;&lt;/a>&lt;/p>
&lt;h2 id="i-just-want-to-use-the-code-as-a-black-box-or-im-just-starting" class="-how-do-i-do-that">I just want to use the code as a black box, or I&amp;rsquo;m just starting. How do I do that?&lt;/h2>
&lt;p>Begin by reading
&lt;a href="/documentation/examples/basic_examples">the basic examples&lt;/a>.
There&amp;rsquo;s quite a lot to learn in order to get
started, so you should plan to read through all of this section. You
will also need to refer to
&lt;a href="/documentation/input_deck/input_deck">the input deck pages&lt;/a>.
Next, look at the code and have a play with some test problems. After
that re-read this section. This should be enough for testing simple
problems.&lt;/p>
&lt;h2 id="what-is-the-auto-loader">What is the auto-loader?&lt;/h2>
&lt;p>Throughout this document we will often refer to the &amp;ldquo;auto-loader&amp;rdquo; when
setting up the initial particle distribution. In the input deck it is
possible to specify a functional form for the density and temperature of
a particle species. &lt;strong>EPOCH&lt;/strong> will then place the particles to match the
density function and set the velocities of the particles so that they
match the Maxwellian thermal distribution for the temperature. The code
which performs this particle set up is called the &amp;ldquo;auto-loader&amp;rdquo;.&lt;/p>
&lt;p>At present, there is no way to specify a non-Maxwellian particle
distribution from within the input deck. In such cases, it is necessary
to edit and recompile the &lt;strong>EPOCH&lt;/strong> source code. The recommended method
for setting the initial particle properties is to use the
&amp;ldquo;&lt;code>manual_load&lt;/code>&amp;rdquo; function as described
&lt;a href="/documentation/code_details/using_epoch_in_practice#manually_overriding_particle_parameters_set_by_the_autoloader">here&lt;/a>.&lt;/p>
&lt;h2 id="what-is-a-maths-parser">What is a maths parser?&lt;/h2>
&lt;p>As previously mentioned, the behaviour of &lt;strong>EPOCH&lt;/strong> is controlled using
an input deck which contains a list of key/value pairs. The value part
of the pair is not restricted to simple constants but can be a complex
mathematical expression. It is evaluated at run time using a section of
code called the &amp;ldquo;maths parser&amp;rdquo;. There is no need for the end user to
know anything about this code. It is just there to enable the use of
mathematical expressions in the input deck. Further information about
this facility can be found
&lt;a href="/documentation/code_details/maths_parser">here&lt;/a>.&lt;/p>
&lt;h2 id="i-am-an-advanced-user-but-i-want-to-set-up-the-code-so-that-less-experienced-users-can-use-it" class="-how-do-i-do-that">I am an advanced user, but I want to set up the code so that less experienced users can use it. How do I do that?&lt;/h2>
&lt;p>See
&lt;a href="/documentation/code_details/using_epoch_in_practice#parameterising_input_decks">here&lt;/a>.&lt;/p>
&lt;h2 id="i-want-to-develop-an-addition-to-epoch" class="-how-do-i-do-that">I want to develop an addition to &lt;strong>EPOCH&lt;/strong>. How do I do that?&lt;/h2>
&lt;p>A slightly outdated developers manual exists which should be sufficient
to cover most aspects of the code functionality. However, the code is
written in a fairly modular and consistent manner, so reading through
that is the best source of information. If you get stuck then you can
post questions on the GitHub forums.&lt;/p>
&lt;h2 id="i-want-to-have-a-full-understanding-of-how-epoch-works" class="-how-do-i-do-that">I want to have a full understanding of how &lt;strong>EPOCH&lt;/strong> works. How do I do that?&lt;/h2>
&lt;p>If you really want to understand &lt;strong>EPOCH&lt;/strong> in full, the only way is to
read all of this manual and then read through the code. Most of it is
commented.&lt;/p>
&lt;h2 id="how-do-i-acknowledge-use-of-the-code">How do I acknowledge use of the code?&lt;/h2>
&lt;p>See
&lt;a href="/documentation/basic_usage/acknowledging_epoch">here&lt;/a>.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Restart from SDF dump</title><link>/quickstart/basic_examples/restart_example.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/restart_example.html</guid><description>&lt;p>It can sometimes be useful to restart an &lt;strong>EPOCH&lt;/strong> simulation from an SDF file.
Supercomputers may often place limits on job length, or systems may be prone to
crashing, so code-restarts can help prevent CPU waste.&lt;/p>
&lt;p>Using the &lt;strong>EPOCH&lt;/strong>
&lt;a href="/documentation/input_deck/input_deck_output_block.html">output block&lt;/a>,
the user is able to force the code to write restart-dumps. These differ from
regular dumps, as they write all the particle and field properties required to
restart the simulation. These will quite often be large and slow files to write,
so there is a trade-off between simulation speed (no restarts) and safety (many
restart dumps).&lt;/p>
&lt;p>In this page we will simulate a basic laser injected into a vacuum, and run the
simulation with and without restarts.&lt;/p>
&lt;h2 id="no_restart">Simulation set-up&lt;/h2>
&lt;p>Here we provide the input deck for a basic 2D simulation where a plane wave
enters
the simulation window through the &lt;code>x_min&lt;/code> boundary. This creates an SDF file
containing the &lt;code>Ey&lt;/code> field every 10 fs. This is a lightweight diagnostic, and
is not sufficient to restart the whole simulation. A plot of the electric field
from the &lt;code>0010.sdf&lt;/code> file is also present, along with the MATLAB script which
created it (other post-processing tools are available). Instructions on running
EPOCH input decks are provided
&lt;a href="/quickstart.html">here&lt;/a>.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 100 * femto
x_min = 0.0
x_max = 10.0e-6
y_min = -5.0e-6
y_max = 5.0e-6
stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
lambda = 1.0e-6
profile = 1.0
t_profile = 1.0
end:laser
begin:output
dt_snapshot = 10.0e-15
ey = always
end:output
&lt;/code>&lt;/pre>
&lt;p>This code took 3 seconds to run on a 4 core laptop. For the MATLAB
post-processing, the contents of &lt;code>epoch/SDF/MATLAB&lt;/code> were copied into the
directory containing the SDF files and &lt;code>input.deck&lt;/code>, and a plot was generated
using this script:&lt;/p>
&lt;pre>&lt;code class="language-MatLab">% Extract data
data = GetDataSDF('0010.sdf');
% Format grid
x_edges = data.Electric_Field.Ey.grid.x;
y_edges = data.Electric_Field.Ey.grid.y;
x_centres = 0.5*(x_edges(2:end) + x_edges(1:end-1));
y_centres = 0.5*(y_edges(2:end) + y_edges(1:end-1));
[x_plot, y_plot] = meshgrid(x_centres, y_centres);
% Create and format plot
surf(x_plot*1.0e6, y_plot*1.0e6, data.Electric_Field.Ey.data','EdgeColor','none');
view(2);
xlabel('x [\mum]');
ylabel('y [\mum]');
cbar = colorbar;
cbar.Label.String = 'Ey [V/m]';
ax = gca;
ax.FontSize = 16;
title(sprintf('%g fs',data.time*1.0e15));
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="restart_example.png" alt="Ey field in basic example">&lt;/p>
&lt;h2 id="restarting-from-simulation-end">Restarting from simulation end&lt;/h2>
&lt;p>Now we have a basic script, let us run it in two simulations loading the second
from a restart-dump. In our first run, we will reduce the run-time to 50 fs, and
force the final dump to be restartable. We will start the second simulation from
the 50 fs restart-dump, and run to completion.&lt;/p>
&lt;p>For the first run, take the previous &lt;code>input.deck&lt;/code> and make some changes.
Firstly, change &lt;code>t_end&lt;/code> in the control block from &lt;code>100 * femto&lt;/code> to &lt;code>50 * femto&lt;/code>.
Next, add the following line to the output block:&lt;/p>
&lt;pre>&lt;code>force_final_to_be_restartable = T
&lt;/code>&lt;/pre>
&lt;p>When we run this simulation, we find that we generate output files from
&lt;code>0000.sdf&lt;/code> to &lt;code>0005.sdf&lt;/code>. If we inspect the file-sizes, we&amp;rsquo;ll see that
&lt;code>0005.sdf&lt;/code> has a size of 18 MB, while the rest have 2 MB - our restart-dump file
is much larger.&lt;/p>
&lt;p>For the restarted run, change &lt;code>t_end&lt;/code> in the control block back to
&lt;code>100 * femto&lt;/code>, and add the control block line:&lt;/p>
&lt;pre>&lt;code>restart_snapshot = 5
&lt;/code>&lt;/pre>
&lt;p>When running the restarted deck, &lt;strong>EPOCH&lt;/strong> will print the lines:&lt;/p>
&lt;pre>&lt;code> Loading snapshot for time 5.0012906556442301E-014
Input file contains 29 blocks
Load from restart dump OK
&lt;/code>&lt;/pre>
&lt;p>if run successfully. You&amp;rsquo;ll see the SDF files continue from where they left off,
and if we were to once again print the &lt;code>Ey&lt;/code> field at &lt;code>0010.sdf&lt;/code>, we once again
find what we had before:&lt;/p>
&lt;p>&lt;img src="restart_example.png" alt="Ey field in basic example">&lt;/p>
&lt;h2 id="restart-checkpoints">Restart checkpoints&lt;/h2>
&lt;p>The previous example assumed you could split your simulation up into obvious
chunks, but what if the nodes you run on have a tendency to crash? In this case,
it would make more sense to make multiple restart dumps. While this could be
achieved by replacing &lt;code>force_final_to_be_restartable&lt;/code> with &lt;code>restart_dump_every&lt;/code>
to make multiple restart dumps, you may want to separate your restart dumps from
your usual dumps. This can be done using multiple output blocks.&lt;/p>
&lt;p>The previous example has been extended to produce two sets out output files, one
labelled &lt;code>normal0000.sdf&lt;/code> to &lt;code>normal0010.sdf&lt;/code>, and the other labelled
&lt;code>restart0000.sdf&lt;/code> to &lt;code>restart0005.sdf&lt;/code>.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 100 * femto
x_min = 0.0
x_max = 10.0e-6
y_min = -5.0e-6
y_max = 5.0e-6
stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
lambda = 1.0e-6
profile = 1.0
t_profile = 1.0
end:laser
begin:output
name = normal
file_prefix = normal
dt_snapshot = 10.0e-15
ey = always
end:output
begin:output
name = restart
file_prefix = restart
restartable = T
dt_snapshot = 20.0e-15
end:output
&lt;/code>&lt;/pre>
&lt;p>As before, the &lt;code>normal&lt;/code> dumps only contain the &lt;code>Ey&lt;/code> data. However, because the
output block named &lt;code>restart&lt;/code> contains the &lt;code>restartable=T&lt;/code> flag, all these dumps
will be restart dumps. Once we have this, we can restart from any of the restart
SDF files. Because
these files now have a prefix, we must add a line like:&lt;/p>
&lt;pre>&lt;code>restart_snapshot = restart0004.sdf
&lt;/code>&lt;/pre>
&lt;p>to the control block, where we use the full file-name.&lt;/p>
&lt;h2 id="restart-at-end-of-the-cluster-job-allocation">Restart at end of the cluster job allocation&lt;/h2>
&lt;p>The issue with regular checkpoints is that it may be overkill for your job, and
any CPU time spent after the final checkpoint is wasted when you come to
restart. Also, writing a restart dump at the end of a simulation is less useful
when you run on supercomputers, as you don&amp;rsquo;t know where you&amp;rsquo;ll be at the end of
your maximum job time!&lt;/p>
&lt;p>In this case, you need a way to automatically stop the simulation as you near
the end of your allotted time, and &lt;em>then&lt;/em> write a restart dump so you can
continue later. This can be achieved using the &lt;code>STOP&lt;/code> file.&lt;/p>
&lt;p>While running, &lt;strong>EPOCH&lt;/strong> continuously scans the directory containing
&lt;code>input.deck&lt;/code> for a file with a filename &lt;code>STOP&lt;/code>. When this file appears,
&lt;strong>EPOCH&lt;/strong> completes the current time-step, writes a restart dump, ends the
simulation, and deletes the &lt;code>STOP&lt;/code> file. No lines need to be added to the
&lt;code>input.deck&lt;/code> in order to use the &lt;code>STOP&lt;/code> functionality.&lt;/p>
&lt;p>For example, if you were to submit an &lt;strong>EPOCH&lt;/strong> job on a super-computer with an
allocated time of 5 hours, and you wanted the code to stop at 4 hours 30 mins
(leaving you 30 minutes to write a restart dump), you could add the line:&lt;/p>
&lt;pre>&lt;code>(sleep 16200; touch STOP) &amp;amp;
&lt;/code>&lt;/pre>
&lt;p>to your job-script just before &lt;strong>EPOCH&lt;/strong> is run. This will create a background
process which will wait 16200 seconds, then create the &lt;code>STOP&lt;/code> file in the
working directory of the original command. If this is the same directory as your
input deck,
this will stop the code with (hopefully) enough time to write the restart dump.
You may want to check in advance how long a restart dump takes to write for your
project, to get the timing of the &lt;code>STOP&lt;/code> file appearence correct.&lt;/p></description></item><item><title>Species block</title><link>/documentation/input_deck/input_deck_species.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_species.html</guid><description>&lt;p>This block contains information about the species of particles which are
used in the code. Also details of how these are initialised. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>The next section of the input deck describes the particle species used
in the code. An example species block for any EPOCH code is given below. In this
example, &lt;code>den_max&lt;/code> is a parameter created by the user in a
&lt;a href="/documentation/input_deck/input_deck_constant.html">constant block&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Electron
charge = -1.0
mass = 1.0
frac = 0.5
# npart = 2000 * 100
number_density = 1.e4
temp = 1e6
temp_x = 0.0
temp_y = temp_x(Electron)
number_density_min = 0.1 * den_max
number_density = if(abs(x) lt thick, den_max, 0.0)
number_density = if((x gt -thick) and (abs(y) gt 2e-6), \
0.0, number_density(Electron))
end:species
begin:species
name = Carbon
charge = 4.0
mass = 1836.0*12
frac = 0.5
number_density = 0.25*number_density(Electron)
temp_x = temp_x(Electron)
temp_y = temp_x(Electron)
dumpmask = full
end:species
&lt;/code>&lt;/pre>
&lt;p>Each species block accepts the following parameters:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>name&lt;/code> - This specifies the name of the particle species
defined in the current block. This name can include any alphanumeric
characters in the basic ASCII set. The name is used to identify the
species in any consequent input block and is also used for labelling
species data in any output dumps. It is a mandatory parameter.
**&lt;code>NOTE: IT IS IMPOSSIBLE TO SET TWO SPECIES WITH THE SAME NAME!&lt;/code>
**&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>charge&lt;/code> - This sets the charge of the species in
multiples of the electron charge. Negative numbers are used for
negatively charged particles. This is a mandatory parameter.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>mass&lt;/code> - This sets the mass of the species in multiples
of the electron mass. Cannot be negative. This is a mandatory
parameter.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>npart&lt;/code> - This specifies the number of pseudoparticles
which should be loaded into the simulation domain for this species
block. Using this parameter is the most convenient way of loading
particles for simulations which contain multiple species with
different number densities. If &lt;em>npart&lt;/em> is specified in a species
block then any value given for &lt;em>npart&lt;/em> in the
&lt;a href="/documentation/input_deck/input_deck_control">&lt;em>control&lt;/em>&lt;/a> block is ignored.
&lt;em>npart&lt;/em> should not be specified at the same time as &lt;em>frac&lt;/em> within a
&lt;em>species&lt;/em> block.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>frac&lt;/code> - This specifies what fraction of &lt;em>npart&lt;/em> (the
global number of particles specified in the control block) should be
assigned to the species.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>**&lt;code>NOTE: frac should not be specified at the same time as npart for a given species.&lt;/code>
**&lt;/p>
&lt;ul>
&lt;li>&lt;code>npart_per_cell&lt;/code> - Integer parameter which specifies
the number of particles per cell to use for the initial particle
loading. At a later stage this may be extended to allow
&amp;ldquo;npart_per_cell&amp;rdquo; to be a spatially varying function.&lt;/li>
&lt;/ul>
&lt;p>If per-species weighting is used then the value of &amp;ldquo;npart_per_cell&amp;rdquo;
will be the average number of particles per cell. If &amp;ldquo;npart&amp;rdquo; or &amp;ldquo;frac&amp;rdquo;
have also been specified for a species, then they will be ignored.&lt;/p>
&lt;p>To avoid confusion, there is no globally used &amp;ldquo;npart_per_species&amp;rdquo;. If
you want to have a single value to change in the input deck then this
can be achieved using a
&lt;a href="/documentation/input_deck/input_deck_constant">&lt;em>constant&lt;/em>&lt;/a> block.&lt;/p>
&lt;ul>
&lt;li>&lt;code>dumpmask&lt;/code> - Determines which output dumps will include
this particle species. The dumpmask has the same semantics as those used
by variables in the
&lt;a href="/documentation/input_deck/input_deck_output_block">&lt;em>output&lt;/em>&lt;/a>
block. The actual dumpmask from the output block is applied first and
then this one is applied afterwards. For example, if the species block
contains &amp;ldquo;dumpmask = full&amp;rdquo; and the output block contains &amp;ldquo;vx = always&amp;rdquo;
then the particle velocity will be only be dumped at full dumps for this
particle species. The default dumpmask is &amp;ldquo;always&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump&lt;/code> - This logical flag is provided for backwards
compatibility. If set to &amp;ldquo;F&amp;rdquo; it has the same meaning as &amp;ldquo;dumpmask =
never&amp;rdquo;. If set to &amp;ldquo;T&amp;rdquo; it has the same meaning as &amp;ldquo;dumpmask = always&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>zero_current&lt;/code> - Logical flag switching the particle
species into zero-current particles. Zero-current particles are enabled
if the if the &amp;ldquo;NO_TRACER_PARTICLES&amp;rdquo; precompiler option has not been
used and the &amp;ldquo;zero_current&amp;rdquo; flag is set to true for a given species.
When set, the species will move correctly for its charge and mass, but
contribute no current. This means that these particles are passive
elements in the simulation. In all other respects they are designed to
behave identically to ordinary particles, so they do take part in
collisions by default. This can be prevented using the
&lt;a href="/documentation/input_deck/input_deck_collisions">collision
matrices&lt;/a>.
&lt;span style="color: red; font-weight: bold;">WARNING:&lt;/span> Since the
particles effectively have zero weight in terms of their numerical
heating properties, they do not always behave in the same way that an
ordinary particle with weight would behave and this can sometimes lead
to unexpected behaviour. If the purpose is merely to track a subset of a
particle species to use as output then a better mechanism to use is
&amp;ldquo;persistent subsets&amp;rdquo; (see
&lt;a href="/documentation/input_deck/input_deck_subset">here&lt;/a>).
&amp;ldquo;tracer&amp;rdquo; is currently accepted as an alias but this will be removed in
version 5.0. &amp;ldquo;zero_current = F&amp;rdquo; is the default value.&lt;/li>
&lt;li>&lt;code>identify&lt;/code> - Used to identify the type of particle.
Originally this was used for the QED routines, but it has since been adopted for other physics packages too. See
&lt;a href="/documentation/input_deck/input_deck_qed">here&lt;/a> for details.&lt;/li>
&lt;li>&lt;code>immobile&lt;/code> - Logical flag. If this parameter is set to &amp;ldquo;T&amp;rdquo;
then the species will be ignored during the particle push. The default
value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>background_species&lt;/code> - Logical flag. If set to &amp;ldquo;T&amp;rdquo; the species will
be treated as a non evolving continuum background. No particles are loaded. Any
particle-like specifications will be ignored. Background species are currently
only used by the bremsstrahlung radiation model.
See
&lt;a href="/documentation/input_deck/input_deck_bremsstrahlung">here&lt;/a>
for details. Default value is &amp;ldquo;F&amp;rdquo;. &amp;ldquo;background&amp;rdquo; is accepted as an alias.&lt;/li>
&lt;/ul>
&lt;p>The species blocks are also used for specifying initial conditions for
the particle species. The initial conditions in EPOCH can be specified
in various ways, but the easiest way is to specify the initial
conditions in the input deck file. This allows any initial condition
which can be specified everywhere in space by a number density and a
drifting Maxwellian distribution function. These are built up using the
normal maths expressions, by setting the density and temperature for
each species which is then used by the autoloader to actually position
the particles.&lt;/p>
&lt;p>The elements of the species block used for setting initial conditions
are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>number_density&lt;/code> - Particle number density in $m^{-3}$. As
soon as a number_density= line has been read, the values are calculated
for the whole domain and are available for reuse on the right hand side
of an expression. This is seen in the above example in the first two
lines for the Electron species, where the number density is first set
and then corrected. If you wish0 to specify the number density in parts
per cubic centimetre then you can divide by the &amp;ldquo;cc&amp;rdquo; constant (see
&lt;a href="/documentation/code_details/maths_parser#constants">here&lt;/a>). This parameter is
mandatory. &amp;ldquo;density&amp;rdquo; is accepted as an alias.&lt;/li>
&lt;li>&lt;code>number_density_min&lt;/code> - Minimum particle number density in
$m^{-3}$. When the number density in a cell falls below
number_density_min the autoloader does not load any pseudoparticles
into that cell to minimise the number of low weight, unimportant
particles. If set to 0 then all cells are loaded with particles. This is
the default. &amp;ldquo;density_min&amp;rdquo; is accepted as an alias.&lt;/li>
&lt;li>&lt;code>number_density_max&lt;/code> - Maximum particle number density in
$m^{-3}$. When the number density in a cell rises above
number_density_max the autoloader clips the number_density to
number_density_max allowing easy implementation of exponential rises
to plateaus. If it is a negative value then no clipping is performed.
This is the default. &amp;ldquo;density_max&amp;rdquo; is accepted as an alias.&lt;/li>
&lt;li>&lt;code>mass_density&lt;/code> - Particle mass density in $kg,m^{-3}$.
The same as &amp;ldquo;number_density&amp;rdquo; but multiplied by the particle mass. If
you wish to use units of $g,cm^{-3}$ then append the appropriate
multiplication factor. For example: &amp;ldquo;&lt;code>mass_density = 2 * 1e3 / cc&lt;/code>&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>temp_{x,y,z}&lt;/code> - The temperature in each direction for a
thermal distribution in Kelvin.&lt;/li>
&lt;li>&lt;code>temp&lt;/code> - Sets an isotropic temperature distribution in
Kelvin. If both temp and a specific temp_x, temp_y, temp_z parameter
is specified then the last to appear in the deck has precedence. If
neither are given then the species will have a default temperature of
zero Kelvin.&lt;/li>
&lt;li>&lt;code>temp_{x,y,z}_ev, temp_ev&lt;/code> - These are the same as the
temperature parameters described above except the units are given in
electronvolts rather than Kelvin, i.e. using 1ev = 11604.5K .&lt;/li>
&lt;li>&lt;code>drift_{x,y,z}&lt;/code> - Specifies a momentum space offset in
$kg\ ms^{-1}$ to the distribution function for this species. By default,
the drift is zero.&lt;/li>
&lt;li>&lt;code>offset&lt;/code> - File offset. See below for details.&lt;/li>
&lt;/ul>
&lt;h1 id="loading_data_from_a_file">Loading data from a file&lt;/h1>
&lt;p>It is also possible to set initial conditions for a particle species
using an external file. Instead of specifying the initial conditions
mathematically in the input deck, you specify in quotation marks the
filename of a simple binary file containing the information required.
For more information on what is meant by a &amp;ldquo;simple binary file&amp;rdquo;, see
&lt;a href="/documentation/input_deck/binary_files">here&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Electron
number_density = 'Data/ic.dat'
offset = 80000
temp_x = 'Data/ic.dat'
end:species
&lt;/code>&lt;/pre>
&lt;p>The sizes of the variables to be filled do not need to be provided: the
code will continue reading until the given variable is filled. Note that
ghost or guard cells should not be included in the file as they cannot
be set this way.&lt;/p>
&lt;p>An additional element is also introduced, the offset element. This is
the offset in bytes from the start of the file to where the data should
be read from. As a given line in the block executes, the file is opened,
the file handle is moved to the point specified by the offset parameter,
the data is read and the file is then closed. Therefore, unless the
offset value is changed between data reading lines the same data will be
read into all the variables. The data is read in as soon as a line is
executed, and so it is perfectly possible to load data from a file and
then modify the data using a mathematical expression.
The example block above is for 10,000 values at double precision, i.e.
8-bytes each. The density data is the first 80,000 bytes of &amp;ldquo;ic.dat&amp;rdquo;.
Bytes 80,000 to 160,000 are the temp_x data.&lt;/p>
&lt;p>The file should be a simple binary file consisting of floating point
numbers of the same precision as &lt;strong>_num&lt;/strong> in the core EPOCH code. For
multidimensional arrays, the data is assumed to be written according to
FORTRAN array ordering rules (i.e. column-major order).
&lt;strong>&lt;code>NOTE: The files that are expected by this block are SIMPLE BINARY files, NOT FORTRAN unformatted files. It is possible to read FORTRAN unformatted files using the offset element, but care must be taken!&lt;/code>&lt;/strong>&lt;/p>
&lt;h1 id="delta_f_parameters">Delta-f parameters&lt;/h1>
&lt;p>The following entries are used for configuring the
&lt;a href="/documentation/code_details/using_delta_f">Delta-f
method&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;code>number_density_back&lt;/code>&lt;/li>
&lt;li>&lt;code>drift_{x,y,z}_back&lt;/code>&lt;/li>
&lt;li>&lt;code>temp_{x,y,z}_back&lt;/code>&lt;/li>
&lt;li>&lt;code>temp_{x,y,z}_back_ev&lt;/code>&lt;/li>
&lt;li>&lt;code>temp_back&lt;/code>&lt;/li>
&lt;li>&lt;code>temp_back_ev&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>These all have the same meanings as the parameters listed above that
don&amp;rsquo;t include the &amp;ldquo;_back&amp;rdquo; text, except that they specify the values to
use for the background distribution function.&lt;/p>
&lt;h1 id="particle_migration_between_species">Particle migration between species&lt;/h1>
&lt;p>It is sometimes useful to separate particle species into separate energy
bands and to migrate particles between species when they become more or
less energetic. A method to achieve this functionality has been
implemented. It is specified using two parameters to the &amp;ldquo;control&amp;rdquo;
block:&lt;/p>
&lt;ul>
&lt;li>&lt;code>use_migration&lt;/code> - Logical flag which determines whether or
not to use particle migration. The default is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>migration_interval&lt;/code> - The number of timesteps between
each migration event. The default is 1 (migrate at every timestep).
The following parameters are added to the &amp;ldquo;species&amp;rdquo; block:&lt;/li>
&lt;li>&lt;code>migrate&lt;/code> - Logical flag which determines whether or not to
consider this species for migration. The default is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>promote_to&lt;/code> - The name of the species to promote
particles to.&lt;/li>
&lt;li>&lt;code>demote_to&lt;/code> - The name of the species to demote particles
to.&lt;/li>
&lt;li>&lt;code>promote_multiplier&lt;/code> - The particle is promoted when its
energy is greater than &amp;ldquo;promote_multiplier&amp;rdquo; times the local average.
The default value is 1.&lt;/li>
&lt;li>&lt;code>demote_multiplier&lt;/code> - The particle is demoted when its
energy is less than &amp;ldquo;demote_multiplier&amp;rdquo; times the local average. The
default value is 1.&lt;/li>
&lt;li>&lt;code>promote_number_density&lt;/code> - The particle is only
considered for promotion when the local number density is less than
&amp;ldquo;promote_number_density&amp;rdquo;. The default value is the largest floating
point number.&lt;/li>
&lt;li>&lt;code>demote_number_density&lt;/code> - The particle is only considered
for demotion when the local number density is greater than
&amp;ldquo;demote_number_density&amp;rdquo;. The default value is 0.&lt;/li>
&lt;/ul>
&lt;h1 id="ionisation">Ionisation&lt;/h1>
&lt;p>EPOCH now includes both field and collisional ionisation, which can be
activated by switching on keys in different blocks. Previous versions of
EPOCH forced the user to specify ionisation energies for each ion charge
state, but since EPOCH 4.19, these are set automatically using look-up tables.&lt;/p>
&lt;p>Field and collisional ionisation must be switched on in the control block and
collision block respectively, and species which are to be ionised must be
specified in their species block. A basic example of using both ionisation
mechanisms is given below, where non-relevant lines have been omitted.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
use_multiphoton = T
use_bsi = F
field_ionisation = T
physics_table_location = &amp;quot;/absolute/path/to/epoch/epoch2d/src/physics_packages/TABLES&amp;quot;
end:control
begin:collisions
collisional_ionisation = T
ci_n_step = 3
end:collisions
begin:species
name = Carbon
charge = 0
atomic_no = 6
ionise = T
ionise_limit = 3
unique_electron_species = T
end:species
begin:species
name = Carbon4
charge = 4
atomic_no = 6
ionise = T
ionisation_electron_species = (Electron4, Electron)
end:species
begin:species
name = Electron
identify:electron
end:species
&lt;/code>&lt;/pre>
&lt;p>A full summary of the keys used in ionisation has been provided below:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>field_ionisation&lt;/code> - Switches on field ionisation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>collisional_ionisation&lt;/code> - Switches on ionisation by collisional
electron impact.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>physics_table_location&lt;/code> - If running the code from a non-standard
directory, you will need to specify a path to the physics tables. This can
be skipped if you run the code from the &lt;code>epoch1d&lt;/code>, &lt;code>epoch2d&lt;/code>, or &lt;code>epoch3d&lt;/code>
directories.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ci_n_step&lt;/code> - Only performs the collisional ionisation calculation
once every &lt;em>n&lt;/em> steps, where &lt;em>n&lt;/em> is set by this parameter. This is done
to speed up the code, and the default is 1 (every step). When
this is greater than 1, the assumed time-step for the collisional ionisation
calculation is &lt;em>n*dt&lt;/em>. Note that an ion may only be ionised once per calculation,
so if &lt;em>n&lt;/em> is too high, the number of ions will be underestimated.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>atomic_no&lt;/code> - Atomic number of the element. When combined with the
charge, the code can deduce the element and charge-state of the ion, and
may use the appropriate ionisation energy and shell binding energies.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ionise&lt;/code> - Allows ionisation of this species, and generates additional
particle species for each ion charge state. Here, Carbon will generate a
Carbon1, Carbon2, and Carbon3 species. If you add a Carbon2 species block, it
will be correctly linked to Carbon3. Only switch on &lt;code>ionise&lt;/code> for the base state.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ionise_limit&lt;/code> - This limits the number of additional particle species to
be generated. In this example, ion macro-particles in the Carbon species can only
be ionised 3 times - ionisation of Carbon3 will not be considered.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ionisation_electron_species&lt;/code> - Name of the electron species to
populate with ejected electrons. This
can be specified as an array in the event that the user wishes some levels
to have a different electron species which can be handy for monitoring
ionisation at specific levels. &lt;code>electron&lt;/code> and &lt;code>electron_species&lt;/code> are
accepted as synonyms. Either one species for &lt;strong>all&lt;/strong> ionisation levels, or one species
for &lt;strong>each&lt;/strong> level should be specified. In the Carbon4 example, the user may have
written &lt;code>ionisation_electron_species = Electron&lt;/code> to use the Electron species
for all ejected electrons.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>unique_electron_species&lt;/code> - If &amp;ldquo;T&amp;rdquo;, this generates a
unique electron species to populate with ejected electrons from each
ion charge state. The user must use this, or &lt;strong>ionisation_electron_species&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>identify&lt;/code> - Collisional ionisation considers ionisation between every electron
species and every species which can be ionised. To tell EPOCH which species are
electrons, you must include the &lt;code>identify:electron&lt;/code> key. EPOCH will also treat
particles in any ejected-electron species as particles which can trigger collisional
ionisation.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Ionised states are created automatically and are named according to the
ionising species name with a number appended. For example, with the Carbon
species block, the species named &amp;ldquo;Carbon1&amp;rdquo;, &amp;ldquo;Carbon2&amp;rdquo; and &amp;ldquo;Carbon3&amp;rdquo;
are automatically created. Here the Carbon4 block is pre-ionised, and ends with its
charge state. If a species name ends in its charge-state, EPOCH will recognise
that the &amp;ldquo;base name&amp;rdquo; is Carbon, and so the Carbon4 block will create a &amp;ldquo;Carbon5&amp;rdquo;
and &amp;ldquo;Carbon6&amp;rdquo; species. These species will also
inherit the ``dump''
parameter from their parent species. This behaviour can be overridden by explicitly
adding a species block of the same name with a differing dumpmask.&lt;/p>
&lt;p>Field ionisation consists of three distinct regimes; multiphoton in which
ionisation is best described as absorption of multiple photons, tunnelling
in which deformation of the atomic Coulomb potential is the dominant factor,
and barrier suppression ionisation in which the electric field is strong
enough for an electron to escape classically. It is possible to turn off
multiphoton or barrier suppression ionisation through the input deck
using the following control block parameters:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>use_multiphoton&lt;/code> - Logical flag which turns on modelling
ionisation by multiple photon absorption. This should be set to &amp;ldquo;F&amp;rdquo; if
there is no laser attached to a boundary as it relies on laser frequency.
The default is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_bsi&lt;/code> - Logical flag which turns on barrier suppression
ionisation correction to the tunnelling ionisation model for high intensity
lasers. The default is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>When collisional ionisation is switched on, ionisation between all electron species and all species which may be ionised is considered - the &lt;code>collide&lt;/code> parameter used in the collisions block has no effect on collisional ionisation. Species which may be ionised include any species with &lt;code>ionise=T&lt;/code> set, and the ionised variants of this species up to the fully ionised state, or &lt;code>ionise_limit&lt;/code>. For electrons, EPOCH will identify any species set as a destination for ejected electrons as an electron species, which can trigger further collisional ionisation. To mark other species as electrons for collisional ionisaiton, the &lt;code>identify&lt;/code> key must be used. Any electron alias may be used for &lt;code>identify&lt;/code>, including electrons created from pair production.&lt;/p>
&lt;h1 id="species_boundary_conditions">Species Boundary Conditions&lt;/h1>
&lt;ul>
&lt;li>&lt;code>bc_x_min&lt;/code> - Boundary condition to be applied to this
species only on the lower x boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_x_max&lt;/code> - Boundary condition to be applied to this
species only on the upper x boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_y_min&lt;/code> - Boundary condition to be applied to this
species only on the lower y boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_y_max&lt;/code> - Boundary condition to be applied to this
species only on the upper y boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_z_min&lt;/code> - Boundary condition to be applied to this
species only on the lower z boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_z_max&lt;/code> - Boundary condition to be applied to this
species only on the upper z boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>meet_injectors&lt;/code> - Logical flag determining whether the
background plasma should be extended to meet the point where
particle injectors operate from. This means that plasma is loaded
one particle shape function length outside the boundary. This means
that it is possible to use an injector to &amp;ldquo;continue&amp;rdquo; an existing
drifting plasma. NOT COMPATIBLE WITH PERIODIC BOUNDARY CONDITIONS!&lt;/li>
&lt;/ul>
&lt;h1 id="maxwell_juttner_distributions">Maxwell Juttner distributions&lt;/h1>
&lt;p>As of version 4.15, EPOCH allows the user to request a Maxwell-Jüttner
distribution rather than a Maxwellian distribution when sampling the
particle momentum for a species.&lt;/p>
&lt;p>This feature does not at present work with the delta_f loader and is
not available for particle injectors. It does work correctly with the
moving window.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>use_maxwell_juttner&lt;/code> - Logical flag determining
whether to sample from the Maxwell-Jüttner distribution when loading
the particle species. If &amp;ldquo;T&amp;rdquo; then Maxwell-Jüttner is used and if
&amp;ldquo;F&amp;rdquo; Maxwellian is used. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>fractional_tail_cutoff&lt;/code> - The sampling is carried out using a
rejection method with an arbitrary cut-off. This parameter takes a
floating-point argument which specifies the fraction of maximum
value at which the sampling should be cut off. Smaller values lead
to distortion nearer the peak of the distribution but are faster to
sample. Larger values lead to a better approximation of the
distribution function but are slower to sample. The default value is
0.0001.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>If drifts are specified with the Maxwell-Jüttner distribution then the
distribution is calculated in the rest frame and then Lorentz
transformed to the specified drifting frame.&lt;/p>
&lt;h1 id="arbitrary_distribution_functions">Arbitrary Distribution functions&lt;/h1>
&lt;p>As of version 4.15, EPOCH also allows the user to request an arbitrary
non-Maxwellian distribution function to use when sampling the particle
momentum for a species. If combined with a specified drift then the
distribution function is calculated first and the drift is applied to
the resulting particles by Lorentz transform.&lt;/p>
&lt;p>This feature does not at present work with the delta_f loader and is
not available for particle injectors. It does work correctly with the
moving window.&lt;/p>
&lt;ul>
&lt;li>&lt;code>dist_fn&lt;/code> - Specifies the functional form of the
distribution function, normalised to have a maximum value of 1. The
variables &amp;ldquo;px&amp;rdquo;, &amp;ldquo;py&amp;rdquo; and &amp;ldquo;pz&amp;rdquo; should be used to parameterise
the x, y and z components of momentum. This may freely vary in space
but temporal variation will be ignored since this is only evaluated
at the start of the simulation.&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>&lt;code>dist_fn_p{x,y,z}_range&lt;/code> - Comma separated pair of
numbers to specify the range of momentum for p_{x,y,z} in SI units.
Should be of the form &amp;ldquo;&amp;lt;lower_range&amp;gt;, &amp;lt;upper_range&amp;gt;&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>If a range for a momentum direction is not specified then that momentum
is assumed to be zero. It is up to the user to ensure that the range is
large enough to correctly capture their desired distribution function.
Sampling is by a simple rejection sampling and may be much slower than
the existing Maxwellian sampler. EPOCH will print a warning if a large
number of samples are needed to complete the sampling. If this occurs
then you might need to reduce the range of momentum over which sampling
is considered.&lt;/p>
&lt;p>If the &amp;ldquo;dist_fn&amp;rdquo; key is supplied then any supplied temperature keys
are ignored. An example of setting up a truncated power law distribution
in px would be&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
dens = 10
v0 = 0.05 * c
vmax = 0.5 * c
p0 = v0 * me * (1.0 + 4.0 * x/x_max)
pmax = vmax * me
alpha = -2.0
end:constant
begin:species
name = Electron_pl
charge = -1
mass = 1.0
frac = 0.5
number_density = dens
#Truncated power law distribution in px
dist_fn = exp(-p0/px) * (px/p0)^(alpha)
dist_fn_px_range = (0, pmax)
end:species
&lt;/code>&lt;/pre>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Code structure</title><link>/documentation/basic_usage/structure.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/structure.html</guid><description>&lt;p>When obtained, the EPOCH codes all have a similar structure. If the
tarred and gzipped archive (commonly referred to as a tarball) is
downloaded and unpacked into the user&amp;rsquo;s &lt;code>$HOME&lt;/code> directory, then the
extracted contents will consist of a directory named
&amp;ldquo;&lt;code>$HOME/epoch-4.12.0&lt;/code>&amp;rdquo; (with &amp;ldquo;4.12.0&amp;rdquo; substituted by the current version
number) and the subdirectories and files listed below.&lt;/p>
&lt;p>Alternatively, if the code is checked out from the GitHub git repository
with the command&lt;/p>
&lt;p>&lt;code>git clone --recursive https://github.com/Warwick-Plasma/epoch.git&lt;/code>&lt;/p>
&lt;p>then the directory will be &amp;ldquo;&lt;code>$HOME/epoch&lt;/code>&amp;rdquo;.&lt;/p>
&lt;p>Once the code has been obtained, the top-level directory will contain
the following 4 directories and several files&lt;/p>
&lt;ul>
&lt;li>epoch1d - Source code and other files required for the 1D version of
EPOCH.&lt;/li>
&lt;li>epoch2d - Source code and other files required for the 2D version of
EPOCH.&lt;/li>
&lt;li>epoch3d - Source code and other files required for the 3D version of
EPOCH.&lt;/li>
&lt;li>SDF - Source code for the SDF file format which is used to generate
output for EPOCH runs. This directory also includes various tools
and readers for working with SDF files.&lt;/li>
&lt;li>CHANGELOG - A brief overview of the change history for each released
version of EPOCH.&lt;/li>
&lt;li>CODING_STYLE - This document contains the conventions which must be
used for any code being submitted for inclusion in the EPOCH
project.&lt;/li>
&lt;li>LICENSE - A copy of the GPLv3 license which is used by the EPOCH
project.&lt;/li>
&lt;li>README.md - A brief overview of obtaining and using the EPOCH code.&lt;/li>
&lt;li>make_tarball.sh - This is a shell script which is used for creating
the tarred and gzipped archives of EPOCH which are posted to the
GitHub server each time a new release is made.&lt;/li>
&lt;li>test_all.sh - A regression test script used when testing the code.&lt;/li>
&lt;/ul>
&lt;p>The three EPOCH subdirectories all have a similar structure. Inside each
of the epoch{1,2,3}d directories, there are 3 sub-directories:&lt;/p>
&lt;ul>
&lt;li>src - The EPOCH source code.&lt;/li>
&lt;li>example_decks - A sample data directory containing example input
deck files.&lt;/li>
&lt;li>Data - This is an empty directory to use for running simulations.&lt;/li>
&lt;/ul>
&lt;p>there are also 3 files:&lt;/p>
&lt;ul>
&lt;li>Makefile - A standard makefile.&lt;/li>
&lt;li>Start.pro - An IDL script which starts the IDL visualisation
routines. Execute it using &amp;ldquo;idl Start&amp;rdquo;.&lt;/li>
&lt;li>unpack_source_from_restart - Restart dumps can be written to
contain a copy of the input decks and source code used to generate
them. This script can be used to unpack that information from a
given restart dump. It is run from the command line and must be
passed the name of the restart dump file.&lt;/li>
&lt;/ul></description></item><item><title>Compiling EPOCH</title><link>/documentation/basic_usage/compiling.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/compiling.html</guid><description>&lt;p>To compile EPOCH in the supplied state, you must first change to the
correct working directory. As explained in , the root directory for
EPOCH contains several subdirectories, including separate directories
for each of the 1D, 2D and 3D versions of the code. To compile the 2D
version of the code, you first switch to the &amp;ldquo;epoch2d&amp;rdquo; directory using
the command
&lt;strong>&lt;code>cd $HOME/epoch/epoch2d&lt;/code>&lt;/strong>
and then type
&lt;strong>&lt;code>make&lt;/code>&lt;/strong>
and the code will compile. There are certain options within the code
which are controlled by compiler preprocessors and are described in the
next section. When the code is compiled, it creates a new directory
called &amp;ldquo;bin&amp;rdquo; containing the compiled binary which will be called
&lt;code>epoch1d&lt;/code>, &lt;code>epoch2d&lt;/code> or &lt;code>epoch3d&lt;/code>. To run the code, just execute the
binary file by typing:
&lt;strong>&lt;code>./bin/epoch2d&lt;/code>&lt;/strong>
or whatever the correct binary is for the dimensionality of the code
that you have. You should be given a screen which begins with the EPOCH
logo, and then reads:&lt;/p>
&lt;pre>&lt;code>The code was compiled with no compile time options
Welcome to EPOCH2D version 4.12.0 (commit v4.12.0-0-gfd74a464-clean)
Code is running on 1 processing elements
Specify output directory
&lt;/code>&lt;/pre>
&lt;p>At this point, the user simply types in the name of the (already
existing) output directory and the code will read the input deck files
inside the specified directory and start running. To run the code in
parallel, just use the normal mpirun or mpiexec scripts supplied by your
MPI implementation. If you want the code to run unattended, then you
will need to pipe in the output directory name to be used. The method
for doing this varies between MPI implementations. For many MPI
implementations (such as recent versions of OpenMPI) this can be
achieved with the following:
&lt;strong>&lt;code>echo Data | mpirun -np 2 ./bin/epoch2d&lt;/code>&lt;/strong>
Some cluster setups accept the following instead:
&lt;strong>&lt;code>mpirun -np 2 ./bin/epoch2d &amp;lt; deck.file&lt;/code>&lt;/strong>
where &amp;ldquo;deck.file&amp;rdquo; is a file containing the name of the output directory.
Some cluster queueing systems do not allow the use of input pipes to
mpirun. In this case, there is usually a &amp;ldquo;-stdin&amp;rdquo; command line option to
specify an input file. See your cluster documentation for more details.&lt;/p>
&lt;p>As of version 4.2.12, EPOCH now checks for the existence of a file named
&amp;ldquo;USE_DATA_DIRECTORY&amp;rdquo; in the current working directory before it
prompts the user for a Data directory. If such a file exists, it reads
it to obtain the name of the data directory to use and does not prompt
the user. If no such file exists, it prompts for a data directory name
as before. This is useful for cluster setups in which it is difficult or
impossible to pipe in the directory name using a job script.&lt;/p>
&lt;p>The &amp;ldquo;Makefile&amp;rdquo; contains configurations for fort, gfortran, pgi, g95,
hector/archer and ibm (the compiler suite used on IBM&amp;rsquo;s BlueGene
machines). In order to compile using one of the listed configurations,
add the &amp;ldquo;&lt;code>COMPILER=&lt;/code>&amp;rdquo; option to the &amp;ldquo;&lt;code>make&lt;/code>&amp;rdquo; command. For example
&lt;strong>&lt;code>make COMPILER=gfortran&lt;/code>&lt;/strong>
will compile the code using the gfortran compiler and appropriate
compiler flags. The options are&lt;/p>
&lt;ul>
&lt;li>COMPILER=gfortran - GNU Fortran&lt;/li>
&lt;li>COMPILER=intel - Intel ifort&lt;/li>
&lt;li>COMPILER=pgi - Portland group compiler&lt;/li>
&lt;li>COMPILER=g95 - G95 compiler&lt;/li>
&lt;li>COMPILER=ibm - IBM AIX Fortran compiler for BlueGene&lt;/li>
&lt;li>COMPILER=hector - Cray compiler as used on hector and archer&lt;/li>
&lt;/ul>
&lt;p>As of version 4.11, it is now possible for the build system to
automatically detect the correct compiler to use. Typing
&lt;code>make COMPILER=auto&lt;/code> will cause the build system to guess which compiler
is in use. Note that this might not always work, so it is better to use
the correct value for &lt;code>COMPILER&lt;/code> if it is already known.&lt;/p>
&lt;p>You can also compile the code with debugging flags by adding
&amp;ldquo;&lt;code>MODE=debug&lt;/code>&amp;rdquo; and can compile using more than one processor by using
&amp;ldquo;&lt;code>-j&amp;lt;n&amp;gt;&lt;/code>&amp;rdquo;, where &amp;ldquo;&lt;code>&amp;lt;n&amp;gt;&lt;/code>&amp;rdquo; is the number of processors to use. Note that
this is just to speed up the compilation process; the resulting binary
can be run on any number of processors.&lt;/p></description></item><item><title>Compiler flags and preprocessor defines</title><link>/documentation/basic_usage/compiler_flags.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/compiler_flags.html</guid><description>&lt;p>As already stated, some features of the code are controlled by compiler
preprocessor directives. The flags for these preprocessor directives are
specified in &amp;ldquo;Makefile&amp;rdquo; and are placed on lines which look like the
following:&lt;/p>
&lt;pre>&lt;code>DEFINES += $(D)PER_SPECIES_WEIGHT
&lt;/code>&lt;/pre>
&lt;p>On most machines &lt;code>$(D)&lt;/code> just means &lt;code>-D&lt;/code> but the variable is required to
accommodate more exotic setups.&lt;/p>
&lt;p>Most of the flags provided in the &amp;ldquo;Makefile&amp;rdquo; are commented out by
prepending them with a &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; symbol (the &amp;ldquo;make&amp;rdquo; system&amp;rsquo;s comment
character). To turn on the effect controlled by a given preprocessor
directive, just uncomment the appropriate &amp;ldquo;DEFINES&amp;rdquo; line by deleting
this &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; symbol. The options currently controlled by the preprocessor
are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>PER_SPECIES_WEIGHT - By default, each pseudoparticle in the code
can represent a different number of real particles. Memory can be
saved by disabling this feature and have all of the pseudoparticles
in a species use the same particle weight. Many of the codes more
advanced features require per-particle weighting so it is enabled by
default. Use this flag to disable per- particle weighting if you
need to save on memory, but it this option is recommended only for
advanced users.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_TRACER_PARTICLES - This flag will disable the option to specify
one or more species as zero-current particles. Zero-current
particles move about as would a normal particle with the same charge
and mass, but they do not generate any current and are therefore
passive elements in the simulation. Zero-current particles should be
included in collisions to ensure they move identically to ordinary
particles. The implementation of zero-current particles requires an
additional &amp;ldquo;IF&amp;rdquo; clause in the particle push, so it has a slight
performance impact. If you do not require the feature then setting
this flag will give a slight performance improvement.
&lt;span style="color: red; font-weight: bold;">WARNING:&lt;/span> Since
the particles effectively have zero weight in terms of their
numerical heating properties, they do not always behave in the same
way that an ordinary particle with weight would behave and this can
sometimes lead to unexpected behaviour. If the purpose is merely to
track a subset of a particle species to use as output then a better
mechanism to use is &amp;ldquo;persistent subsets&amp;rdquo; (see
&lt;a href="/documentation/input_deck/input_deck_subset">here&lt;/a>). In version 5.0, this
flag will be and replaced with &amp;ldquo;ZERO_CURRENT_PARTICLES&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_PARTICLE_PROBES - For laser plasma interaction studies it can
sometimes be useful to be able to record information about particles
which cross a plane in the simulation. Since this requires the code
to check whether each particles has crossed the plane in the
particles pusher and also to store copies of particles until the
next output dump, it is a heavyweight diagnostic. If you don&amp;rsquo;t
require the diagnostic you can set this flag to disable it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PROBE_TIME - Paticle probes also output the time particles pass the probe.
Without this key, only the time of the SDF output dump will be available.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_SHAPE_TOPHAT - By default, the code uses a first order
b-spline (triangle) shape function to represent particles giving
third order particle weighting. Using this flag changes the particle
representation to that of a top-hat function (0th order b-spline
yielding a second order weighting).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_SHAPE_BSPLINE3 - This flag changes the particle
representation to that of a 3rd order b-spline shape function (5th
order weighting).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_ID - When this option is enabled, all particles are
assigned a unique identification number when writing particle data
to file. This number can then be used to track the progress of a
particle during the simulation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_ID4 - This does the same as the previous option except it
uses a 4-byte integer instead of an 8-byte one. Whilst this saves
storage space, care must be taken that the number does not overflow.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PHOTONS - This enables support for photon particle types in the
code. These are a pre-requisite for modelling synchrotron emission,
radiation reaction and pair production (see
&lt;a href="/documentation/input_deck/input_deck_qed">here&lt;/a>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TRIDENT_PHOTONS - This enables support for virtual photons which
are used by the Trident process for pair production.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BREMSSTRAHLUNG - Similar to photons, but for modelling bremsstrahlung
radiation instead of QED emission.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PREFETCH - This enables an Intel-specific code optimisation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARSER_DEBUG - The code outputs more detailed information whilst
parsing the input deck. This is a debug mode for code development.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_DEBUG - Each particle is additionally tagged with
information about which processor it is currently on, and which
processor it started on. This is a debug mode for code development.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MPI_DEBUG - This option installs an error handler for MPI calls
which should aid tracking down some MPI related errors.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SIMPLIFY_DEBUG - This option enables debugging code related to the
deck parser simplification routine.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_IO - This option disables all file I/O which can be useful when
doing benchmarking.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>COLLISIONS_TEST - This enables some routines for debugging the
collision routines. It completely alters the behaviour of the code.
This flag should never be enabled by the end user. Removed in
v4.19.7.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PER_PARTICLE_CHARGE_MASS - By default, the particle charge and
mass are specified on a per-species basis. With this flag enabled,
charge and mass become a per-particle property. This is a legacy
flag which will be removed in version 4.21.0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARSER_CHECKING - Setting this flag adds code which checks for
valid values on evaluated deck expressions. This slows down the code
but may be required if floating point exceptions are enabled.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>WORK_DONE_INTEGRATED - This enables support for tracking the work
done on each particle by the electric field. Note that this
increases the size of each particle by 48 bytes. The information
gathered can be output to file using the &amp;ldquo;work_{x,y,z}&amp;rdquo; and
&amp;ldquo;work_{x,y,z}_total&amp;rdquo; dumpmasks. See
&lt;a href="/documentation/input_deck/input_deck_output_block#particle_variables">here&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DELTAF_METHOD - Compile the code to use the delta-f method to
represent particles rather than standard PIC. Note that this
completely changes the code behaviour and should not be enabled for
normal use. See
&lt;a href="/documentation/code_details/using_delta_f">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DELTAF_DEBUG - Add debug code for the delta-f method.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HC_PUSH - Use the push from
&lt;a href="https://doi.org/10.1063/1.4979989" target="_blank" rel="noopener">Higuera and
Cary&lt;/a> rather than the Boris push.
This is slightly slower than the Boris push but gives the correct
$\mathbf{E} \times \mathbf{B}$ velocity, improving performance for
highly relativistic simulations.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_USE_ISATTY - When printing the initial welcome message, EPOCH
makes use of the C-library&amp;rsquo;s isatty function. This requires
Fortran2003 features that might not be available on all platforms.
The flag allows this functionality to be disabled on platforms that
don&amp;rsquo;t support it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_MPI3 - This compiler flag allows the user to disable MPI-3
features such as the &amp;ldquo;MPI_TYPE_SIZE_X&amp;rdquo; routine. This allows the
code to be compiled against older versions of the MPI library. The
flag should only be enabled if the code fails to compile without it.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="changing-precompiler-directives">Changing precompiler directives&lt;/h1>
&lt;p>If a user has already compiled EPOCH, and would like to change the active
compiler flags, then the user may comment and uncomment different flags in the
Makefile (by adding or removing # at the start of the line), and recompiling the
code using the commands:&lt;/p>
&lt;pre>&lt;code class="language-perl">make clean
make COMPILER=gfortran -j4
&lt;/code>&lt;/pre>
&lt;p>Where in this example, the gfortran compiler has been chosen.&lt;/p>
&lt;h1 id="errors_for_unspecified_precompiler_directives">Errors for unspecified precompiler directives&lt;/h1>
&lt;p>If a user requests an option which the code has not been compiled to
support then the code will give an error or warning message as follows:&lt;/p>
&lt;pre>&lt;code> *** ERROR ***
Unable to set &amp;quot;use_qed=T&amp;quot; in the &amp;quot;qed&amp;quot; block.
Please recompile with the -DPHOTONS preprocessor flag.
&lt;/code>&lt;/pre>
&lt;h1 id="other_makefile_flags">Other Makefile flags&lt;/h1>
&lt;p>It is also possible to pass other flags to the compiler. In &amp;ldquo;Makefile&amp;rdquo;
there is a line which reads&lt;/p>
&lt;pre>&lt;code>FFLAGS = -O3 -fast
&lt;/code>&lt;/pre>
&lt;p>The two commands to the right are compiler flags and are passed
unaltered to the FORTRAN compiler. Change this line to add any
additional flags required by your compiler.&lt;/p>
&lt;p>By default, EPOCH will write a copy of the source code and input decks
into each restart dump. This can be very useful since a restart dump
contains an exact copy of the code which was used to generate it,
ensuring that you can always regenerate the data or continue running
from a restart. The output can be prevented by using &amp;ldquo;dump_source_code
= F&amp;rdquo; and &amp;ldquo;dump_input_deck = F&amp;rdquo; in the output block. However, the
functionality is difficult to build on some platforms so the Makefile
contains a line for bypassing this section of the build process. Just
below all the DEFINE flags there is the following line:&lt;/p>
&lt;pre>&lt;code>#ENCODED_SOURCE = epoch_source_info_dummy.o
&lt;/code>&lt;/pre>
&lt;p>Just uncomment this line and source code in restart dumps will be
permanently disabled.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Running EPOCH and basic control of EPOCH</title><link>/documentation/basic_usage/running.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/running.html</guid><description>&lt;p>When the code is run, the output is&lt;/p>
&lt;pre>&lt;code> d########P d########b .######b d####### d##P d##P
d########P d########### d########### .########## d##P d##P
---- ---- ---- ----- ---- ----- ---- -- P
d########P d####,,,####P ####. .#### d###P d############P
d########P d#########P #### .###P ####. d############P
d##P d##P #### d#### ####. d##P d##P
d########P d##P ###########P ##########P d##P d##P
d########P d##P d######P #######P d##P d##P
The code was compiled with no compile time options
Welcome to EPOCH2D version 4.12.0 (commit v4.12.0-0-gfd74a464-clean)
Code is running on 1 processing elements
Specify output directory
&lt;/code>&lt;/pre>
&lt;p>At which point the end user should simply type in the name of the
directory where the code output is to be placed. This directory must
also include the file which controls the code setup, specifies how to
set the initial conditions and controls the I/O. Writing an input deck
for EPOCH is fairly time consuming and so the code is supplied with some
example input decks which include all the necessary sections for the
code to run. Alternately, the code checks for the Data directory in a
file named &amp;ldquo;USE_DATA_DIRECTORY&amp;rdquo; before prompting at the command-line.
This allows the code to be run without waiting for input at the
command-line.&lt;/p></description></item><item><title>Acknowledging EPOCH</title><link>/documentation/basic_usage/acknowledging_epoch.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/acknowledging_epoch.html</guid><description>&lt;h2 id="how-do-i-acknowledge-use-of-the-code">How do I acknowledge use of the code?&lt;/h2>
&lt;p>There is a paper&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> which details many aspects of the &lt;strong>EPOCH&lt;/strong>
implementation and also includes useful information on current PIC
codes. This paper is OpenAccess so freely available to all. If using
EPOCH in your research output please use this as the reference for EPOCH
and ideally also acknowledge the UK grant which funded this work. The
BibTeX entry for this paper is as follows.&lt;/p>
&lt;pre>&lt;code class="language-bibtex">@article{Arber:2015hc,
author = {Arber, T D and Bennett, K and Brady, C S and Lawrence-Douglas,
A and Ramsay, M G and Sircombe, N J and Gillies, P and Evans,
R G and Schmitz, H and Bell, A R and Ridgers, C P},
title = {{Contemporary particle-in-cell approach to laser-plasma modelling}},
journal = {Plasma Physics and Controlled Fusion},
year = {2015},
volume = {57},
number = {11},
pages = {1--26},
month = nov
}
&lt;/code>&lt;/pre>
&lt;p>Acknowledgement: &amp;ldquo;This work was in part funded by the UK EPSRC grants
EP/G054950/1, EP/G056803/1, EP/G055165/1 and EP/ M022463/1.&amp;rdquo;&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>T D Arber, K Bennett, C S Brady, A Lawrence-Douglas, M G Ramsay, N
J Sircombe, P Gillies, R G Evans, H Schmitz, A R Bell,
&amp;ldquo;Contemporary particle-in-cell approach to laser-plasma
modelling,&amp;rdquo; Plasma Physics and Controlled Fusion, 2015.
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/57/11/113001/pdf" target="_blank" rel="noopener">link&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>The EPOCH input deck</title><link>/documentation/input_deck/input_deck.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck.html</guid><description>&lt;p>Most of the control of EPOCH is through a text file called &lt;code>input.deck&lt;/code>.
The input deck file must be in the output directory which is passed to
the code at runtime and contains all the basic information which is
needed to set up the code, including the size and subdivision of the
domain, the boundary conditions, the species of particles to simulate
and the output settings for the code. For most users this will be
capable of specifying all the initial conditions and output options they
need. More complicated initial conditions will be handled in later
sections.&lt;/p>
&lt;p>The input deck is a structured file which is split into separate blocks,
with each block containing several &amp;ldquo;parameter&amp;rdquo; = &amp;ldquo;value&amp;rdquo; pairs. The
pairs can be present in any order, and not all possible pairs must be
present in any given input deck. If a required pair is missing the code
will exit with an error message. The blocks themselves can also appear
in any order. The input deck is case sensitive, so true is always &amp;ldquo;T&amp;rdquo;,
false is always &amp;ldquo;F&amp;rdquo; and the names of the parameters are always lower
case. Parameter values are evaluated using a maths parser which is
described in
&lt;a href="/documentation/code_details/maths_parser">EPOCH maths parser&lt;/a>.
If the deck contains a &amp;ldquo;&lt;code>\&lt;/code>&amp;rdquo; character then the rest of the line is
ignored and the next line becomes a continuation of the current one.
Also, the comment character is &amp;ldquo;&lt;code>#&lt;/code>&amp;quot;; if the &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; character is used
anywhere on a line then the remainder of that line is ignored.
There are three &lt;em>&lt;code>input deck directive&lt;/code>&lt;/em> commands, which are:&lt;/p>
&lt;ul>
&lt;li>begin:&lt;em>&lt;code>block&lt;/code>&lt;/em> - Begin the block named
&lt;em>&lt;code>block&lt;/code>&lt;/em>.&lt;/li>
&lt;li>end:&lt;em>&lt;code>block&lt;/code>&lt;/em> - Ends the block named
&lt;em>&lt;code>block&lt;/code>&lt;/em>.&lt;/li>
&lt;li>import:&lt;em>&lt;code>filename&lt;/code>&lt;/em> - Includes another file (called
&lt;em>&lt;code>filename&lt;/code>&lt;/em>) into the input deck at the point where the
directive is encountered. The input deck parser reads the included
file exactly as if the contents of the included file were pasted
directly at the position of the import directive.&lt;/li>
&lt;/ul>
&lt;p>Each block must be surrounded by valid &lt;em>&lt;code>begin:&lt;/code>&lt;/em> and
&lt;em>&lt;code>end:&lt;/code>&lt;/em> directives or the input deck will fail. There are
currently fourteen valid blocks hard coded into the input deck reader,
but it is possible for end users to extend the input deck. The fourteen
built in blocks are:&lt;/p>
&lt;ul>
&lt;li>control - Contains information about the general code setup. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>boundaries - Contains information about the boundary conditions for
this run. See
&lt;a href="/documentation/input_deck/input_deck_boundaries">here&lt;/a>&lt;/li>
&lt;li>species - Contains information about the species of particles which
are used in the code. Also details of how these are initialised. See
&lt;a href="/documentation/input_deck/input_deck_species">here&lt;/a>&lt;/li>
&lt;li>laser - Contains information about laser boundary sources. See
&lt;a href="/documentation/input_deck/input_deck_laser">here&lt;/a>.&lt;/li>
&lt;li>fields - Contains information about the EM fields specified at the
start of the simulation. See
&lt;a href="/documentation/input_deck/input_deck_fields">here&lt;/a>.&lt;/li>
&lt;li>particles_from_file - Contains information about files used to
load particle data. See
&lt;a href="/documentation/input_deck/input_deck_particle_file">here&lt;/a>.&lt;/li>
&lt;li>window - Contains information about the moving window if the code is
used in that fashion. See
&lt;a href="/documentation/input_deck/input_deck_window">here&lt;/a>.&lt;/li>
&lt;li>output - Contains information about when and how to dump output
files. See
&lt;a href="/documentation/input_deck/input_deck_output_block">here&lt;/a>.&lt;/li>
&lt;li>output_global - Contains parameters which should be applied to all
output blocks. See
&lt;a href="/documentation/input_deck/input_deck_output_global">here&lt;/a>.&lt;/li>
&lt;li>dist_fn - Contains information about distribution functions that
should be calculated for output. See
&lt;a href="/documentation/input_deck/input_deck_dist_fn">here&lt;/a>.&lt;/li>
&lt;li>probe - Contains information about particle probes used for output.
See
&lt;a href="/documentation/input_deck/input_deck_probe">here&lt;/a>.&lt;/li>
&lt;li>collisions - Contains information about particle collisions. See
&lt;a href="/documentation/input_deck/input_deck_collisions">here&lt;/a>.&lt;/li>
&lt;li>qed - Contains information about QED pair production. See
&lt;a href="/documentation/input_deck/input_deck_qed">here&lt;/a>.&lt;/li>
&lt;li>subset - Contains configuration for filters which can be used to
modify the data to be output. See
&lt;a href="/documentation/input_deck/input_deck_subset">here&lt;/a>.&lt;/li>
&lt;li>constant - Contains information about user defined constants and
expressions. These are designed to simplify the initial condition
setup. See
&lt;a href="/documentation/input_deck/input_deck_constant">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Bremsstrahlung block</title><link>/documentation/input_deck/input_deck_bremsstrahlung.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_bremsstrahlung.html</guid><description>&lt;p>This block contains information about bremsstrahlung radiation. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;p>EPOCH is capable of simulating bremsstrahlung radiation using the teqhniques described by Morris &lt;em>et al&lt;/em> &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> and Vyskočil &lt;em>et al&lt;/em> &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>.
In order to run this module, the compiler flag &lt;strong>&lt;code>-DBREMSSTRAHLUNG&lt;/code>&lt;/strong> must be
switched on in the Makefile. There should also be a corresponding
&amp;ldquo;bremsstrahlung&amp;rdquo; block for the input deck which uses a similar
format to the &amp;ldquo;qed&amp;rdquo; block. Bremsstrahlung cross sections may be calculated
for both electrons and positrons. Photons may also undergo pair production
according to the Bethe-Heitler model.&lt;/p>
&lt;p>An example bremsstrahlung block is shown below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:bremsstrahlung
enable = T
start_time = 0
produce_photons = T
photon_energy_min = 1 * kev
photon_weight = 1.0
photon_dynamics = F
use_plasma_screening = F
use_brem_scatter = T
use_bethe_heitler = F
use_positron_brem = F
end:bremsstrahlung
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>&lt;code>enable&lt;/code> - Logical flag to turn bremsstrahlung on or off.
&amp;ldquo;use_bremsstrahlung&amp;rdquo; is accepted as an alias. The default is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>start_time&lt;/code> - Floating point value specifying the time after
which bremsstrahlung radiation is modelled. The default is 0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>produce_photons&lt;/code> - Logical flag to allow population of a photon
species. If &amp;ldquo;F&amp;rdquo;, then only the energy loss of the electrons will be
simulated. The photon species can be specified by including the line
&lt;code>identify:brem_photon&lt;/code> in the corresponding species block. If the
compiler flag &lt;strong>&lt;code>-DPHOTONS&lt;/code>&lt;/strong> is active, QED and bremsstrahlung will both
populate the first species with &lt;code>identify:photon&lt;/code> if no
&lt;em>brem_photon&lt;/em> species is specified. The default is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>photon_energy_min&lt;/code> - Floating point value specifying the minimum
energy of produced photons. Electron energy loss is still calculated for
lower energy photon emissions, but these photons are not added to the photon
species. The default is 0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>photon_weight&lt;/code> - Floating point value which applies a multiplier to
the weight of produced macro-photons, in order to increase the number
of overall emissions and obtain better spectra. Must be less than or equal
to 1 and greater than 0. For example, 0.1 would make emission 10 times more
likely, but for macro-photons only 10% the weight of the generating
macro-electrons. Electron recoil would be reduced accordingly. The default is 1. Note that only one emission is possible
per macro-electron per timestep, so setting this too low will saturate
emissions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>photon_dynamics&lt;/code> - Logical flag to specify whether or not to push
photons. If &amp;ldquo;F&amp;rdquo;, then the generated photons are immobilised at the point of
emission. The default is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_plasma_screening&lt;/code> - Logical flag to specify whether a cross
section enhancement due to heated ionised targets is considered, based on
theory described by Wu &lt;em>et al&lt;/em>&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>. It is expected that for high energy
electrons passing through low density, ionised plasmas with electron
temperatures over $\sim$100 eV ($\sim8\times 10^{5}$ K), the bremsstrahlung
emission rate could increase by a factor of 2-3. This has not been tested
experimentally, and so the default value is set to &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_radiation_reaction&lt;/code> - Logical flag to specify whether the
electrons experience energy loss when emitting photons or not.
&amp;ldquo;use_bremsstrahlung_recoil&amp;rdquo; is accepted as an alias. Debugging
flag, default &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>table_location&lt;/code> - String specifying the
location of the emission look-up tables for bremsstrahlung.
The default path is set to
&lt;code>src/physics_packages/TABLES/br&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_brem_scatter&lt;/code> - Samples photon ejection angle from a
differential cross section. Default is &amp;ldquo;F&amp;rdquo;, where photons are emitted in the
direction of the incident particle (ultra-relativistic approximation).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_bethe_heitler&lt;/code> - Allows photons to undergo Bethe-Heitler pair
production. Default is &amp;ldquo;F&amp;rdquo;. This requires both electron and positron species
to be defined.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_positron_brem&lt;/code> - Samples bremsstrahlung radiation from positrons.
Default is &amp;ldquo;F&amp;rdquo;. If &amp;ldquo;T&amp;rdquo;, electrons and positrons share the same
parameter values set in the bremsstrahlung block.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Bremsstrahlung, like QED, requires the code to know which species are electrons
and which are photons, so uses the same identify system (with
&lt;code>identify:brem_photon&lt;/code> for a bremsstrahlung-only photon species).
Additionally, the atomic numbers of the atom/ion species are required in
the species block. For example, atomic aluminium (charge = 0) could be
specified as:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Aluminium
atomic_number = 13
charge = 0
mass = 49218
number_density = 6.022e28
fraction = 0.5
dump = T
end:species
&lt;/code>&lt;/pre>
&lt;p>If the atomic number is not specified then it will be assumed that the ion is
fully ionised and the atomic number would be set to the charge (the nearest
integer to the ion charge when expressed in units of elementary charge). If
ionisation is considered, the atomic number must be specified once, and all child species will retain the same atomic number.&lt;/p>
&lt;p>If Bethe-Heitler pair production is considered, the user may identify specific
species to populate with Bethe-Heitler electrons and positrons using the identity
aliases:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>identify:bethe_heitler_electron&lt;/code> - bh_electron is also accepted.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>identify:bethe_heitler_positron&lt;/code> - bh_positron is also accepted.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>If these species are unspecified, EPOCH will populate the first electron and
positron species present read in from the input deck. Additional identity aliases are provided in the
&lt;a href="/documentation/input_deck/input_deck_qed">QED&lt;/a> section.&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Morris, S., Robinson, A., &amp;amp; Ridgers, C. (2021).
Highly efficient conversion of laser energy to hard x-rays
in high-intensity laser–solid simulations. Physics of Plasmas, 28(10), 103304.
&lt;a href="https://aip.scitation.org/doi/full/10.1063/5.0055398" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>J. Vyskočil, O. Klimo, and S. Weber, “Simulations of
bremsstrahlung emission in ultra-intense laser
interactions with foil targets,” Plasma Physics and Controlled Fusion,
vol. 60, no. 5, p. 054013, 2018.
&lt;a href="https://iopscience.iop.org/article/10.1088/1361-6587/aab4c3/meta" target="_blank" rel="noopener">2&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>Wu, D., He, X. T., Yu, W., &amp;amp; Fritzsche, S. (2018).
Particle-in-cell simulations of laser–plasma interactions at solid
densities and relativistic intensities: the role of atomic processes. High
Power Laser Science and Engineering, 6.
&lt;a href="https://www.cambridge.org/core/journals/high-power-laser-science-and-engineering/article/particleincell-simulations-of-laserplasma-interactions-at-solid-densities-and-relativistic-intensities-the-role-of-atomic-processes/82560EBD1E5A4869CC5EC059C47A017A" target="_blank" rel="noopener">3&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Control block</title><link>/documentation/input_deck/input_deck_control.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_control.html</guid><description>&lt;p>The &lt;em>control&lt;/em> block contains information about the general code setup.
See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>The block sets up the basic code properties for the domain, the end time
of the code, the load balancer and the types of initial conditions to
use.&lt;/p>
&lt;p>The control block of a valid input deck for EPOCH2D reads as follows:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
# Global number of gridpoints
nx = 512 # in x
ny = 512 # in y
# Global number of particles
npart = 10 * nx * ny
# Final time of simulation
t_end = 1.0e-12
# nsteps = -1
# Size of domain
x_min = -0.1e-6
x_max = 400.0e-6
y_min = -400.0e-6
y_max = 400.0e-6
# dt_multiplier = 0.95
# dlb_threshold = 0.8
# restart_snapshot = 98
# field_order = 2
# maxwell_solver = yee
# stdout_frequency = 10
end:control
&lt;/code>&lt;/pre>
&lt;p>As illustrated in the above code block, the &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; symbol is
treated as a comment character and the code ignores everything on a line
following this character.
The allowed entries are as follows:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>nx, ny, nz&lt;/code> - Number of grid points in the x,y,z
direction. This parameter is mandatory.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>npart&lt;/code> - The global number of pseudoparticles in the
simulation. This parameter does not need to be given if a specific
number of particles is supplied for each particle species by using the
&amp;ldquo;npart&amp;rdquo; directive in each
&lt;a href="/documentation/input_deck/input_deck_species">&lt;strong>species&lt;/strong> block&lt;/a>.
If both are given then the
value in the &lt;strong>control&lt;/strong> block will be ignored.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>nsteps&lt;/code> - The number of iterations of the core solver
before the code terminates. Negative numbers instruct the code to only
terminate at &lt;strong>t_end&lt;/strong>. If &lt;strong>nsteps&lt;/strong> is not specified then &lt;strong>t_end&lt;/strong>
must be given.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>t_end&lt;/code> - The final simulation time in simulation seconds
before the code terminates. If &lt;strong>t_end&lt;/strong> is not specified then
&lt;strong>nsteps&lt;/strong> must be given. If they are both specified then the first time
restriction to be satisfied takes precedence. Sometimes it is more
useful to specify the time in picoseconds or femtoseconds. To accomplish
this, just append the appropriate multiplication factor. For example,
&amp;ldquo;t_end = 3 * femto&amp;rdquo; specifies 3 femtoseconds. A list of multiplication
factors is supplied
&lt;a href="/documentation/code_details/maths_parser#constants">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{x,y,z}_min&lt;/code> - Minimum grid position of the domain in
metres. These are required parameters. Can be negative. &amp;ldquo;{x,y,z}_start&amp;rdquo;
is accepted as a synonym. In a similar manner to that described above,
distances can be specified in microns using a multiplication constant.
eg. &amp;ldquo;x_min = 4 * micron&amp;rdquo; specifies a distance of 4 μm.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{x,y,z}_max&lt;/code> - Maximum grid position of the domain in
metres. These are required parameters. Must be greater than
&lt;em>{x,y,z}_min&lt;/em>. &amp;ldquo;{x,y,z}_end&amp;rdquo; is accepted as a synonym.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dt_multiplier&lt;/code> - Factor by which the timestep is
multiplied before it is applied in the code, i.e. a multiplying factor
applied to the CFL condition on the timestep. Must be less than one. If
no value is given then the default of 0.95 is used. If maxwell_solver
is different from &amp;ldquo;yee&amp;rdquo; (the default) this parameter becomes
increasingly relevant.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dlb_threshold&lt;/code> - The minimum ratio of the load on the
least loaded processor to that on the most loaded processor allowed
before the code load balances. Set to 1 means always balance, set to 0
means never balance. If this parameter is not specified then the code
will only be load balanced at initialisation time.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>restart_snapshot&lt;/code> - The number of a previously written
restart dump to restart the code from. If not specified then the initial
conditions from the input deck are used.
Note that as of version 4.2.5, this parameter can now also accept a
filename in place of a number. If you want to restart from &amp;ldquo;0012.sdf&amp;rdquo;
then it can either be specified using &amp;ldquo;restart_snapshot = 12&amp;rdquo;, or
alternatively it can be specified using &amp;ldquo;restart_snapshot = 0012.sdf&amp;rdquo;.
This syntax is required if output file prefixes have been used (see the
&lt;a href="/documentation/input_deck/input_deck_output_block">output block&lt;/a> page).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>field_order&lt;/code> - Order of the finite difference scheme used
for solving Maxwell&amp;rsquo;s equations. Can be 2, 4 or 6. If not specified, the
default is to use a second order scheme.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>maxwell_solver&lt;/code> - Choose a Maxwell solver scheme with an extended stencil. This option
is only active if field_order is set to 2. Possible options are &amp;ldquo;yee&amp;rdquo;,
&amp;ldquo;lehe_{x,y,z}&amp;rdquo;, &amp;ldquo;pukhov&amp;rdquo;, &amp;ldquo;cowan&amp;rdquo; and since v4.12 &amp;ldquo;custom&amp;rdquo;. Note that
not all options are available in 1d and 2d. The default is &amp;ldquo;yee&amp;rdquo; which
is the default second order scheme.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stdout_frequency&lt;/code> - If specified then the code will print
a one line status message to stdout after every given number or
timesteps. The default is to print nothing to screen (i.e.
&lt;strong>stdout_frequency = 0&lt;/strong>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_random_seed&lt;/code> - The initial particle distribution is
generated using a random number generator. By default, EPOCH uses a
fixed value for the random generator seed so that results are
repeatable. If this flag is set to &amp;ldquo;T&amp;rdquo; then the seed will be generated
using the system clock.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>nproc{x,y,z}&lt;/code> - Number of processes in the &lt;em>x,y,z&lt;/em>
directions (e.g. &lt;code>nprocx = 4&lt;/code>). By default, EPOCH will try to pick the best method of
splitting the domain amongst the available processors but occasionally
the user may wish to override this choice.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>smooth_currents&lt;/code> - This is a logical flag. If set to &amp;ldquo;T&amp;rdquo;
then a smoothing function is applied to the current generated during the
particle push. This can help to reduce noise and self-heating in a
simulation. The smoothing function used is the same as that outlined in
Buneman &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>field_ionisation&lt;/code> - Logical flag which turns on field
ionisation. See
&lt;a href="/documentation/input_deck/input_deck_species.html#ionisation">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>physics_table_location&lt;/code> - EPOCH expects you to run the code from the
&lt;code>epoch1d&lt;/code>, &lt;code>epoch2d&lt;/code> or &lt;code>epoch3d&lt;/code> directories, so all paths are relative to
this. If you can&amp;rsquo;t run the code from here, you must manually specify the
location of the TABLES file by setting this key to something like:
&lt;code>&amp;quot;/absolute/path/to/epoch/epoch2d/src/physics_packages/TABLES&amp;quot;&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_bsi&lt;/code> - Logical flag which turns on barrier
suppression ionisation correction to the tunnelling ionisation model for
high intensity lasers. See
&lt;a href="/documentation/input_deck/input_deck_species.html#ionisation">here&lt;/a> . This flag
should always be enabled when using field ionisation and is only
supplied for testing purposes. The default is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_multiphoton&lt;/code> - Logical flag which turns on modelling
ionisation by multiple photon absorption. This should be set to &amp;ldquo;F&amp;rdquo; if
there is no laser attached to a boundary as it relies on laser
frequency. See
&lt;a href="/documentation/input_deck/input_deck_species.html#ionisation">here&lt;/a>.
This flag should always be enabled when using field ionisation and is
only supplied for testing purposes. The default is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>particle_tstart&lt;/code> - Specifies the time at which to start
pushing particles. This allows the field to evolve using the Maxwell
solver for a specified time before beginning to move the particles.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_exact_restart&lt;/code> - Logical flag which makes a
simulation restart as close as is numerically possible to if the
simulation had not been stopped and restarted. Without this flag set to
T then the simulation will still give a correct result after restart, it
is simply not guaranteed to be identical to if the code had not been
restarted. This flag is mainly intended for testing purposes and is not
normally needed for physical simulations. If set to &amp;ldquo;T&amp;rdquo; then the domain
split amongst processors will be identical along with the seeds for the
random number generators. Note that the flag will be ignored if the
number of processors does not match that used in the original run. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_current_correction&lt;/code> - Logical flag to specify
whether EPOCH should correct for residual DC current in the initial
conditions. If set to true, the DC current in the initial conditions is
calculated and is subtracted from all subsequent current depositions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>allow_cpu_reduce&lt;/code> - Logical flag which allows the
number of CPUs used to be reduced from the number specified. In some
situations it may not be possible to divide the simulation amongst
all the processors requested. If this flag is set to &amp;ldquo;T&amp;rdquo; then EPOCH
will continue to run and leave some of the requested CPUs idle. If
set to &amp;ldquo;F&amp;rdquo; then code will exit if all CPUs cannot be utilised. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>check_stop_file_frequency&lt;/code> - Integer parameter
controlling automatic halting of the code. The frequency is
specified as number of simulation cycles. Refer to description later
in this section. The default value is 10.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stop_at_walltime&lt;/code> - Floating point parameter
controlling automatic halting of the code. Refer to description
later in this section. The default value is -1.0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stop_at_walltime_file&lt;/code> - String parameter controlling
automatic halting of the code. See
&lt;a href="#automatic_halting_of_a_simulation">below&lt;/a>. The default
value is an empty string.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>simplify_deck&lt;/code> - If this logical flag is set to &amp;ldquo;T&amp;rdquo;
then the deck parser will attempt to simplify the maths expressions
encountered after the first pass. This can significantly improve the
speed of evaluation for some input deck blocks. The default value is
&amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>print_constants&lt;/code> - If this logical flag is set to &amp;ldquo;T&amp;rdquo;,
deck constants are printed to the &amp;ldquo;deck.status&amp;rdquo; (and
&amp;ldquo;const.status&amp;rdquo; after 4.11) file as they are parsed. The default
value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_migration&lt;/code> - Logical flag which determines whether
or not to use
&lt;a href="/documentation/input_deck/input_deck_species#particle_migration_between_species">particle migration&lt;/a>.
The default is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>migration_interval&lt;/code> - The number of timesteps between
each
&lt;a href="/documentation/input_deck/input_deck_species#particle_migration_between_species">migration event&lt;/a>.
The default is 1 (migrate at every timestep).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>allow_missing_restart&lt;/code> - Logical flag to allow code to
run when a restart dump is absent. When &amp;ldquo;restart_snapshot&amp;rdquo; is
specified then the simulation first checks that the specified
restart dump is valid. If the restart dump exists and is valid then
it is used to provide initial conditions for the simulation.
However, if the restart dump does not exist or is not usable for
some reason then by default the simulation will abort. If
&amp;ldquo;allow_missing_restart&amp;rdquo; is set to &amp;ldquo;T&amp;rdquo; then the simulation will
not abort but will continue to run and use the initial conditions
contained in the input deck to initialise the simulation. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code> print_eta_string&lt;/code> - If this logical flag is set to
&amp;ldquo;T&amp;rdquo; then the current estimated time to completion will be appended
to the status updates. The default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code> n_zeros&lt;/code> - Integer flag which specifies the number of
digits to use for the output file numbers. (eg. &amp;ldquo;0012.sdf&amp;rdquo;). By
default, the code tries to calculate the number of digits required
by dividing t_end by dt_snapshot. Note that the minimum number of
digits is 4.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_accurate_n_zeros&lt;/code> - If this logical flag is set to &amp;ldquo;T&amp;rdquo; then the
code performs a more
rigorous test to determine the number of digits required to accommodate
all outputs that are to be generated by a run. Since this can be time
consuming and is overkill for most cases, it is disabled by default. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_particle_count_update&lt;/code> - If this logical flag is set to &amp;ldquo;T&amp;rdquo; then the code
keeps global particle counts for each species on each processor. This
information isn&amp;rsquo;t needed by the core algorithm, but can be useful for
developing some types of additional physics packages. It does require
one additional MPI_ALL_REDUCE per species per timestep, so it is not
activated by default. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>reset_walltime&lt;/code> - When restarting from a
dump file, the current walltime displayed will include the elapsed
walltime recorded in the restart dump. The user can request that this
time is ignored by setting the &amp;ldquo;reset_walltime&amp;rdquo; flag to &amp;ldquo;T&amp;rdquo;. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dlb_maximum_interval&lt;/code> - This integer parameter determines the maximum
number of timesteps to allow between load balancing checks. Each time
that the load balancing sweep is unable to improve the load balance of
the simulation, it doubles the number of steps before the next check
will occur. It will keep increasing the check interval until it reaches
the value given by &lt;strong>dlb_maximum_interval&lt;/strong>. If the value of
&lt;strong>dlb_maximum_interval&lt;/strong> is negative then the check interval will
increase indefinitely. When the load balancing sweep finds an
improvement to the load balance of the simulation, the check interval is
reset to one. The default value is 500.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dlb_force_interval&lt;/code> - This integer parameter determines the maximum number of timesteps to
allow between forcing a full load balance sweep. If the current load
balance is greater than the value of &lt;strong>dlb_threshold&lt;/strong> then the load
balancer exits before attempting to improve the loading. If
&lt;strong>dlb_force_interval&lt;/strong> is greater than zero, then the full load
balancer will be run at the requested interval of timesteps, regardless
of the value of &lt;strong>dlb_threshold&lt;/strong>. Note that the simulation will only
be redistributed if this would result in an improved load balance. The
default value is 2000.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>balance_first&lt;/code> - This logical flag determines whether a load balance will be attempted
on the first call of the load balancer. The load balancer performs to
functions: first it attempts to find a domain decomposition that
balances the load evenly amongst processors. Next, it redistributes the
domain and particles onto the new layout (if requred). This latter step
is always required when setting up the simulation, so the load balancer
is always called once during set-up. This flag controls whether or not a
load balance is attempted during this call, regardless of the value of
&lt;strong>dlb_threshold&lt;/strong>. The default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_pre_balance&lt;/code> - This logical flag determines whether a load balance
will be attempted before the particle load occurs. If this flag is set to
&amp;ldquo;T&amp;rdquo; then the particle auto-loader will be called at setup time, but
instead of creating particles it will just populate a particle-per-cell
field array. This will then be used to calculate the optimal domain
decomposition and all field arrays will be redistributed to use the new
layout. Finally, after all of this has been done, the auto-loader will be
called again and create just the particles that are present on their
optimally load-balanced domains. In contrast, if the flag is set to &amp;ldquo;F&amp;rdquo;
then the domain is just divided evenly amongst processors and the particles
are loaded on this domain decomposition. Balancing is then carried out on
to redistribute the work load. For heavily imbalanced problems, this can
lead to situations in which there is insufficient memory to setup a
simulation, despite there being sufficient resources for the final
load-balanced conditions. The default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_optimal_layout&lt;/code> - This logical flag determines whether the load
balancer attempts to find an optimal processor split before loading the
particles. The initial domain split is chosen in such a way as to minimize
the total surface area of the resulting domains in 3D, or edge lengths in
2D. For example, if a 2D square domain is run on 16 CPUs then the domain
will be divided by 4 in the x-direction and 4 in the y-direction. The other
possible splits (1x16, 2x8, 8x2, 16x1) are rejected because they all yield
rectangular subdomains whose total edge length is greater than the 4x4
edge length. For some problems (eg. a density ramp or thin foil) this is a
poor choice and a better load balance would be obtained by a less even
split. It is always possible to specify such a split by using
&lt;strong>nproc{x,y,z}&lt;/strong> flags but enabling the &lt;strong>use_optimal_layout&lt;/strong> flag will
automatically determine the best split for you. Future versions of the
code will also allow the split to be changed dynamically at run time. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_more_setup_memory&lt;/code> - This logical flag determines whether the extra
memory will be used during the initial setup of particle species. If set
to false then only one set of arrays will be used for storing temperature,
density and drift during species loading. This can be a significant memory
saving but omes at the expense of recalculating grid quantities multiple
times. Setting the flag to true enables one set of arrays per species. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>deck_warnings_fatal&lt;/code> - This logical flag controls the behaviour of the
deck parser when a warning is encountered. Usually the code will just
print a warning message and continue running. Setting this flag to &amp;ldquo;T&amp;rdquo;
will force the code to abort. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="maxwell_solvers">Maxwell Solvers&lt;/h1>
&lt;p>With the default settings &amp;ldquo;field_order=2&amp;rdquo;, &amp;ldquo;maxwell_solver=yee&amp;rdquo; EPOCH
will use the standard second order Yee scheme for solving Maxwell&amp;rsquo;s
equations. This scheme has a grid dispersion relation with phase
velocities smaller than $c$, especially for large spatial frequencies.
Since EPOCH v4.11 it is possible to introduce extended stencils into the
update step of the Maxwell-Faraday equation which will help improving
the dispersion relation. All of the following extended stencils are only
available when &amp;ldquo;field_order=2&amp;rdquo;. Please note that you will also need to
choose an appropriate dt_multiplier, according to the selected scheme.
A dt_multiplier equal to unity would result in using the largest
time-step allowed by the CFL condition for any of the implemented
schemes. This time-step is said to be marginally stable. While, in
general, the marginally stable time-step has the best dispersion
properties, simulations may suffer from numerical problems such as
exponentially growing noise. Choosing smaller values for the
dt_multiplier tend to improve on this, while adversely affecting the
dispersion relation. The implemented solvers behave differently in this
regard.&lt;/p>
&lt;p>Different options are available as follows:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>maxwell_solver = lehe_{x,y,z}&lt;/code> - This setting will
enable an extended stencil proposed by Lehe et al &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. This stencil
focusses on improving the dispersion relation on the $x$-axis, please
take this into account when defining your laser input. It is available
in EPOCH1D, EPOCH2D and EPOCH3D. While it is not technically required to
use a dt_multiplier smaller than unity, the value proposed by Lehe et
al &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> is &amp;ldquo;dt_multiplier=0.96&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>maxwell_solver = pukhov&lt;/code> - This setting will enable an
extended stencil proposed by Pukhov &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> under the name of NDFX. It
is available in EPOCH2D and EPOCH3D. In EPOCH1D, setting
maxwell_solver = pukhov will make the code fall back silently to
Yee&amp;rsquo;s scheme. Pukhov&amp;rsquo;s NDFX scheme aims at improving the numerical
dispersion relation by allowing to choose &amp;quot; dt_multiplier= 1.0&amp;quot;,
while smaller values are also valid. The resulting dispersion
relation is best along the axis with the smallest grid spacing.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>
&lt;p>&lt;code>maxwell_solver = cowan&lt;/code> - This setting will enable en
extended stencil proposed by Cowan et al &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>. It is available only
in EPOCH3D. In EPOCH1D and EPOCH2D, setting maxwell_solver = cowan
will make the code fall back silently to Yee&amp;rsquo;s scheme. Cowan et al
&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> proposes to numerically calculate a time step that has the
correct group velocity for the input laser. Typically these time
steps are only slightly below the CFL condition, e.g. &amp;quot; = 0.999&amp;quot;.
When Cowan&amp;rsquo;s scheme is reduced to 2D it is the same as Pukhov&amp;rsquo;s
scheme with dt_multiplier &amp;lt;1.0. The resulting dispersion relation
is best along the axis with the smallest grid spacing.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>maxwell_solver = custom&lt;/code> - This setting will enable full user control
over the extended stencil coefficients. This allows for the specification
of optimised coefficients as outlined in &lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>. This option must be
accompanied by a &amp;ldquo;stencil&amp;rdquo; block. See
&lt;a href="/documentation/input_deck/input_deck_control#stencil_block">below.&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="stencil_block">Stencil Block&lt;/h1>
&lt;p>The extended stencil Maxwell solvers described above all operate by
including points in neighbouring cells with a carefully chosen
weighting. These weightings are determined by adjusting the coefficients
shown in the Figure. Full control over these coefficients can be
achieved by specifying &amp;ldquo;custom&amp;rdquo; for the &amp;ldquo;maxwell_solver&amp;rdquo; parameter in
the control block and then supplying a &amp;ldquo;stencil&amp;rdquo; block to provide the
desired coefficient values.&lt;/p>
&lt;p>&lt;img src="Stencil.png" alt="Coefficient locations for the B_z field computational stencil in2D.">
This option allows the user to specify an extended stencil scheme that
has been specifically optimised for the simulation grid spacing and
timestep. See &lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup> for further details.
or see
&lt;a href="https://github.com/Ablinne/optimize-stencil" target="_blank" rel="noopener">6&lt;/a> for stencil
optimization code. Note that there is no option for changing the value
of $\alpha_{x,y,z}$ since these are calculated using the following
equations:
$$
\begin{aligned}
\alpha_x &amp;amp;= 1 - 2\beta_{xy} - 2\beta{xz} - 3\delta_x\,, \\\&lt;br>
\alpha_y &amp;amp;= 1 - 2\beta_{yx} - 2\beta{yz} - 3\delta_y\,, \\\&lt;br>
\alpha_z &amp;amp;= 1 - 2\beta_{zx} - 2\beta{zy} - 3\delta_z\,.
\end{aligned}
$$&lt;/p>
&lt;ul>
&lt;li>&lt;code>delta{x,y,z}, gamma{x,y,z}, beta{xy,xz,yx,yz,zx,zy}&lt;/code> -
The coefficients to use for the extended stencil points as shown in
Figure [stencil]. See for further details. These coefficients are
specified as floating point numbers. The default values are to set
all coefficients to zero which results in $\alpha_{x,y,z}$ having
values of unity. This corresponds to the standard Yee scheme.&lt;/li>
&lt;li>&lt;code>dt&lt;/code> - The timestep restriction to use for the field
solver&lt;/li>
&lt;/ul>
&lt;h1 id="strided_current_filtering">Strided Current Filtering&lt;/h1>
&lt;p>EPOCH 4.15 introduces strided multipass digital current filtering as
described and benchmarked in the review by
&lt;a href="https://www.sciencedirect.com/science/article/abs/pii/S163107211400148X" target="_blank" rel="noopener">Vay and
Godfrey&lt;/a>.
This can be tuned to substantially damp high frequencies in the currents
and can be used to reduce the effect of numerical Cherenkov radiation.
Once you turn on current filtering by specifying &amp;ldquo;smooth_currents=T&amp;rdquo;
you can then set the following keys&lt;/p>
&lt;ul>
&lt;li>&lt;code>smooth_iterations&lt;/code> - Integer number of iterations of
the smoothing function to be performed. If not present defaults to
one iteration. More iterations will produce smoother results but
will be slower.&lt;/li>
&lt;li>&lt;code>smooth_compensation&lt;/code> - Logical flag. If true then
perform a compensation step (see Vay and Godfrey &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>) after the
smoothing steps are performed. Total number of iterations if true is
smooth_iterations + 1. If not specified defaults to false&lt;/li>
&lt;li>&lt;code>smooth_strides&lt;/code> - Either a comma separated list of
integers or &amp;ldquo;auto&amp;rdquo; (without quote marks). This specifies the
strides (in number of grid cells) to use when performing strided
filtering. Specifying &amp;ldquo;1, 3&amp;rdquo; will smooth each point with the
points immediately adjacent and with the points 3 cells away on each
side of the current cell. Setting this key to &amp;ldquo;auto&amp;rdquo; uses a &amp;ldquo;1,
2, 3, 4&amp;rdquo; set of strides as a &amp;ldquo;good&amp;rdquo; starting point for strided
filtering.&lt;/li>
&lt;/ul>
&lt;p>It should be stressed that there is no set of values that is guaranteed
to give any given result from filtering while not affecting the physical
correctness of your simulation. Current filtering should be tuned to
match the problem that you want to work on and should always be
carefully tested to ensure that it doesn&amp;rsquo;t produce unphysical results.&lt;/p>
&lt;h1 id="dynamic_load_balancing">Dynamic Load Balancing&lt;/h1>
&lt;p>&amp;ldquo;dlb&amp;rdquo; in the input deck stands for Dynamic Load Balancing and, when
turned on, it allows the code to rearrange the internal domain
boundaries to try and balance the workload on each processor. This
rearrangement is an expensive operation, so it is only performed when
the maximum load imbalance reaches a given critical point. This critical
point is given by the parameter &amp;ldquo;dlb_threshold&amp;rdquo; which is the ratio of
the workload on the least loaded processor to the most loaded processor.
When the calculated load imbalance is less than &amp;ldquo;dlb_threshold&amp;rdquo; the
code performs a re-balancing sweep, so if &amp;ldquo;dlb_threshold = 1.0&amp;rdquo; is set
then the code will keep trying to re-balance the workload at almost
every timestep. At present the workload on each processor is simply
calculated from the number of particles on each processor, but this will
probably change in future. If the &amp;ldquo;dlb_threshold&amp;rdquo; parameter is not
specified then the code will only be load balanced at initialisation
time.&lt;/p>
&lt;h1 id="automatic_halting_of_a_simulation">Automatic halting of a simulation&lt;/h1>
&lt;p>It is sometimes useful to be able to halt an EPOCH simulation midway
through execution and generate a restart dump. Two methods have been
implemented to enable this.&lt;/p>
&lt;p>The first method is to check for the existence of a &amp;ldquo;STOP&amp;rdquo; file.
Throughout execution, EPOCH will check for the existence of a file named
either &amp;ldquo;STOP&amp;rdquo; or &amp;ldquo;STOP_NODUMP&amp;rdquo; in the simulation output directory. The
check is performed at regular intervals and if such a file is found then
the code exits immediately. If &amp;ldquo;STOP&amp;rdquo; is found then a restart dump is
written before exiting. If &amp;ldquo;STOP_NODUMP&amp;rdquo; is found then no I/O is
performed.&lt;/p>
&lt;p>The interval between checks is controlled by the integer parameter
&amp;ldquo;check_stop_frequency&amp;rdquo; which can be specified in the &amp;ldquo;control&amp;rdquo; block
of the input deck. If it is less than or equal to zero then the check is
never performed.&lt;/p>
&lt;p>The next method for automatically halting the code is to stop execution
after a given elapsed walltime. If a positive value for
&amp;ldquo;stop_at_walltime&amp;rdquo; is specified in the control block of an input deck
then the code will halt once this time is exceeded and write a restart
dump. The parameter takes a real argument which is the time in seconds
since the start of the simulation.&lt;/p>
&lt;p>An alternative method of specifying this time is to write it into a
separate text file. &amp;ldquo;stop_at_walltime_file&amp;rdquo; is the filename from
which to read the value for &amp;ldquo;stop_at_walltime&amp;rdquo;. Since the walltime
will often be found by querying the queueing system in a job script, it
may be more convenient to pipe this value into a text file rather than
modifying the input deck.&lt;/p>
&lt;h1 id="requesting_output_dumps_at_run_time">Requesting output dumps at run time&lt;/h1>
&lt;p>In addition to polling for the existence of a &amp;ldquo;STOP&amp;rdquo; file, EPOCH also
periodically checks the output directory for a file named &amp;ldquo;DUMP&amp;rdquo;. If
such a file is found then EPOCH will immediately create an output dump
and remove the &amp;ldquo;DUMP&amp;rdquo; file. By default, the file written will be a
restart dump but if the &amp;ldquo;DUMP&amp;rdquo; file contains the name of an output
block then this will be used instead.&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>O. Buneman, &amp;ldquo;TRISTAN: The 3-D Electromagnetic Particle Code.&amp;rdquo; in
Computer Space Plasma Physics: Simulations Techniques and Software,
1993.
&lt;a href="https://www.terrapub.co.jp/e-library/cspp/" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>R. Lehe, A. Lifschitz, C. Thaury, V. Malka, and X. Davoine,
&amp;ldquo;Numerical growth of emittance in simulations of laser-wakefield
acceleration,&amp;rdquo; Phys. Rev. Accel. Beams, vol. 16, no. 2, p.021301,
2013
&lt;a href="https://www.researchgate.net/publication/258097872_Numerical_growth_of_emittance_in_simulations_of_laser-wakefield_acceleration" target="_blank" rel="noopener">2&lt;/a>.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>Pukhov, A., &amp;ldquo;Three-dimensional electromagnetic relativistic
particle-in-cell code VLPL (Virtual Laser Plasma Lab)&amp;rdquo;, J. Plasma
Phys., vol. 61, no. 3, p. 425, 1999
&lt;a href="https://www.cambridge.org/core/journals/journal-of-plasma-physics/article/three-dimensional-electromagnetic-relativistic-particle-in-cell-code-vlpl-virtual-laser-plasma-lab/7FBA476D599E2F19DFEA3F0F2F84FFAB" target="_blank" rel="noopener">3&lt;/a>.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>B. Cowan, D. Bruhwiler, J. Cary, E. Cormier-Michel, and C. Geddes,
&amp;ldquo;Generalized algorithm for control of numerical dispersion in
explicit time-domain electromagnetic simulations&amp;rdquo;, Phys. Rev.
Accel. Beams, vol. 16, no. 4, p. 041303, 2013
&lt;a href="https://journals.aps.org/prab/abstract/10.1103/PhysRevSTAB.16.041303" target="_blank" rel="noopener">4&lt;/a>.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>A. Blinne, D. Schinkel, S. Kuschel, N. Elkina, S. G. Rykovanov,
and M. Zepf, &amp;ldquo;A systematic approach to numerical dispersion in
Maxwell solvers&amp;rdquo;, Computer Physics Communications, 00104655,
2017
&lt;a href="https://arxiv.org/pdf/1710.06829.pdf" target="_blank" rel="noopener">5&lt;/a>&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6" role="doc-endnote">
&lt;p>J. L. Vay and B. B. Godfrey,
&amp;ldquo;Modeling of relativistic plasmas with the particle-in-cell method&amp;rdquo;,
Comptes Rendus Mcanique, 2014
&lt;a href="http://www.sciencedirect.com/science/article/pii/S163107211400148X" target="_blank" rel="noopener">6&lt;/a>&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Boundaries block</title><link>/documentation/input_deck/input_deck_boundaries.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_boundaries.html</guid><description>&lt;p>This block contains information about the boundary conditions for this
run. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more
information on the input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>The &lt;em>&lt;code>boundaries&lt;/code>&lt;/em> block sets the boundary conditions of each
boundary of the domain. Some types of boundaries allow EM wave sources
(lasers) to be attached to a boundary. Lasers are attached at the
initial conditions stage.&lt;/p>
&lt;p>An example boundary block for EPOCH2D is as follows:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:boundaries
bc_x_min = simple_laser
bc_x_max_field = simple_outflow
bc_x_max_particle = simple_outflow
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>boundaries&lt;/code> block accepts the following parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>bc_{x,y,z}_min&lt;/code> - The condition for the lower boundary
for both fields and particles. &amp;ldquo;xbc_left&amp;rdquo;, &amp;ldquo;ybc_down&amp;rdquo; and &amp;ldquo;zbc_back&amp;rdquo;
are accepted as a synonyms.&lt;/li>
&lt;li>&lt;code>bc_{x,y,z}_min_{field,particle}&lt;/code> - The condition for
the lower boundary for {fields,particles}.
&amp;ldquo;xbc_left_{field,particle}&amp;rdquo;, &amp;ldquo;ybc_down_{field,particle}&amp;rdquo; and
&amp;ldquo;zbc_back_{field,particle}&amp;rdquo; are accepted as a synonyms.&lt;/li>
&lt;li>&lt;code>bc_{x,y,z}_max&lt;/code> - The condition for the upper boundary
for both fields and particles. &amp;ldquo;xbc_right&amp;rdquo;, &amp;ldquo;ybc_up&amp;rdquo; and &amp;ldquo;zbc_front&amp;rdquo;
are accepted as a synonyms.&lt;/li>
&lt;li>&lt;code>bc_{x,y,z}_max_{field,particle}&lt;/code> - The condition for
the upper boundary for {fields,particles}.
&amp;ldquo;xbc_right_{field,particle}&amp;rdquo;, &amp;ldquo;ybc_up_{field,particle}&amp;rdquo; and
&amp;ldquo;zbc_front_{field,particle}&amp;rdquo; are accepted as a synonyms.&lt;/li>
&lt;li>&lt;code>cpml_thickness&lt;/code> - The thickness of the
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> boundary in terms of the
number of grid cells. The default value is 6.&lt;/li>
&lt;li>&lt;code>cpml_kappa_max&lt;/code> - A tunable
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> parameter.&lt;/li>
&lt;li>&lt;code>cpml_a_max&lt;/code> - A tunable
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> parameter.&lt;/li>
&lt;li>&lt;code>cpml_sigma_max&lt;/code> - A tunable
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> parameter.
There are ten boundary types in EPOCH and each boundary of the domain
can have one and only one of these boundaries attached to it. These
boundary types are:&lt;/li>
&lt;li>&lt;code>periodic&lt;/code> - A simple periodic boundary condition. Fields
and/or particles reaching one edge of the domain are wrapped round to
the opposite boundary. If either boundary condition is set to periodic
then the boundary condition on the matching boundary at the other side
of the box is also assumed periodic.&lt;/li>
&lt;li>&lt;code>simple_laser&lt;/code> - A characteristic based boundary condition
to which one or more EM wave sources can be attached. EM waves impinging
on a &lt;em>simple_laser&lt;/em> boundary are transmitted with as little reflection
as possible. Particles are fully transmitted. The field boundary
condition works by allowing outflowing characteristics to propagate
through the boundary while using the attached lasers to specify the
inflowing characteristics. The particles are simply removed from the
simulation when they reach the boundary. See
&lt;a href="/documentation/input_deck/input_deck_laser"> laser
blocks&lt;/a> for details.&lt;/li>
&lt;li>&lt;code>simple_outflow&lt;/code> - A simplified version of &lt;em>simple_laser&lt;/em>
which has the same properties of transmitting incident waves and
particles, but which cannot have EM wave sources attached to it. These
boundaries are about 5% more computationally efficient than
&lt;em>simple_laser boundaries&lt;/em> with no attached sources. This boundary
condition again allows outflowing characteristics to flow unchanged, but
this time the inflowing characteristics are set to zero. The particles
are again simply removed from the simulation when they reach the
boundary.&lt;/li>
&lt;li>&lt;code>reflect&lt;/code> - This applies reflecting boundary conditions to
particles. When specified for fields, all field components are clamped
to zero.&lt;/li>
&lt;li>&lt;code>conduct&lt;/code> - This applies perfectly conducting boundary
conditions to the field. When specified for particles, the particles are
reflected.&lt;/li>
&lt;li>&lt;code>open&lt;/code> - When applied to fields, EM waves outflowing
characteristics propagate through the boundary. Particles are
transmitted through the boundary and removed from the system.&lt;/li>
&lt;li>&lt;code>cpml_laser&lt;/code> - See
&lt;a href="#cpml_boundary_conditions">#CPML boundary
conditions&lt;/a>.&lt;/li>
&lt;li>&lt;code>cpml_outflow&lt;/code> - See
&lt;a href="#cpml_boundary_conditions">#CPML boundary
conditions&lt;/a>.&lt;/li>
&lt;li>&lt;code>thermal&lt;/code> - See
&lt;a href="#thermal_boundaries">#Thermal
boundaries&lt;/a>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>NOTE: If simple_laser, simple_outflow, cpml_laser,
cpml_outflow or open are specified on one or more boundaries then the
code will no longer necessarily conserve mass.
Note also that it is possible for the user
to specify contradictory, unphysical boundary conditions. It is the
users responsibility that these flags are set correctly.&lt;/strong>&lt;/p>
&lt;h1 id="cpml_boundary_conditions">CPML boundary conditions&lt;/h1>
&lt;p>There are now Convolutional Perfectly Matched Layer boundary conditions
in EPOCH. The implementation closely follows that outlined in the book
&amp;ldquo;Computational Electrodynamics: The Finite-Difference Time-Domain
Method&amp;rdquo; by Taflove and Hagness&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. See also Roden and Gedney&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>CPML boundaries are specified in the input deck by specifying either
&amp;ldquo;cpml_outflow&amp;rdquo; or &amp;ldquo;cpml_laser&amp;rdquo; in the boundaries block.
&amp;ldquo;cpml_outflow&amp;rdquo; specifies an absorbing boundary condition whereas
&amp;ldquo;cpml_laser&amp;rdquo; is used to attach a laser to an otherwise absorbing
boundary condition.&lt;/p>
&lt;p>There are also four configurable parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>cpml_thickness&lt;/code> - The thickness of the CPML boundary in
terms of the number of grid cells. The default value is 6.&lt;/li>
&lt;li>&lt;code>cpml_kappa_max&lt;/code>, &lt;code>cpml_a_max&lt;/code>,
&lt;code>cpml_sigma_max&lt;/code> - These are tunable parameters which
affect the behaviour of the absorbing media. The notation follows that
used in the two references quoted above. Note that the
&amp;ldquo;cpml_sigma_max&amp;rdquo; parameter is normalised by $\sigma_{\rm opt}$ which
is taken to be 3.2/dx (see Taflove and Hagness&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> for details). These
are real valued parameters which take the following default values:
cpml_kappa_max=20, cpml_a_max=0.15, cpml_sigma_max=0.7
An example usage is as follows:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code> begin:boundaries
cpml_thickness = 16
cpml_kappa_max = 20
cpml_a_max = 0.2
cpml_sigma_max = 0.7
bc_x_min = cpml_laser
bc_x_max = cpml_outflow
bc_y_min = cpml_outflow
bc_y_max = cpml_outflow
end:boundaries
&lt;/code>&lt;/pre>
&lt;h1 id="thermal_boundaries">Thermal boundaries&lt;/h1>
&lt;p>Thermal boundary conditions have been added to the &amp;ldquo;boundaries&amp;rdquo; block.
These simulate the existence of a &amp;ldquo;thermal bath&amp;rdquo; of particles in the
domain adjacent to the boundary. When a particle leaves the simulation
it is replace with an incoming particle sampled from a Maxwellian of a
temperature corresponding to that of the initial conditions. It is
requested using the keyword &amp;ldquo;thermal&amp;rdquo;. For example:&lt;/p>
&lt;pre>&lt;code> begin:boundaries
bc_x_min = laser
bc_x_max = thermal
end:boundaries
&lt;/code>&lt;/pre>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>A. Taflove and S. C. Hagness, Computational Electrodynamics: The
Finite-Difference Time-Domain Method. Artech House,
2000.
&lt;a href="https://www.researchgate.net/publication/202924435_Computational_Electrodynamics_The_Finite-Difference_Time-Domain_Method" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>J. Roden and S. Gedney, &amp;ldquo;Convolution pml (cpml): An efficient fdtd
implementation of the cfs-pml for arbitrary media,&amp;rdquo; Microw. Opt.
Technol. Lett.,
2000.
&lt;a href="https://www.researchgate.net/publication/228078114_Convolutional_PML_CPML_an_efficient_FDTD_implementation_of_the_CFS-PML_for_arbitrary_media" target="_blank" rel="noopener">2&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Laser block</title><link>/documentation/input_deck/input_deck_laser.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_laser.html</guid><description>&lt;p>This block contains information about laser boundary sources. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;p>Laser blocks attach an EM wave source to a boundary which is set as
&lt;strong>simple_laser&lt;/strong>.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:laser
boundary = x_min
id = 1
intensity_w_cm2 = 1.0e15
lambda = 1.06 * micron
pol_angle = 0.0
phase = 0.0
t_profile = gauss(time, 40.0e-15, 40.0e-15)
t_start = 0.0
t_end = 80.0e-15
end:laser
&lt;/code>&lt;/pre>
&lt;p>As already mentioned in the discussion of laser boundaries in the
&lt;a href="/documentation/input_deck/input_deck_boundaries">boundaries&lt;/a> block, lasers are
attached to compatible boundaries here in the initial conditions deck.&lt;/p>
&lt;ul>
&lt;li>&lt;code>boundary&lt;/code> - The boundary on which to attach the laser. In
1D, the directions can be either x_min or x_max. &amp;ldquo;left&amp;rdquo; and &amp;ldquo;right&amp;rdquo;
are accepted as a synonyms. In 2D, y_min and y_max may also be
specified. These have synonyms of &amp;ldquo;down&amp;rdquo; and &amp;ldquo;up&amp;rdquo;. Finally, 3D adds
z_min and z_max with synonyms of &amp;ldquo;back&amp;rdquo; and &amp;ldquo;front&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>amp&lt;/code> - The amplitude of the $E$ field of the laser in
$V/m$.&lt;/li>
&lt;li>&lt;code>intensity&lt;/code> - The intensity of the laser in $W/m^2$. There
is no need to specify both intensity and amp and the last specified in
the block is the value used. It is mandatory to specify at least one.
The amplitude of the laser is calculated from intensity using the
formula &lt;code>amp = sqrt(2*intensity/c/epsilon0)&lt;/code>. &amp;ldquo;irradiance&amp;rdquo; is accepted
as a synonym. Note that spatial and temporal profiles are applied to
the electromagnetic fields of the laser, not the intensity. For
example, if a laser enters through a boundary in a cell where the
profile is set to 0.5, the intensity would be reduced to 0.25 the value
set here.&lt;/li>
&lt;li>&lt;code>intensity_w_cm2&lt;/code> - This is identical to the
&lt;strong>intensity&lt;/strong> parameter described above, except that the units are
specified in $W/cm^2$.&lt;/li>
&lt;li>&lt;code>id&lt;/code> - An id code for the laser. Used if you specify the
laser time profile in the EPOCH source rather than in the input deck.
Does not have to be unique, but all lasers with the same id will have
the same time profile. This parameter is optional and is not used under
normal conditions.&lt;/li>
&lt;li>&lt;code>omega&lt;/code> - Angular frequency (rad/s not Hz) for the laser.&lt;/li>
&lt;li>&lt;code>frequency&lt;/code> - Ordinary frequency (Hz not rad/s) for the
laser.&lt;/li>
&lt;li>&lt;code>lambda&lt;/code> - Wavelength in a vacuum for the laser specified
in $m$. If you want to specify in $\mu m$ then you can multiply by the
constant &amp;ldquo;micron&amp;rdquo;. One of &lt;strong>lambda&lt;/strong> or &lt;strong>omega&lt;/strong> (or &lt;strong>frequency&lt;/strong>) is
a required parameter.&lt;/li>
&lt;li>&lt;code>pol_angle&lt;/code> - Polarisation angle for the electric field of
the laser in radians. This parameter is optional and has a value of zero
by default. The angle is measured with respect to the right-hand triad
of propagation direction, electric and magnetic fields. Although the 1D
code has no $y$ or $z$ spatial axis, the fields still have $y$ and $z$
components. If the laser is on &lt;strong>x_min&lt;/strong> then the default $E$ field is
in the $y$-direction and the $B$ field is the $z$-direction. The
polarisation angle is measured clockwise about the $x$-axis with zero
along the $E_y$ direction. If the laser is on &lt;strong>x_max&lt;/strong> then the angle
is anti-clockwise.
**Similarly, for propagation directions:
**&lt;em>y_min&lt;/em> - angle about $y$-axis, zero along $z$-axis
**&lt;em>z_min&lt;/em> - angle about $z$-axis, zero along $x$-axis
**&lt;em>y_max&lt;/em> - angle anti-clockwise about $y$-axis, zero along $z$-axis
**&lt;em>z_max&lt;/em> - angle anti-clockwise about $z$-axis, zero along $x$-axis&lt;/li>
&lt;li>&lt;code>pol&lt;/code> - This is identical to &lt;em>pol_angle&lt;/em> with the angle
specified in degrees rather than radians. If both are specified then the
last one is used.&lt;/li>
&lt;li>&lt;code>phase&lt;/code> - The phase profile of the laser wavefront given in
radians. Phase may be a function of both space and time. The laser is
driven using ${\rm{sin}}(\omega t + \phi)$ and &lt;strong>phase&lt;/strong> is the $\phi$
parameter. There is zero phase shift applied by default.&lt;/li>
&lt;li>&lt;code>profile&lt;/code> - The spatial profile of the laser. This should
be a spatial function not including any values in the direction normal
to the boundary on which the laser is attached, and the expression will
be evaluated at the boundary. It may also be time-dependant. The laser
field is multiplied by the profile to give its final amplitude so the
intention is to use a value between zero and one. By default it is a
unit constant and therefore has no affect on the laser amplitude. This
parameter is redundant in 1D and is only included for consistency with
2D and 3D versions of the code.&lt;/li>
&lt;li>&lt;code>t_profile&lt;/code> - Used to specify the time profile for the
laser amplitude. Like &lt;strong>profile&lt;/strong> the laser field is multiplied by this
parameter but it is only a function of time and not space. In a similar
manner to &lt;strong>profile&lt;/strong>, it is best to use a value between zero and one.
Setting values greater than one is possible but will cause the maximum
laser intensity to grow beyond &lt;strong>amp&lt;/strong>. In previous versions of EPOCH,
the &lt;strong>profile&lt;/strong> parameter was only a function of space and this
parameter was used to impose time-dependance. Since &lt;strong>profile&lt;/strong> can now
vary in time, &lt;strong>t_profile&lt;/strong> is no longer needed but it has been kept to
facilitate backwards compatibility. It can also make input decks clearer
if the time dependance is given separately. The default value of
&lt;strong>t_profile&lt;/strong> is just the real constant value of 1.0.&lt;/li>
&lt;li>&lt;code>t_start&lt;/code> - Start time for the laser in seconds. Can be
set to the string &amp;ldquo;start&amp;rdquo; to start at the beginning of the simulation.
This is the default value. When using this parameter, the laser start is
hard. To get a soft start use the &lt;strong>t_profile&lt;/strong> parameter to ramp the
laser up to full strength.&lt;/li>
&lt;li>&lt;code>t_end&lt;/code> - End time for the laser in seconds, can be set to
the string &amp;ldquo;end&amp;rdquo; to end at the end of the simulation. This is the
default value. When using this parameter, the laser end is clipped
straight to zero at $t &amp;gt; t_end$. To get a soft end use the
&lt;strong>t_profile&lt;/strong> parameter to ramp the laser down to zero.
If you add multiple laser blocks to the initial conditions file then the
multiple lasers will be additively combined on the boundary.&lt;/li>
&lt;/ul>
&lt;p>In theory, any laser time profile required is possible, but the core
FDTD solver for the EM fields in EPOCH produces spurious results if
sudden changes in the field intensity occur. This is shown below. The
pulse shown on the left used a constant &lt;em>t_profile&lt;/em> and used &lt;em>t_end&lt;/em>
to stop the laser after 8fs. Since the stopping time was not an exact
multiple of the period, the result was to introduce spurious
oscillations behind the pulse. If the laser had a finite phase shift so
that the amplitude did not start at zero, a similar effect would be
observed on the front of the pulse.&lt;/p>
&lt;p>&lt;img src="Pulse2.png" alt="A laser pulse with a sharp cutoff shows numerical artefacts behind thepulse.">&lt;/p>
&lt;p>&lt;img src="Pulse1.png" alt="A laser pulse with a smooth temporal profile shows noartefacts.">&lt;/p>
&lt;p>The second figure instead used a Gaussian window function with a
characteristic width of 8fs as well as using &lt;em>t_end&lt;/em> to introduce a
hard cutoff. It can clearly be seen that there are no spurious
oscillations and the wave packet propagates correctly, showing only some
dispersive features.&lt;/p>
&lt;p>There is no hard and fast rule as to how rapid the rise or fall for a
laser can be, and the best advice is to simply test the problem and see
whether any problems occur. If they do then there are various solutions.
Essentially, the timestep must be reduced to the point where the sharp
change in amplitude can be accommodated. The best solution for this is
to increase the spatial resolution (with a comparable increase in the
number of pseudoparticles), thus causing the timestep to drop via the
CFL condition.&lt;/p>
&lt;p>This is computationally expensive, and so a cheaper option is simply to
decrease the input.deck option &lt;em>dt_multiplier&lt;/em>. This artificially
decreases the timestep below the timestep calculated from the internal
stability criteria and allows the resolution of sharp temporal
gradients. This is an inferior solution since the FDTD scheme has
increased error as the timestep is reduced from that for EM waves. EPOCH
includes a high order field solver to attempt to reduce this.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Fields block</title><link>/documentation/input_deck/input_deck_fields.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_fields.html</guid><description>&lt;p>This block contains information about the EM fields specified at the
start of the simulation. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>This block allows you to specify the electric and magnetic fields at any
point in the domain. An example block is shown below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:fields
ex = sin(pi * x / length_x)
ey = cos(pi * x / length_x)
ez = 0
bx = 1.0
by = -1.0
bz = 0
end:fields
&lt;/code>&lt;/pre>
&lt;p>Once again, this is a very simple block needing only limited
explanation. All field variables are accessible by name and can be read
back using the appropriate commands from the maths parser (see
&lt;a href="/documentation/code_details/maths_parser#constants">here&lt;/a>). The possible
parameters are as follows:&lt;/p>
&lt;ul>
&lt;li>&lt;code>ex,ey,ez&lt;/code> - The electric field vectors pointing in all
three directions. The default value is zero.&lt;/li>
&lt;li>&lt;code>bx,by,bz&lt;/code> - The magnetic field vectors pointing in all
three directions. The default value is zero.&lt;/li>
&lt;li>&lt;code>offset&lt;/code> - File offset. The field values may also be
specified using a binary file in a similar way to that used for species
variables. See
&lt;a href="/documentation/input_deck/input_deck_species">the species block&lt;/a>
for more details.
Any valid maths parser expression can be used to set up the fields, and
no check is made to ensure that the $\nabla.B = 0$ is satisfied.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Window block</title><link>/documentation/input_deck/input_deck_window.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_window.html</guid><description>&lt;p>This block contains information about the moving window if the code is
used in that fashion. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>EPOCH can include an optional block which causes the simulation domain
to operate as a moving window. At present, it is only possible to have
the window moving at a speed parallel to the x direction, although the
window does not have to start moving at t = 0. When the window moves,
the code removes particles from the left hand edge of the domain and
introduces new particles at the right hand edge. The new particles are
placed by re-evaluating the species density, temperature and drift using
the new time and spatial coordinates. The block looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:window
move_window = T
window_v_x = 3.0e8
window_start_time = 7.0e-13
bc_x_min_after_move = simple_outflow
bc_x_max_after_move = simple_outflow
end:window
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>move_window&lt;/code> - Logical flag determining whether or not
to move the window. If the window block is absent then this is the
same as setting move_window to &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>window_v_x&lt;/code> - The speed in m/s of the window.&lt;/li>
&lt;li>&lt;code>window_start_time&lt;/code> - The time in seconds at which the
window should start moving.&lt;/li>
&lt;li>&lt;code>window_stop_time&lt;/code> - The time in seconds at which the window should stop moving.&lt;/li>
&lt;li>&lt;code>bc_x_min_after_move&lt;/code> - The boundary condition which
should apply to the left boundary after the window has started moving.
This is to allow the swapping of a laser boundary to a simple outflow
boundary. Boundary codes are the same as when just specifying normal
boundaries. If a boundary value isn&amp;rsquo;t specified then it is assumed that
the boundary isn&amp;rsquo;t changed when the window starts moving.
&amp;ldquo;xbc_left_after_move&amp;rdquo; is accepted as a synonym.&lt;/li>
&lt;li>&lt;code>bc_x_max_after_move&lt;/code> - The boundary condition which
should apply to the right boundary after the window has started moving.
&amp;ldquo;xbc_right_after_move&amp;rdquo; is accepted as a synonym.&lt;/li>
&lt;li>&lt;code>bc_{y,z}_{min,max}_after_move&lt;/code> - &amp;ldquo;y&amp;rdquo; and &amp;ldquo;z&amp;rdquo;
versions of the previous two parameters. &lt;strong>ybc_down_after_move&lt;/strong>,
&lt;strong>ybc_up_after_move&lt;/strong>, &lt;strong>zbc_back_after_move&lt;/strong> and
&lt;strong>zbc_front_after_move&lt;/strong> are accepted as synonyms.&lt;/li>
&lt;/ul>
&lt;h1 id="compatibility">Compatibility&lt;/h1>
&lt;p>Because of how the moving window must work, there are some compatibility
issues with certain features. In particular:&lt;/p>
&lt;ul>
&lt;li>lasers attached to an X boundary which remain in place after the
window moves, or attached to Y or Z boundaries:
&lt;ul>
&lt;li>The laser will behave as though it is attached to the window
itself: for Y or Z boundaries with spatial variations this may
not give the expected result&lt;/li>
&lt;li>For X boundaries, the moving emitter will result in a form of
numerical Doppler shifting. In addition to this the boundary
used to drive the field will shift discontinuously, yielding
noisy and erratic changes in the electromagnetic field.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Injectors attached to an X boundary will not work. Those on a Y or Z
boundary may appear to work, but the rates will be incorrect.&lt;/li>
&lt;li>CPML boundary conditions:
&lt;ul>
&lt;li>in X these cannot work as they rely on time-history which is
simply missing.&lt;/li>
&lt;li>On Y or Z boundaries they will approximately work, but the
history will be truncated and so they will generally require
more tuning. We can&amp;rsquo;t help with this in general.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Load of particles from file is not supported since it can&amp;rsquo;t be made
to work in general.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Output block</title><link>/documentation/input_deck/input_deck_output_block.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_output_block.html</guid><description>&lt;p>This block contains information about when and how to dump output files.
See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>Output in EPOCH is handled using the custom designed SDF file format
(&lt;em>Self Describing Format&lt;/em>). A detailed specification of this format is
available elsewhere, although this is only of interest to developers
wishing to write new libraries. EPOCH comes with readers for ITT IDL,
LLNL VisIt, Mathworks MatLab and Python. The IDL reader is also
compatible with the open source GDL tool.&lt;/p>
&lt;p>There are two styles of output block supported by EPOCH. The first
style, which will be referred to as the &amp;ldquo;traditional&amp;rdquo; style, is the
method that has been supported by EPOCH since its inception. With this
method, a single output block governs all the output dumps which are to
be performed. There are a few levels of output which give some small
amount of flexibility over what gets dumped but these do not allow for a
very fine-grained control.&lt;/p>
&lt;p>In version 4.0 of EPOCH, a new style was introduced in which multiple
named output blocks may be specified allowing for much greater
flexibility. The existence of a &amp;ldquo;name&amp;rdquo; parameter is what determines that
an output block is the new style rather than the traditional style.&lt;/p>
&lt;p>Most of the parameters are shared by both styles. The following sections
document the traditional style of output block and any differences
between the two styles are described
&lt;a href="#multiple_output_blocks">below&lt;/a> .&lt;/p>
&lt;p>What the code should output and when it should output it is specified in
the &amp;ldquo;output&amp;rdquo; block of the input deck. An example output block is shown
below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
# If use_offset_grid is true then the code dumps a grid which
# displays positions relative to the left hand edge of the window
use_offset_grid = F
# number of timesteps between output dumps
dt_snapshot = 1.0e-14
# Number of dt_snapshot between full dumps
full_dump_every = 10
restart_dump_every = -1
force_final_to_be_restartable = T
# Properties at particle positions
particles = never
px = never
py = never
pz = never
vx = never
vy = never
vz = never
charge = never
mass = never
particle_weight = never
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
jy = always
ekbar = always + species
mass_density = never + species
charge_density = always
number_density = always + species
temperature = always + species
distribution_functions = always
particle_probes = never
end:output
&lt;/code>&lt;/pre>
&lt;p>There are three types of output dump in EPOCH which are used for
different purposes. These types are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>normal&lt;/code> - The most frequent type of output dump in EPOCH is a normal
dump.&lt;/li>
&lt;li>&lt;code>full&lt;/code> - A full dump is usually written every 10 or so normal dumps. A
full dump contains all the data that a normal dump contains and
should also contain any information which is needed only
infrequently, whether this is the full particle information or a
large distribution function. It is possible to turn off full dumps
completely.&lt;/li>
&lt;li>&lt;code>restart&lt;/code> - A restart dump is a dump where the code guarantees to
write enough data to allow the code to restart from the output.
Output dumps are guaranteed to contain all the information in a
normal dump and, if they coincide with the timing for a full dump,
will also contain the full dump information.&lt;/li>
&lt;/ul>
&lt;p>Information will never be written into a file twice, even if two
conditions for it being written are satisfied (i.e even if px should be
dumped both because it is a full dump and a restart dump, px will only
be written once).&lt;/p>
&lt;p>Note that these dump levels only really make sense for the traditional
style of output block and are not really required when the new style is
used.&lt;/p>
&lt;h1 id="dumpmask">Dumpmask&lt;/h1>
&lt;p>When specifying which type of output dump to write a variable to there
are eight options which can be specified for each variable and can be
combined by addition. Some combinations make no sense but are formally
valid. The first four options specify at which output types the variable
is to be dumped:&lt;/p>
&lt;ul>
&lt;li>&lt;code>never&lt;/code> - If the variable is not a required restart
variable then it will never be written. If it is a required restart
variable then it will be written only at restart dumps.&lt;/li>
&lt;li>&lt;code>full&lt;/code> - This variable will be written at full dumps only.&lt;/li>
&lt;li>&lt;code>always&lt;/code> - This variable will be written at full, normal
and restart dumps.&lt;/li>
&lt;li>&lt;code>restart&lt;/code> - This variable will be written at restart dumps
only. Note that variables required for restarting the code are always
written to restart dumps. This flag is to enable the writing of
additional variables into such dump files.
For grid variables derived from summing over particles (ie. &amp;ldquo;ekbar&amp;rdquo;,
&amp;ldquo;mass_density&amp;rdquo;, &amp;ldquo;charge_density&amp;rdquo;, &amp;ldquo;number_density&amp;rdquo;, &amp;ldquo;temperature&amp;rdquo;)
the following two parameters also apply.&lt;/li>
&lt;li>&lt;code>species&lt;/code> - The derived variable should be output on a
species by species basis. It is combined with a dumpmask code by
addition as in:
&lt;strong>charge_density = always + species&lt;/strong> .&lt;/li>
&lt;li>&lt;code>no_sum&lt;/code> - The output for this derived variable should not
be summed over all species. By default, derived variables are summed
over all species. If you don&amp;rsquo;t want to include this sum, you must use
the &amp;ldquo;no_sum&amp;rdquo; flag. It is combined with a dumpmask code by addition as
in:
&lt;strong>charge_density = always + species + no_sum&lt;/strong> .
Most grid variables may be averaged over time. A more detailed
description of this is given in
&lt;a href="#data_averaging">#Data
Averaging&lt;/a>. Data averaging is specified
using the following dumpmask parameters.&lt;/li>
&lt;li>&lt;code>average&lt;/code> - The output for this variable should be averaged
over time. The time span over which the variable will be averaged is
controlled using flags described
&lt;a href="#directives">below&lt;/a>.&lt;/li>
&lt;li>&lt;code>snapshot&lt;/code> - By default, the &amp;ldquo;average&amp;rdquo; parameter replaces
the variable with an averaged version of the data. Adding this flag
specifies that the non-averaged variable should also be dumped to file.
When applied to a variable, these codes are referred to as a &lt;em>dumpmask&lt;/em>.&lt;/li>
&lt;/ul>
&lt;h1 id="directives">Directives&lt;/h1>
&lt;p>The first set of options control the type and frequency of output dumps.
They are used as follows&lt;/p>
&lt;ul>
&lt;li>&lt;code>disabled&lt;/code> - Logical flag. If this is set to &amp;ldquo;T&amp;rdquo; then the
block is ignored and never generates any output. The default value is
&amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dt_snapshot&lt;/code> - Sets the interval between normal output
dumps in simulation seconds. Setting zero or negative means that the
code will not output based on this condition. The code does NOT
guarantee that outputs will be exactly &lt;em>dt_snapshot&lt;/em> apart, what is
guaranteed is that the next output will be after the first iteration
which takes the simulation to a time $\ge$ &lt;em>dt_snapshot&lt;/em> from the last
output. As with other variables which specify a unit of time, it can be
specified in more convenient unit by using a multiplication factor (see
&lt;a href="/documentation/code_details/maths_parser#constants">here&lt;/a>). For example,
&amp;ldquo;dt_snapshot = 5 * femto&amp;rdquo; will set it to be 5 femtoseconds. The
default value is a large number which will never trigger an output.&lt;/li>
&lt;li>&lt;code>nstep_snapshot&lt;/code> - Sets the number of timesteps between
normal output dumps. Setting zero or negative means that the code will
not output based on this condition. If &lt;em>dt_snapshot&lt;/em> is also specified
then both conditions are considered and output will be generated when
either condition is met. The default value is a large integer which will
never trigger an output.&lt;/li>
&lt;li>&lt;code>full_dump_every&lt;/code> - The number of normal output dumps
between full output dumps. Setting to zero makes every dump a full dump.
Setting to a negative number stops the code from producing any full
dumps. This is the default.&lt;/li>
&lt;li>&lt;code>restart_dump_every&lt;/code> - The number of normal output dumps
between restart dumps. Setting to zero makes every dump a restart dump.
Setting to a negative number stops the code from producing any restart
dumps. This is the default.&lt;/li>
&lt;li>&lt;code>force_first_to_be_restartable&lt;/code> - Logical flag which
determines whether the file written at time zero is a restart dump. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>force_last_to_be_restartable&lt;/code> - Force the code to
override other output settings and make the last output dump it writes
be a restart dump. Any internal condition which causes the code to
terminate will make the code write a restart dump, but code crashes or
scheduler terminations will not cause the code to write a restart dump.
&amp;ldquo;force_final_to_be_restartable&amp;rdquo; is accepted as a synonym. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump_first&lt;/code> - Logical flag which determines whether to
write an output file immediately after initialising the simulation. The
default is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump_last&lt;/code> - Logical flag which determines whether to
write an output file just before ending the simulation. The default is
&amp;ldquo;T&amp;rdquo; if an output block exists in the input deck and &amp;ldquo;F&amp;rdquo; otherwise.
&amp;ldquo;dump_final&amp;rdquo; is accepted as a synonym.&lt;/li>
&lt;li>&lt;code>time_start&lt;/code> - Floating point parameter which specifies
the simulation time at which to start considering output for the block.
Note that if &amp;ldquo;dump_first&amp;rdquo; or &amp;ldquo;dump_last&amp;rdquo; are set to true for this
block then dumps will occur at the first or last timestep regardless of
the value of the &lt;em>time_start&lt;/em> parameter. This also applies to the three
following parameters. The default value is 0.&lt;/li>
&lt;li>&lt;code>time_stop&lt;/code> - Floating point parameter which specifies the
simulation time at which to stop considering output for the block. The
default value is the largest possible float.&lt;/li>
&lt;li>&lt;code>nstep_start&lt;/code> - Integer parameter which specifies the step
number at which to start considering output for the block. The default
value is 0.&lt;/li>
&lt;li>&lt;code>nstep_stop&lt;/code> - Integer parameter which specifies the step
number at which to stop considering output for the block. The default
value is the largest possible integer.&lt;/li>
&lt;li>&lt;code>walltime_start&lt;/code> - Floating point parameter which specifies the elapsed walltime in
seconds at which to start considering output for the block. Note that if
&lt;strong>dump_first&lt;/strong> or &lt;strong>dump_last&lt;/strong> are set to true for this block then
dumps will occur at the first or last timestep regardless of the value
of the &lt;strong>walltime_start&lt;/strong> parameter. The default value is 0.&lt;/li>
&lt;li>&lt;code>walltime_stop&lt;/code> - Floating point parameter which specifies the elapsed walltime in
seconds at which to stop considering output for the block. The default
value is the largest possible float.&lt;/li>
&lt;li>&lt;code>dump_cycle&lt;/code> - If this is set to a positive integer then
the output file number will be reset to zero after the specified cycle
number is reached. eg. if &amp;ldquo;dump_cycle = 2&amp;rdquo; then the sequence of output
dumps will be 0000.sdf, 0001.sdf, 0002.sdf, 0000.sdf, 0001.sdf, etc. The
default is 0, so dump cycling never occurs.&lt;/li>
&lt;li>&lt;code>dump_cycle_first_index&lt;/code> - If this is set to a positive
integer then the value is used as the first index to use when cycling
output dumps due to the &amp;ldquo;dump_cycle&amp;rdquo; parameter. For example, if
&amp;ldquo;dump_cycle = 2&amp;rdquo; and &amp;ldquo;dump_cycle_first_index = 1&amp;rdquo; then the sequence
of output dumps will be 0000.sdf, 0001.sdf, 0002.sdf, 0001.sdf,
0002.sdf, 0001.sdf, etc. The default is 0.&lt;/li>
&lt;li>&lt;code>dump_source_code&lt;/code> - EPOCH has the ability to write its
own source code into restart dumps. This is generated at compile time
and embedded into the binary and so is guaranteed to match that
corresponding to the running code. EPOCH comes with a script called
&lt;em>unpack_source_from_restart&lt;/em> which can be used to unpack the source
code from a restart dump. To use this script, just type
&lt;strong>unpack_source_from_restart &amp;lt;sdf_filename&amp;gt;&lt;/strong> at the command-line. If
this logical flag is set to false then the feature will be disabled. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump_input_decks&lt;/code> - If this logical flag is set to true
then a copy of the input decks for the currently running simulation is
written into the restart dumps. The default value is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dt_average&lt;/code> - When averaged variables are being output to
file, this parameter specifies the simulation time period over which
averaging is to occur. &amp;ldquo;averaging_period&amp;rdquo; is accepted as a synonym.&lt;/li>
&lt;li>&lt;code>nstep_average&lt;/code> - When averaged variables are being output
to file, this parameter specifies the number of time steps over which
averaging is to occur. &amp;ldquo;min_cycles_per_average&amp;rdquo; is accepted as a
synonym. If both &lt;em>dt_average&lt;/em> and &lt;em>nstep_average&lt;/em> are specified, the
code will use the one which gives the longest simulation time-span.&lt;/li>
&lt;li>&lt;code>use_offset_grid&lt;/code> - When using moving windows some
visualisation programs (notably VisIt) show the motion of the window by
moving the visualisation window rather than by changing the x-axis.
Setting this option to &amp;ldquo;T&amp;rdquo; causes the code to write another grid which
always gives the offset relative to the left hand edge of the window
rather than the true origin. Performs no function when not using the
moving window. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>filesystem&lt;/code> - String parameter. Some filesystems can be
unreliable when performing parallel I/O. Often this is fixable by
prefixing the filename with &amp;lsquo;ufs&amp;rsquo; or &amp;lsquo;nfs&amp;rsquo;. This parameter supplies the
prefix to be used. The default value is an empty string.&lt;/li>
&lt;li>&lt;code>file_prefix&lt;/code> - Although this parameter is supported by
the traditional style of output block, its primary purpose is for use
with multiple output blocks so it is documented in .
A few additional parameters have been added for use with the new style
of output block. These are documented
&lt;a href="#multiple_output_blocks">below&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h1 id="particle_variables">Particle Variables&lt;/h1>
&lt;p>The next set are per particle properties. If you wish to plot these
according to their spatial positions, you must include the
&amp;ldquo;particle_grid&amp;rdquo; in your output variables. All entries have a default
dumpmask of &amp;ldquo;never&amp;rdquo;.&lt;/p>
&lt;ul>
&lt;li>&lt;code>particle_grid&lt;/code> - Requests the output of particle
positions. This is a restart variable. No particle variables can be
plotted in VisIt unless this is dumped. If any particle variables are
written then the &amp;ldquo;particle_grid&amp;rdquo; is automatically written unless
&amp;ldquo;particle_grid = never&amp;rdquo; is specified. The synonym &amp;ldquo;particles&amp;rdquo; may also
be used.&lt;/li>
&lt;li>&lt;code>px,py,pz&lt;/code> - The dumpmasks for the particle momenta.
Restart variable.&lt;/li>
&lt;li>&lt;code>vx,vy,vz&lt;/code> - The dumpmasks for the particle velocities.&lt;/li>
&lt;li>&lt;code>charge&lt;/code> - The dumpmask for the charge of a given particle.
This has no effect if the code is not compiled with the flag
&amp;ldquo;-DPER_PARTICLE_CHARGE_MASS&amp;rdquo; (see
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a> ).&lt;/li>
&lt;li>&lt;code>mass&lt;/code> - The dumpmask for the mass of a given particles.
This has no effect if the code is not compiled with the flag
&amp;ldquo;-DPER_PARTICLE_CHARGE_MASS&amp;rdquo; (see
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a>). The synonym
&amp;ldquo;rest_mass&amp;rdquo; may also be used.&lt;/li>
&lt;li>&lt;code>particle_weight&lt;/code> - The dumpmask for the weighting
function which describes how many real particles each pseudoparticle
represents. Restart variable. The synonym &amp;ldquo;weight&amp;rdquo; may also be used.&lt;/li>
&lt;li>&lt;code>ejected_particles&lt;/code> - If requested then all the particles
which have left the simulation domain since the last output dump of this
type are included in the output. The list of ejected particles is
treated as if it were a separate species and the particle variables
which get written are requested using the other particle variable flags
(ie. &amp;ldquo;particle_grid&amp;rdquo;, etc). Once the data has been written, the ejected
particle lists are reset and will accumulate particles until the next
requested output dump.&lt;/li>
&lt;li>&lt;code>particle_energy&lt;/code> - The dumpmask for per-particle kinetic
energy.&lt;/li>
&lt;li>&lt;code>relativistic_mass&lt;/code> - The dumpmask for per-particle
relativistic mass (ie. not rest mass).&lt;/li>
&lt;li>&lt;code>gamma&lt;/code> - The dumpmask for per-particle relativistic gamma
(ie. $[1-(v/c)^2]^{-1/2}$).&lt;/li>
&lt;li>&lt;code>optical_depth&lt;/code> - The dumpmask for per-particle optical
depth. Restart variable. This option is only supplied for debugging
purposes and should not be required by most users.&lt;/li>
&lt;li>&lt;code>trident_optical_depth&lt;/code> - The dumpmask for per-particle
optical depth used by the Trident model. Restart variable. This option
is only supplied for debugging purposes and should not be required by
most users.&lt;/li>
&lt;li>&lt;code>qed_energy&lt;/code> - The dumpmask for per-particle QED-related
particle energy. Restart variable. This option is only supplied for
debugging purposes and should not be required by most users.&lt;/li>
&lt;li>&lt;code>work_{x,y,z}&lt;/code> - The dumpmask for the work exerted by the fields on each particle
during the last time step. The work is divided into its three spatial
components. The output is in numbers of $mc^2$ corresponding to the
particle&amp;rsquo;s $\gamma$-factor. Requires compiler flag
&amp;ldquo;WORK_DONE_INTEGRATED&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>work_{x,y,z}_total&lt;/code> - Same as above, but the work is integrated over the entire simulation
duration. The sum of all three components equals the particle&amp;rsquo;s
$\gamma$-factor. Requires compiler flag &amp;ldquo;WORK_DONE_INTEGRATED&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>id&lt;/code> - Global particle ID. See below for details.
Particle IDs are useful if you want to track the progress of each
particle throughout the simulation. Since they increase the size of each
particle data structure, they are disabled by default and must be
enabled using a compiler flag. The &amp;ldquo;PARTICLE_ID&amp;rdquo; flag will use an
8-byte integer to represent the ID and &amp;ldquo;PARTICLE_ID4&amp;rdquo; uses a 4-byte
integer. They are written to file using the &amp;ldquo;id&amp;rdquo; flag.&lt;/li>
&lt;/ul>
&lt;p>Note: In the current implementation, the particle IDs are passed between
processors and written to file using REAL numbers. This means that in
double precision the maximum particle ID is $2^{53} \sim 10^{16}$. This
should be ample for the foreseeable future. However, if the code is
compiled for single precision then the maximum ID is
$2^{24} = 16777216$. Probably not big enough.&lt;/p>
&lt;h1 id="grid_variables">Grid Variables&lt;/h1>
&lt;p>The next set of parameters specify properties which are defined on a
regular cartesian mesh. All entries have a default dumpmask of &amp;ldquo;never&amp;rdquo;.&lt;/p>
&lt;ul>
&lt;li>&lt;code>grid&lt;/code> - The dumpmask for the Cartesian grid which defines
the locations of the grid variables. No grid variables can be plotted in
VisIt unless this variable is output. If any grid variables are written
then the &amp;ldquo;grid&amp;rdquo; is automatically written unless &amp;ldquo;grid = never&amp;rdquo; is
specified. The synonym &amp;ldquo;field_grid&amp;rdquo; may also be used.&lt;/li>
&lt;li>&lt;code>ex,ey,ez&lt;/code> - The electric field vectors pointing in all
three directions. Restart variables.&lt;/li>
&lt;li>&lt;code>bx,by,bz&lt;/code> - The magnetic field vectors pointing in all
three directions. Restart variables. In 1D bx is a trivial variable
because of the Solenoidal condition. It is included simply for symmetry
with higher dimension codes.&lt;/li>
&lt;li>&lt;code>jx,jy,jz&lt;/code> - The current densities pointing in all three
directions. Restart variables. Can have species dumpmask.&lt;/li>
&lt;/ul>
&lt;h1 id="derived_variables">Derived Variables&lt;/h1>
&lt;p>The final set of parameters specify properties which are not variables
used in the code but are derived from them. The first six variables are
derived by summing properties of all the particles in each grid cell.
The resulting quantities are defined on the regular cartesian mesh used
for grid variables. All entries have a default dumpmask of &amp;ldquo;never&amp;rdquo;.&lt;/p>
&lt;ul>
&lt;li>&lt;code>ekbar&lt;/code> - Mean kinetic energy on grid in $J$. Can have
species dumpmask.&lt;/li>
&lt;li>&lt;code>ekflux&lt;/code> - Mean kinetic energy flux in each direction on
the grid in $W/m^2$. Can have species dumpmask.&lt;/li>
&lt;li>&lt;code>mass_density&lt;/code> - Mass density on grid in $kg/m^3$. Can
have species dumpmask.&lt;/li>
&lt;li>&lt;code>charge_density&lt;/code> - Charge density on grid in $C/m^3$. Can
have species dumpmask.&lt;/li>
&lt;li>&lt;code>number_density&lt;/code> - Number density on grid in $m^{-3}$. Can
have species dumpmask.&lt;/li>
&lt;li>&lt;code>particles per cell&lt;/code> - Number of particles per cell. Can
have species dumpmask. The synonym &amp;ldquo;ppc&amp;rdquo; may also be used.&lt;/li>
&lt;li>&lt;code>average weight&lt;/code> - Average of weight of the particles in
each cell. Can have species dumpmask.&lt;/li>
&lt;li>&lt;code>average_p{x,y,z}&lt;/code> - Average momentum in each direction of the particles in each cell. Can have species dumpmask.&lt;/li>
&lt;li>&lt;code>temperature&lt;/code> - Isotropic temperature on grid in $K$.
Calculated from standard deviation of particle momenta, so in general
matches mean kinetic energy only for isotropic plasma with no net drift.
The synonym &amp;ldquo;temp&amp;rdquo; may also be used. Can have species dump mask.&lt;/li>
&lt;li>&lt;code>temperature_{x,y,z}&lt;/code> - The temperature in each of the {x,y,z} directions, respectively, in
$K$. The synonyms &amp;ldquo;temp_{x,y,z}&amp;rdquo; and &amp;ldquo;t{x,y,z}&amp;rdquo; may also be used.
Can have species dumpmask.&lt;/li>
&lt;li>&lt;code>poynt_flux&lt;/code> - Poynting flux in each direction in $W/m^2$.&lt;/li>
&lt;li>&lt;code>coulomb_logarithm&lt;/code> - An estimate for the averaged Coulomb logarithm in each cell between
the first listed species, and all other species. If the “species” dumpmask is given, then this calculation
is repeated for the remaining particle species.&lt;/li>
&lt;/ul>
&lt;h1 id="other_variables">Other Variables&lt;/h1>
&lt;ul>
&lt;li>&lt;code>distribution_functions&lt;/code> - Dumpmask for outputting
distribution functions specified in the input deck. Each individual
distribution function can have its own dumpmask and these will be
applied after the value of &amp;ldquo;distribution_functions&amp;rdquo; has been
considered. For example, if the output block contains
&amp;ldquo;distribution_functions = full&amp;rdquo; and the dist_fn block (see
&lt;a href="/documentation/input_deck/input_deck_dist_fn">here&lt;/a>)
contains &amp;ldquo;dumpmask = always&amp;rdquo; then the distribution function will
only be output at full dumps.&lt;/li>
&lt;li>&lt;code>particle_probes&lt;/code> - Dumpmask for outputting particle
probes specified in the input deck. Each individual particle probe
can have its own dumpmask and these will be applied after the value
of &amp;ldquo;particle_probes&amp;rdquo; has been considered. For example, if the
output block contains &amp;ldquo;particle_probes = always&amp;rdquo; and the dist_fn
block contains &amp;ldquo;dumpmask = full&amp;rdquo; then the particle probe will only
be output at full dumps.&lt;/li>
&lt;li>&lt;code>absorption&lt;/code> - This is a two-valued output variable. It
accepts a dumpmask in the same manner as other output variables.
When selected, two numbers will be calculated and written to file:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>&amp;ldquo;Absorption/Laser_enTotal&amp;rdquo; - The total amount of energy injected
into the simulation by laser boundaries.&lt;/li>
&lt;li>&amp;ldquo;Absorption/Abs_frac&amp;rdquo; - The fraction of the total laser energy
being absorbed by the open boundaries.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>total_energy_sum&lt;/code> - This is also a two-valued output
variable. It accepts a dumpmask in the same manner as other output
variables. When selected, the following two numbers will be
calculated and written to file:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>&amp;ldquo;Total Particle Energy in Simulation (J)&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;Total Field Energy in Simulation (J)&amp;rdquo;&lt;/li>
&lt;/ol>
&lt;h1 id="data_averaging">Data Averaging&lt;/h1>
&lt;p>EPOCH can accumulate an average value for field variables to be written
to output dumps. These may be requested by using the &amp;ldquo;average&amp;rdquo; keyword
when specifying a dump variable. The non-averaged variable will still be
written to restart dumps where required for restarting the code but not
full or normal dumps. If you also want the non-averaged variable to be
written then you can add the &amp;ldquo;snapshot&amp;rdquo; option.&lt;/p>
&lt;p>The period of time over which averaging occurs can be specified using
the &amp;ldquo;dt_average&amp;rdquo; keyword. Alternatively, you may specify the number of
cycles over which to perform the averaging using the &amp;ldquo;nstep_average&amp;rdquo;
keyword. If both &amp;ldquo;dt_average&amp;rdquo; and &amp;ldquo;nstep_average&amp;rdquo; are specified then
the averaging will be performed over the longest of the two intervals.&lt;/p>
&lt;p>Note that previous versions of the code would alter the time step to
ensure that there were enough cycles between output dumps to satisfy the
&amp;ldquo;nstep_average&amp;rdquo; parameter. However, since it affects the accuracy of
the result, this is no longer the case and only a warning message is
issued.&lt;/p>
&lt;p>The following shows an example use of averaging in the output block.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
dt_snapshot = 1.0e-15
full_dump_every = 10
dt_average = 1.0e-17
charge_density = always + average + snapshot
mass_density = full + average + snapshot
ekbar = full + average
end:output
&lt;/code>&lt;/pre>
&lt;p>With this configuration, &amp;ldquo;charge_density&amp;rdquo; will be written in both
normal and averaged form at normal, full and restart dumps.
&amp;ldquo;mass_density&amp;rdquo; will be written in both forms at full dumps. Only the
average value of &amp;ldquo;ekbar&amp;rdquo; will be written at full dumps.&lt;/p>
&lt;p>Only field and derived variables can be averaged currently in EPOCH.
Particle properties, distribution functions and particle probes cannot
currently be averaged.&lt;/p>
&lt;h1 id="single_precision_output">Single-precision output&lt;/h1>
&lt;p>By default, EPOCH is compiled and run using double precision arithmetic.
This is the only method which has been fully tested and the method that
we recommend to other users of the code. However, this also means that
data files can get very large.&lt;/p>
&lt;p>To avoid this problem, it is possible to run the code in double
precision but convert the data to single precision when writing to disk.
This is done by adding the &amp;ldquo;single&amp;rdquo; field the the dumpmask of an output
variable. It can be specified on a per-variable basis.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
dt_snapshot = 8 * femto
grid = always
ex = always
ey = always + single
end:output
&lt;/code>&lt;/pre>
&lt;p>In this example, the grid variable &amp;ldquo;ex&amp;rdquo; will be written as a double
precision array and &amp;ldquo;ey&amp;rdquo; will be converted to single precision.&lt;/p>
&lt;p>Dumping variable averages adds an extra field variable for each average
requested. These take up memory during runtime but do not influence the
simulation behaviour in any way. For this reason, if the average is to
be written out in single precision then it may as well be stored in a
single precision variable. This behaviour can be requested using the
&amp;ldquo;average_single&amp;rdquo; dumpmask flag.&lt;/p>
&lt;h1 id="multiple_output_blocks">Multiple output blocks&lt;/h1>
&lt;p>In more recent versions of EPOCH, it is now possible to have multiple
&amp;ldquo;output&amp;rdquo; blocks in the input deck, each with their own &amp;ldquo;dt_snapshot&amp;rdquo; or
&amp;ldquo;nstep_snapshot&amp;rdquo; and their own set of output variables.&lt;/p>
&lt;p>The syntax remains the same as the original &amp;ldquo;output&amp;rdquo; block syntax with
the addition of &amp;ldquo;name&amp;rdquo; and &amp;ldquo;restartable&amp;rdquo; fields.&lt;/p>
&lt;p>The &amp;ldquo;name&amp;rdquo; field specifies the file name to use for the output list.
Each time EPOCH generates an output dump, it writes an entry into the
file &amp;ldquo;&lt;code>&amp;lt;name&amp;gt;.visit&lt;/code>&amp;rdquo;. This can be used to find all the output dumps of
a specific output block. It is named with a &amp;ldquo;.visit&amp;rdquo; suffix to enable
its use as a file grouping list in the VisIt data analysis tool, but it
is just a plain text file so it can equally be used by any other
program.&lt;/p>
&lt;p>If two output blocks are written at the same time, the output will be
combined into a single file.&lt;/p>
&lt;p>The &amp;ldquo;restartable&amp;rdquo; field specifies that the output block should generate
output dumps containing all the information necessary to restart a
simulation.&lt;/p>
&lt;p>The following parameters are supported by the new style of output block
in addition to those for the traditional style:&lt;/p>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - Identifies the output block with a name which is
required when multiple output blocks are used.&lt;/li>
&lt;li>&lt;code>restartable&lt;/code> - Specifies whether or not the output for
this block is a restartable dump.&lt;/li>
&lt;li>&lt;code>dump_at_times&lt;/code> - Floating point parameter which
specifies a set of simulation times at which to write the current
output block. This can only be used with named output blocks. The
values are given as a comma separated list. eg. &amp;ldquo;dump_at_times =
0, 0.15, 1.1&amp;rdquo;. The name &amp;ldquo;times_dump&amp;rdquo; is accepted as a synonym. By
default the list is empty.&lt;/li>
&lt;li>&lt;code>dump_at_nsteps&lt;/code> - Integer parameter which specifies a
set of step numbers at which to write the current output block. This
can only be used with named output blocks. The values are given as a
comma separated list. eg. &amp;ldquo;dump_at_nsteps = 5, 11, 15&amp;rdquo;. The name
&amp;ldquo;nsteps_dump&amp;rdquo; is accepted as a synonym. By default the list is
empty.&lt;/li>
&lt;li>&lt;code>dump_at_walltimes&lt;/code> - Floating point parameter which specifies a set of elapsed walltimes
at which to write the current output block. This can only be used with
named output blocks. The values are given as a comma separated list. eg.
&amp;ldquo;dump_at_walltimes = 10, 100.1, 250.5&amp;rdquo;. These times are the total
elapsed time in seconds since the start of the simulation. Note that if
the simulation has been restarted then the total elapsed time will
include the accumulated walltime of all previous runs that were used to
produce the restart dump. The name &lt;strong>walltimes_dump&lt;/strong> is accepted as a
synonym. By default the list is empty.&lt;/li>
&lt;li>&lt;code>walltime_interval&lt;/code> - Floating point parameter which specifies the interval between output
dumps in elapsed walltime seconds. Setting zero or negative means that
the code will not output based on this condition. The default value is -1.0.&lt;/li>
&lt;li>&lt;code>file_prefix&lt;/code> - String parameter. It is sometimes useful
to distinguish between dumps generated by the different output blocks.
This parameter allows the user to supply a file prefix to be prepended
to all dumps generated by the current output block. See below for
further details. The default value is an empty string.&lt;/li>
&lt;li>&lt;code>rolling_restart&lt;/code> - Logical flag. If set to &amp;ldquo;T&amp;rdquo;, this sets
the parameters required for performing rolling restarts on the current
block. It is a shorthand for setting the following flags: &amp;ldquo;dump_cycle =
1&amp;rdquo;, &amp;ldquo;restartable = T&amp;rdquo; and &amp;ldquo;file_prefix = roll&amp;rdquo;. With rolling restarts
enabled the first file will be named &amp;ldquo;roll0000.sdf&amp;rdquo; and the second will
be &amp;ldquo;roll0001.sdf&amp;rdquo;. The third dump will again be named &amp;ldquo;roll0000.sdf&amp;rdquo;,
overwriting the first one. In this way, restart dumps can be generated
throughout the duration of the simulation whilst limiting the amount of
disk space used.&lt;/li>
&lt;/ul>
&lt;p>The following parameters cannot be used in conjunction with the new
style of output block:&lt;/p>
&lt;ul>
&lt;li>&lt;code>full_dump_every&lt;/code>&lt;/li>
&lt;li>&lt;code>restart_dump_every&lt;/code>&lt;/li>
&lt;li>&lt;code>force_first_to_be_restartable&lt;/code>&lt;/li>
&lt;li>&lt;code>force_last_to_be_restartable&lt;/code>&lt;/li>
&lt;li>&lt;code>use_offset_grid&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>The &amp;ldquo;file_prefix&amp;rdquo; parameter warrants some further discussion. This
parameter prepends the given prefix to all files generated by the output
block in which it is specified. For example, if &amp;ldquo;file_prefix = aa&amp;rdquo; is
set then files generated by the output block will be named &amp;ldquo;aa0000.sdf&amp;rdquo;,
etc. instead of just &amp;ldquo;0000.sdf&amp;rdquo;.&lt;/p>
&lt;p>This also allows different variables to different files at the same time
step. For example, here are two output blocks which do not use file
prefixes:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
name = o1
nstep_snapshot = 1
charge_density = always
end:output
begin:output
name = o2
dump_at_nsteps = 10
restartable = T
end:output
&lt;/code>&lt;/pre>
&lt;p>With this input deck, we want to have the &amp;ldquo;charge_density&amp;rdquo; derived
variable at every snapshot and then periodically write a restart dump.
The problem is that the dump file &amp;ldquo;0010.sdf&amp;rdquo; contains both the restart
information and the &amp;ldquo;charge_density&amp;rdquo; variable. At the end of the run we
can&amp;rsquo;t just delete the large restart dumps without losing the smaller
variables at that time step.&lt;/p>
&lt;p>With the new version we would add a prefix to one or both blocks:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
name = o1
file_prefix = small
nstep_snapshot = 1
charge_density = always
end:output
begin:output
name = o2
nstep_snapshot = 10
restartable = T
end:output
&lt;/code>&lt;/pre>
&lt;p>Now the &amp;ldquo;charge_density&amp;rdquo; will be written to &amp;ldquo;small0000.sdf&amp;rdquo;, etc. At
step 10, two files will be written: &amp;ldquo;small0010.sdf&amp;rdquo; containing just the
charge_density and &amp;ldquo;0000.sdf&amp;rdquo; containing all the restart variables.&lt;/p>
&lt;p>Note that some care must be taken, since if the same variable is in the
output block for multiple file prefixes then multiple copies will be
written to file. This obviously uses more disk space and is more time
consuming than necessary.&lt;/p>
&lt;p>It should also be noted that if multiple output blocks use the same file
stem then their output will be combined. eg:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
name = o1
file_prefix = a
dump_at_nsteps = 2,4
ex = always
end:output
begin:output
name = o2
file_prefix = a
dump_at_nsteps = 3,4
ey = always
end:output
begin:output
name = o3
file_prefix = b
dump_at_nsteps = 4
ez = always
end:output
&lt;/code>&lt;/pre>
&lt;p>In this example, at step 2 a0000.sdf contains ex, step 3 a0001.sdf
contains ey, step 4 a0002.sdf contains ex, ey and b0000.sdf contains ez.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Output_global block</title><link>/documentation/input_deck/input_deck_output_global.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_output_global.html</guid><description>&lt;p>This block contains parameters which should be applied to all output
blocks. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more
information on the input deck.&lt;/p>
&lt;p>With the introduction of multiple output blocks, there are now a few
parameters that only make sense to be applied globally across all output
blocks. To accommodate this, a new block named &amp;ldquo;output_global&amp;rdquo; has been
added. Most of the parameters accepted by this block have the same
meaning as those in the &amp;ldquo;output&amp;rdquo; block except that they are applied to
all &amp;ldquo;output&amp;rdquo; blocks.&lt;/p>
&lt;p>The parameters that can be specified in the &amp;ldquo;output_global&amp;rdquo; block are
as follows:&lt;/p>
&lt;ul>
&lt;li>&lt;code>force_first_to_be_restartable&lt;/code> - Logical flag which
determines whether the file written at time zero is a restart dump. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>force_last_to_be_restartable&lt;/code> - Force the code to
override other output settings and make the last output dump it writes
be a restart dump. Any internal condition which causes the code to
terminate will make the code write a restart dump, but code crashes or
scheduler terminations will not cause the code to write a restart dump.
&amp;ldquo;force_final_to_be_restartable&amp;rdquo; is accepted as a synonym. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump_first&lt;/code> - Logical flag which determines whether to
write an output file immediately after initialising the simulation. The
default is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump_last&lt;/code> - Logical flag which determines whether to
write an output file just before ending the simulation. The default is
&amp;ldquo;T&amp;rdquo; if an output block exists in the input deck and &amp;ldquo;F&amp;rdquo; otherwise.
&amp;ldquo;dump_final&amp;rdquo; is accepted as a synonym.&lt;/li>
&lt;li>&lt;code>time_start&lt;/code> - Floating point parameter which specifies
the simulation time at which to start considering output for all output
blocks. Note that if &amp;ldquo;dump_first&amp;rdquo; or &amp;ldquo;dump_last&amp;rdquo; are set to true for
any block then dumps will occur at the first or last timestep regardless
of the value of this parameter. This also applies to the three following
parameters. The default value is 0.&lt;/li>
&lt;li>&lt;code>time_stop&lt;/code> - Floating point parameter which specifies the
simulation time at which to stop considering output for all output
blocks. The default value is the largest possible float.&lt;/li>
&lt;li>&lt;code>nstep_start&lt;/code> - Integer parameter which specifies the step
number at which to start considering output for the block. The default
value is 0.&lt;/li>
&lt;li>&lt;code>nstep_stop&lt;/code> - Integer parameter which specifies the step
number at which to stop considering output for the block. The default
value is the largest possible integer.&lt;/li>
&lt;li>&lt;code>walltime_start&lt;/code> - Floating point parameter which specifies the elapsed walltime in
seconds at which to start considering output for all output blocks. Note
that if &lt;strong>dump_first&lt;/strong> or &lt;strong>dump_last&lt;/strong> are set to true for any blocks
then dumps will occur at the first or last timestep regardless of the
value of the &lt;strong>walltime_start&lt;/strong> parameter. The default value is 0.&lt;/li>
&lt;li>&lt;code>walltime_stop&lt;/code> - Floating point parameter which specifies the elapsed walltime in
seconds at which to stop considering output all output blocks. The
default value is the largest possible float.&lt;/li>
&lt;li>&lt;code>sdf_buffer_size&lt;/code> - Integer parameter. When writing
particle data to an SDF file, the data is first transferred into an
output buffer. The size of this buffer can have a big impact on the
overall speed of writing dump files. This parameter allows the size of
the buffer to be specified in bytes. The default value is 67108864 (64
MB).&lt;/li>
&lt;li>&lt;code>filesystem&lt;/code> - String parameter. Some filesystems can be
unreliable when performing parallel I/O. Often this is fixable by
prefixing the filename with &amp;lsquo;ufs&amp;rsquo; or &amp;lsquo;nfs&amp;rsquo;. This parameter supplies the
prefix to be used. The default value is an empty string.&lt;/li>
&lt;li>&lt;code>use_offset_grid&lt;/code> - When using moving windows some
visualisation programs (notably VisIt) show the motion of the window by
moving the visualisation window rather than by changing the x-axis.
Setting this option to &amp;ldquo;T&amp;rdquo; causes the code to write another grid which
always gives the offset relative to the left hand edge of the window
rather than the true origin. Performs no function when not using the
moving window. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code> dump_first_after_restart&lt;/code> - Logical flag to enable a
dump to occur immediately after restart. In the past, a &lt;code>dump_first&lt;/code>
flag in the output block would cause an output dump immediately after
restarting. Since this is rarely the desired behaviour, the flag is now
ignored when restarting. To force a dump to occur immediately after
restart, set &lt;code>dump_first_after_restart = T&lt;/code> in the output block. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Dist_fn block</title><link>/documentation/input_deck/input_deck_dist_fn.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_dist_fn.html</guid><description>&lt;p>This block contains information about distribution functions that should
be calculated for output. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>Sometimes it is useful to reconstruct part of the full phase space for
one or more particle species. This functionality is provided through a
&lt;em>dist_fn&lt;/em> block. The distribution function is integrated over all
dimensions which are not axes of the distribution function.&lt;/p>
&lt;p>Calculating distribution functions requires some degree of integration
of data leading to various possible ways of normalising the resulting
distribution function. In EPOCH, distribution functions are normalised
so that the value at every point of the distribution function is the
number of particles within that cell of the distribution function,
ignoring all phase space directions which are not considered as an axis
of the distribution function. Summing the distribution function should
give the total number of real particles (as opposed to computational
pseudoparticles) in the simulation.&lt;/p>
&lt;p>An example &lt;em>dist_fn&lt;/em> block is given below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:dist_fn
name = x_px
ndims = 2
dumpmask = always
direction1 = dir_x
direction2 = dir_px
# Range is ignored for spatial coordinates
range1 = (1, 1)
range2 = (-50.0e-20, 50.0e-20)
# Resolution is ignored for spatial coordinates
resolution1 = 1
resolution2 = 5000
restrict_py = (-3.0e-20, 3.0e-20)
include_species:Electron
include_species:Carbon
end:dist_fn
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - The name of the distribution function when it is
output. This name is appended with the name of each species for
which the data is output and so, for example, when applied to a
species named carbon the output is called &lt;em>x_px_Carbon&lt;/em>. The
Cartesian grid which describes the axes of the distribution function
would then be called &lt;em>grid_x_px_Carbon&lt;/em>.&lt;/li>
&lt;li>&lt;code>ndims&lt;/code> - The number of dimensions in this phase space
reconstruction. Due to difficulties in visualising data in more than
three dimensions, this is restricted to being 1, 2 or 3.&lt;/li>
&lt;li>&lt;code>dumpmask&lt;/code> - Determines which output dumps will include
this distribution function. The dumpmask has the same semantics as
those used by variables in the &amp;ldquo;output&amp;rdquo; block, described
&lt;a href="/documentation/input_deck/input_deck_output_block">here&lt;/a>. The dumpmask from
&amp;ldquo;distribution_functions&amp;rdquo; in the output block is applied first and
then this one is applied afterwards. For example, if the dist_fn
block contains &amp;ldquo;dumpmask = full&amp;rdquo; and the output block contains
&amp;ldquo;distribution_functions = always&amp;rdquo; then this distribution function
will be only be dumped at full dumps. The default dumpmask is
&amp;ldquo;always&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>direction**n**&lt;/code> - This is the phase space to sample
along axis . This can be any one of: dir_x, dir_y, dir_z,
dir_px, dir_py, dir_pz, dir_en, dir_gamma_m1, dir_xy_angle,
dir_yz_angle, dir_zx_angle with spatial codes only being
available in dimensionalities of the code which have that direction.
Therefore dir_z does not exist in EPOCH1D or EPOCH2D and dir_y
does not exist in EPOCH1D.&lt;/li>
&lt;/ul>
&lt;p>The flags &amp;ldquo;dir_xy_angle&amp;rdquo;, &amp;ldquo;dir_yz_angle&amp;rdquo; and &amp;ldquo;dir_zx_angle&amp;rdquo;
calculate the distribution of particle momentum directions in the X-Y,
Y-Z and Z-X planes. In general, &amp;ldquo;dir_ij_angle&amp;rdquo; collapses the particle
momentum into the $ij$ plane, and quotes the momentum angle with
respect to the positive $i$ unit vector. The angle is output in the
range of $\pi$ to $-\pi$. Angles towards $+j$ are positive, and vice-versa
for negative $j$.&lt;/p>
&lt;ul>
&lt;li>&lt;code>range**n**&lt;/code> - The range between which this axis should
run. This is in the form of (minimum, maximum). Any particle which
exceeds the range is ignored. For momentum directions this parameter is
specified in $kg\ ms^{-1}$. If the range of a momentum direction is set
so that the maximum and the minimum are equal then the code will
automatically set the range to exactly span the range of particle
momenta at the point of writing the dump.&lt;/li>
&lt;li>&lt;code>resolution**n**&lt;/code> - The number of gridpoints in a given
direction. This is ignored for spatial dimensions where the resolution
is always the same as the resolution of the underlying simulation.&lt;/li>
&lt;li>&lt;code>include_species&lt;/code> - Specifies a species which should be
included in the output. This is useful since it is rare that momentum
limits are appropriate for both electrons and ions, so usually for a
given dist_fn block only electrons or ions are considered. It is
possible to have two dist_fn blocks with the same name but different
ranges and different include_species settings produce the effect of a
single diagnostic for all species in the output file.&lt;/li>
&lt;li>&lt;code>output_deltaf&lt;/code> - If set to &amp;ldquo;T&amp;rdquo;, the particle weights used
in calculating the distribution function is adjusted by subtracting the
Delta-f distribution function for the particle species. The default
value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>restrict_{x,y,z,px,py,pz}&lt;/code> - Restrictions are specified
in the same way as ranges, but have a subtly different behaviour. Ranges
specify the range of a visible axis on the resulting distribution
function, whereas restrictions allow you to specify minimum and maximum
values for each spatial and momentum direction and use only particles
which fall within this range when calculating the distribution function.
Restrictions can be specified even for properties which are not being
used as axes. It is possible to set a restriction that is more
restrictive than the range applied. This is not trapped as an error and
such parts of the distribution function are guaranteed to be empty. The
available spatial restrictions depend on the dimensionality of the code.
Therefore, attempting to set restrict_z in EPOCH1D will produce a
warning.
At present, the code to calculate the distribution functions has one
limitation: it ignores particle shape functions when calculating
properties on the spatial axis, meaning that the result is less smooth
than normal properties from the code.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Probe block</title><link>/documentation/input_deck/input_deck_probe.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_probe.html</guid><description>&lt;p>This block contains information about particle probes used for output.
See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;p>Sometimes it is useful to consider all the properties of particle which
pass through a point/line/plane (depending on dimension) in the
simulation. To allow this, it is possible to specify one or more
&lt;em>&lt;code>Particle Probe&lt;/code>&lt;/em> blocks in the input deck. These record
copies of all particles which cross a point/line/plane in a given
direction which meet minimum and maximum kinetic energy criteria and
output the particle properties into the normal output files. Each output
file only contains properties for particles which have passed the probe
since the previous output, and not all particles which have passed the
probe since the start of the simulation.&lt;/p>
&lt;p>Particle
probes record the positions, momenta and weight of all particles passing
through the plane.
If the code is compiled with &lt;strong>&lt;code>-DPARTICLE_ID&lt;/code>&lt;/strong> or &lt;strong>&lt;code>-DPARTICLE_ID4&lt;/code>&lt;/strong>,
the code also outputs the ID of passing particles.
If the code is compiled with &lt;strong>&lt;code>-DPROBE_TIME&lt;/code>&lt;/strong>, the time at which the
particle touches the probe surface is also output.&lt;/p>
&lt;p>To use particle probes, the code must not have been
compiled with the &lt;strong>&lt;code>-DNO_PARTICLE_PROBES&lt;/code>&lt;/strong> compiler option. This is
a fairly heavyweight diagnostic since each particle position must be tested
from within the particle push. The code will run faster if it is not compiled
in.&lt;/p>
&lt;p>The probe is specified in terms of a point in the plane and the normal
vector to the plane which is to be monitored. Particles are only
recorded if they cross the plane in the direction given by the normal
vector. If you want to record particles travelling in both directions
then use two particle probes, one with an opposite signed normal vector
to the other.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:probe
name = electron_back_probe
point = (50.0e-6, -50.0e-6)
normal = (1.0, 0.0)
ek_min = 0.0
ek_max = -1.0
include_species : s1
dumpmask = always
end:probe
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - The name that the probe should have in output
dumps. Output variables are then named this as a prefix. For
example, the block shown above will result in the name
&lt;strong>electron_back_probe_px&lt;/strong> for the x momentum. The particle
positions would just be called &lt;strong>electron_back_probe&lt;/strong>.&lt;/li>
&lt;li>&lt;code>point&lt;/code> - An arbitrary point in the plane of the probe.&lt;/li>
&lt;li>&lt;code>normal&lt;/code> - A vector normal to the plane of the probe, in
the direction of crossings you wish to monitor.&lt;/li>
&lt;li>&lt;code>include_species&lt;/code> - The species to which this probe
should be applied. To probe several species, use several probe
blocks in the input deck. &amp;ldquo;probe_species&amp;rdquo; is accepted as a
synonym.&lt;/li>
&lt;li>&lt;code>ek_min&lt;/code> - The minimum kinetic energy of particles to
store information about. Set to 0 for no minimum kinetic energy.&lt;/li>
&lt;li>&lt;code>ek_max&lt;/code> - The maximum kinetic energy of particles to
store information about. Set to -1 for no maximum kinetic energy.&lt;/li>
&lt;li>&lt;code>dumpmask&lt;/code> - The dump code for this particle probe. This
is the same as that for the main output controls in &lt;strong>input.deck&lt;/strong>.
Note that the code has to store copies of particles which pass
through the probe until a dump occurs. This means that the code&amp;rsquo;s
memory requirements can increase drastically if this code only dumps
probe information infrequently. If this is set to &lt;strong>never&lt;/strong> then the
code effectively never uses the probe.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Collisions block</title><link>/documentation/input_deck/input_deck_collisions.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_collisions.html</guid><description>&lt;p>This block contains information about particle collisions. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;p>EPOCH has a particle collision routine with scattering algorithms based
on the model presented by Sentoku and Kemp&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> or the model presented by
Pérez et al &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>, which in turn was based on the work of Nanbu and
Yonemura&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>. This adds a new output block named &amp;ldquo;collisions&amp;rdquo;, and since version 4.19, there are two
possible collision modes: binary and background.
Binary collisions pair particles together, and apply scatter to both particles.
In the background mode, particle species are split into fast-background pairs, where
only particles in the fast species are scattered. Originally, EPOCH could only
run in the full binary-collisions mode, which accepts the following keys:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>use_nanbu&lt;/code> - This logical flag determines whether the scattering angle of
Pérez/Nanbu will be used. The default is &amp;ldquo;T&amp;rdquo;. If &amp;ldquo;F&amp;rdquo;, the
Sentoku-Kemp algorithm will be used.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>coulomb_log&lt;/code> - This may either be set to a real value,
specifying the Coulomb logarithm to use when scattering the
particles or to the special value &amp;ldquo;auto&amp;rdquo;. If &amp;ldquo;auto&amp;rdquo; is used then the
routine will calculate a value based on the local temperature and
density of the particle species being scattered, along with the two
particle charges. If omitted, the default value is &amp;ldquo;auto&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>collide&lt;/code> - This sets up a symmetric square matrix of
size $nspecies \times nspecies$ containing the collision frequency
factors to use between particle species. The element (s1,s2) gives
the frequency factor used when colliding species s1 with species s2.
If the factor is less than zero, no collisions are performed. If it
is equal to one, collisions are performed normally. For any value
between zero and one, the collisions are performed using a frequency
multiplied by the given factor.
If &amp;ldquo;collide&amp;rdquo; has a value of &amp;ldquo;all&amp;rdquo; then all elements of the matrix are
set to one. If it has a value of &amp;ldquo;none&amp;rdquo; then all elements are set to
minus one.
If the syntax &amp;ldquo;species1 species2 &lt;em>value&lt;/em>&amp;rdquo; is used, then the
(species1,species2) element of the matrix is set to the factor
&amp;ldquo;&lt;em>value&lt;/em>&amp;rdquo;. This may either be a real number, or the special value &amp;ldquo;on&amp;rdquo;
or &amp;ldquo;off&amp;rdquo;. &lt;em>value&lt;/em> may also be set to &amp;ldquo;background&amp;rdquo; to specify a fast-background pair (see below). The &amp;ldquo;collide&amp;rdquo; parameter may be used multiple times.
The default value is &amp;ldquo;all&amp;rdquo; (ie. all elements of the matrix are set to
one, modelling physical collisions).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>collisional_ionisation&lt;/code> - If this logical flag is set to
&amp;ldquo;T&amp;rdquo; then the collisional ionisation model is enabled. This process is
independent of &lt;em>field_ionisation&lt;/em> (see
&lt;a href="/documentation/input_deck/input_deck_species#ionisation">here&lt;/a>). However, in
order to set up &lt;em>collisional_ionisation&lt;/em> you must also specify
ionisation energies and electrons in a &lt;em>species&lt;/em> block (see
&lt;a href="/documentation/input_deck/input_deck_species#ionisation">here&lt;/a>). The default
value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>coll_n_step&lt;/code> - Number of time-steps, $n$, between collision calculations. This key speeds up the
collisions routine by reducing the number of collision calculations performed. On steps which apply
collisions, the calculation is performed using a time-step of $n$*dt, where dt is the simulation time-step.
The default is 1 (calculate collisions every step).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ci_n_step&lt;/code> - Only performs the collisional ionisation calculation once every $n$ steps, where $n$ is set by this parameter. This is done to speed up the code, and the default is 1 (every step). When this is greater than 1, the assumed time-step for the collisional ionisation calculation is $n$*dt. Note that an ion may only be ionised once per calculation, so if $n$ is too high, the number of ions will be underestimated.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>An example deck using full binary collisions could be set up as follows.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:collisions
use_collisions = T
use_nanbu = T
coulomb_log = auto
collide = all
collide = spec1 spec2 off
collide = spec2 spec3 0.5
coll_n_step = 10
end:collisions
&lt;/code>&lt;/pre>
&lt;p>With this block, collisions are turned on, the Nanbu-Pérez scattering
algorithm is used and the Coulomb logarithm is automatically calculated.
All values of the frequency array are set to one except (spec1,spec2) is
set to minus one (and also (spec2,spec1)) and (spec2,spec3) is set to
0.5. Note: only a frequency value of 1 provides a physical scatter.
Collisions are only calculated once every 10 steps, but using an
inferred time-step of 10*dt.&lt;/p>
&lt;h1 id="background-collisions">Background collisions&lt;/h1>
&lt;p>The background collisions mode offers a speed-up compared to the binary
method when applicable. This mode assumes the particles in one species are
considerably faster than the particles in a background species, so the
relative velocity between fast and background particles is roughly the
fast particle speed.
This eliminates the need to pair particles together in a local cell, as in
the binary-collision case. However, background particles will not
experience scatter in this mode. This mode was originally intended for
electron-ion collisions, where both species had temperatures on the order
of keV. An example of fast-background collisions is given below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:collisions
use_collisions = T
coulomb_log = 5
collide = none
collide = Electron Ion1 background
collide = Electron Ion2 background
collide = Electron Electron on
use_cold_correction = F
rel_cutoff = 0.01
back_update_dt = 5.0e-15
end:collisions
&lt;/code>&lt;/pre>
&lt;p>The above example deactivates all collisions, then sets up two fast-background pairs,
with the Electron providing the fast species in both pairs, and Ion1 and Ion2 taking
the background roles. Full binary collisions are used for Electron-Electron collisions,
as these do not satisfy the fast-background assumptions. Additional speed-up parameters are
used which only apply to background collisions. These are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>use_cold_correction&lt;/code> - The Nanbu-Pérez collisions model has a low
temperature correction factor, given in equation (20) of Pérez&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>.
In some cases, this only affects particles with energy
on the order of eV, and may be ignored in hot plasma. If &amp;ldquo;F&amp;rdquo;, this calculation is skipped. The
default is &amp;ldquo;T&amp;rdquo;, to perform the full calculation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>rel_cutoff&lt;/code> - Collisions are calculated in the centre-of-mass frame
between colliding fast and background particles. In practice, only the fast
particle momentum is transformed. This parameter takes a number between 0 and 1, and
if the fractional momentum change between frames is lower than this number, the
frame transform is skipped. The default is 0, so frame transforms are always considered.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>back_update_dt&lt;/code> - If the background species number density varies
slowly, we do not need to re-calculate each step. This parameter specifies the
time-step of recalculation for the background number density, and also the
Coulomb logarithm if &lt;code>coulomb_log&lt;/code> is set to auto. The default is 0,
so background variables are re-calculated each step.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Y. Sentoku and A. J. Kemp, &amp;ldquo;Numerical methods for particle
simulations at extreme densities and temperatures: Weighted
particles, relativistic collisions and reduced currents,&amp;rdquo; J. Comput.
Phys., 2008.
&lt;a href="http://www.sciencedirect.com/science/article/pii/S0021999108001988" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>F. Pérez et al, &amp;ldquo;Improved modeling of relativistic collisions and
collisional ionization in particle-in-cell codes ,&amp;rdquo; Physics of
Plasmas, 2012.
&lt;a href="https://doi.org/10.1063/1.4742167" target="_blank" rel="noopener">2&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>K. Nanbu and S. Yonemura, &amp;ldquo;Weighted Particles in Coulomb Collision
Simulations Based on the Theory of a Cumulative Scattering Angle,&amp;rdquo;
J. Comput. Phys., 1998.
&lt;a href="https://doi.org/10.1006/jcph.1998.6049" target="_blank" rel="noopener">3&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>QED block</title><link>/documentation/input_deck/input_deck_qed.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_qed.html</guid><description>&lt;p>This block contains information about QED pair production. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;p>EPOCH can model QED pair production, synchrotron emission and radiation
reaction as described in Duclous et al&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> and Ridgers et al. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> It is
enabled using the compiler flag &lt;strong>&lt;code>-DPHOTONS&lt;/code>&lt;/strong>. Additionally, the
Trident process is enabled using &lt;strong>&lt;code>-DTRIDENT_PHOTONS&lt;/code>&lt;/strong>.&lt;/p>
&lt;p>A new input deck block named &amp;ldquo;qed&amp;rdquo; has been added which accepts the
following parameters:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>use_qed&lt;/code> - Logical flag which turns QED on or off. The
default is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>qed_start_time&lt;/code> - Floating point value specifying the
time after which QED effects should be turned on. The default is 0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>produce_photons&lt;/code> - Logical flag which specifies whether
to track the photons generated by synchrotron emission. If this is &amp;ldquo;F&amp;rdquo;
then the radiation reaction force is calculated but the properties of
the emitted photons are not tracked. The default is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>photon_energy_min&lt;/code> - Minimum energy of produced photons.
Radiation reaction is calculated for photons of all energies, but
photons with energy below this cutoff are not tracked. The default is 0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>photon_dynamics&lt;/code> - Logical flag which specifies whether
to push photons. If &amp;ldquo;F&amp;rdquo; then photons are generated, but their motion
through the domain is not simulated and they stay where they were
generated. The default is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>produce_pairs&lt;/code> - Logical flag which determines whether or
not to simulate the process of pair generation from gamma ray photons.
Both produce_photons and photon_dynamics must be &amp;ldquo;T&amp;rdquo; for this to work.
The default is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>qed_table_location&lt;/code> - EPOCH&amp;rsquo;s QED routines use lookup
tables to calculate gamma ray emission and pair production. If you want
to use tables in a different location from the default, specify the new
location using this parameter. The default is
&amp;ldquo;src/physics_packages/TABLES&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_radiation_reaction&lt;/code> - Logical flag which determines
whether or not to calculate the radiation reaction force. If set to &amp;ldquo;F&amp;rdquo;
then the force is not calculated. This should nearly always be enabled
when using the QED model. It is only provided for testing purposes. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>QED also requires that the code now know which species are electrons,
positrons and photons. The species type is specified using a single
&amp;ldquo;identify&amp;rdquo; tag in a species block. To specify an electron the block in
the deck would look like&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = electron
frac = 0.5
number_density = 7.7e29
identify:electron
end:species
&lt;/code>&lt;/pre>
&lt;p>Once the identity of a species is set then the code automatically
assigns mass and charge states for the species. Possible identities
are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>electron&lt;/code> - A normal electron species. All species of
electrons in the simulation must be identified in this way or they will
not generate photons.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>positron&lt;/code> - A normal positron species. All species of
positron in the simulation must be identified in this way or they will
not generate photons.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>photon&lt;/code> - A normal photon species. One species of this
type is needed for photon production to work. If multiple species are
present then generated photons will appear in the first species of this
type.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>bw_electron&lt;/code> - The electron species for pair production
by the Breit-Wheeler process. If a species of this type exists then
electrons from the pair production module will be created in this
species. If no species of this type is specified then pair electrons
will be generated in the first electron species.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>bw_positron&lt;/code> - As above but for positrons.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>trident_electron&lt;/code> - The electron species for pair
production by the Trident process. If a species of this type exists then
electrons from the pair production module will be created in this
species. If no species of this type is specified then pair electrons
will be generated in the first electron species.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>trident_positron&lt;/code> - As above but for positrons.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>proton&lt;/code> - A normal proton species. This is for convenience
only and is not required by the pair production routines.
A species should be identified only once, so a &amp;ldquo;bw_electron&amp;rdquo; species
does not need to also be identified as an &amp;ldquo;electron&amp;rdquo; species. If the
code is running with &amp;ldquo;produce_photons=T&amp;rdquo; then a photon species must be
created by the user and identified. If the code is running with
&amp;ldquo;produce_pairs=T&amp;rdquo; then the code must specify at least one electron (or
bw_electron) species and one positron (or bw_positron) species. These
species will usually be defined with zero particles from the start of
the simulation and will accumulate particles as the simulation
progresses. The code will fail to run if the needed species are not
specified.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>brem_photon&lt;/code> - A bremsstrahlung photon species. This is used by the bremsstrahlung radiation model. See the
&lt;a href="/documentation/input_deck/input_deck_bremsstrahlung">bremsstrahlung&lt;/a> page.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>bh_electron&lt;/code> - An electron produced in a Bethe-Heitler pair. See the
&lt;a href="/documentation/input_deck/input_deck_bremsstrahlung">bremsstrahlung&lt;/a> page for more details.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>bh_positron&lt;/code> - A positron produced in a Bethe-Heitler pair.
See the
&lt;a href="/documentation/input_deck/input_deck_bremsstrahlung">bremsstrahlung&lt;/a> page for more details.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The basic input deck has now been considered fully but it is possible
for an end user to add new blocks to the input deck As a result, a
version of the code which you have obtained from a source other than the
GitHub server may include other input deck blocks. These should
be described in additional documentation provided with the version of
the code that you have.&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>R. Duclous, J. G. Kirk, and A. R. Bell, &amp;ldquo;Monte carlo calculations
of pair production in high-intensity laserplasma interactions,&amp;rdquo;
Plasma Phys. Contr. F., vol. 53, no. 1, p. 015009,
2011
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/53/1/015009" target="_blank" rel="noopener">1&lt;/a>.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>C. P. Ridgers, J. G. Kirk, R. Duclous, T. G. Blackburn, C. S.
Brady, K. Bennett, T. D. Arber, A. R. Bell, &amp;ldquo;Modelling gamma-ray
photon emission and pair production in high-intensity laser&amp;ndash;matter
interactions,&amp;rdquo; J. Comp. Phys., vol. 260, p. 273-285,
2014
&lt;a href="https://doi.org/10.1016/j.jcp.2013.12.007" target="_blank" rel="noopener">2&lt;/a>.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Subset block</title><link>/documentation/input_deck/input_deck_subset.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_subset.html</guid><description>&lt;p>This block contains configuration for filters which can be used to
modify the data to be output. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>It is possible to restrict the number of particles written to file
according to various criteria. For example, you can now output the
momentum of all particles which have a gamma lower than 1.8 or the
positions of a randomly chosen subset of a given species.&lt;/p>
&lt;p>A new input deck block named &amp;ldquo;subset&amp;rdquo; is defined which accepts the
following parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - The name given to this subset. This is used to
identify the subset in the output block and is also used when labelling
the data in the SDF files.&lt;/li>
&lt;li>&lt;code>include_species&lt;/code> - Add the given particle species to the
set of particles that this subset applies to. By default, no particle
species are included.&lt;/li>
&lt;li>&lt;code>dumpmask&lt;/code> - The dumpmask to use when considering this
subset in an output block. This takes the same form as the output block
dumpmask. The default value is &amp;ldquo;always&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>random_fraction&lt;/code> - Select a random percentage of the
particle species. This is a real value between zero and one. If 0 is
specified, no particles are selected. If 1 is specified, all the
particles are selected. If 0.2 is specified, 20% of the particles are
selected.&lt;/li>
&lt;li>&lt;code>{px,py,pz,weight,charge,mass,gamma}_min&lt;/code> - Select only
the particles with momentum, weight, charge, mass or gamma which is
greater than the given value.&lt;/li>
&lt;li>&lt;code>{px,py,pz,weight,charge,mass,gamma}_max&lt;/code> - Select only
the particles with momentum, weight, charge, mass or gamma which is less
than the given value.&lt;/li>
&lt;li>&lt;code>{x,y,z}_min&lt;/code> - Select only the particles whose position
lies above the given value.&lt;/li>
&lt;li>&lt;code>{x,y,z}_max&lt;/code> - Select only the particles whose position
lies below the given value.&lt;/li>
&lt;li>&lt;code>id_min,max&lt;/code> - Select only the particles whose &amp;ldquo;id&amp;rdquo; is
greater than or less than the given values. The &amp;ldquo;id&amp;rdquo; field is explained
below.&lt;/li>
&lt;li>&lt;code>skip,skip_{x,y,z}&lt;/code> - Integer parameter for subsampling
output. If set to a positive integer then all grid-based variables using
the subset restriction will be reduced when being written to file. This
is achieved by skipping by the specified number of cells in each of the
specified directions. The &amp;ldquo;skip&amp;rdquo; parameter provides a quick method for
setting the same number of cells to skip in all directions. This
currently only applies to grid-based variables and is ignored for data
averages. The default value is &amp;ldquo;0&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;p>Once a subset has been defined, the subset name can then be used in
place of (or in addition to) the dumpmask in an &amp;ldquo;output&amp;rdquo; block (see also
&lt;a href="/documentation/input_deck/input_deck_output_block#dumpmask">here&lt;/a>). For example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:subset
name = background
random_fraction = 0.1
include_species:electron
include_species:proton
end:subset
begin:subset
name = high_gamma
gamma_min = 1.3
include_species:electron
end:subset
begin:output
particles = background + high_gamma + always
px = background + high_gamma
py = background
pz = always
end:output
&lt;/code>&lt;/pre>
&lt;p>In this example, three &amp;ldquo;px&amp;rdquo; blocks will be written:
&amp;ldquo;Particles/background/electron/Px&amp;rdquo;, &amp;ldquo;Particles/background/proton/Px&amp;rdquo; and
&amp;ldquo;Particles/high_gamma/electron/Px&amp;rdquo;. The &amp;ldquo;background&amp;rdquo; blocks will
contain 10% of the each species, randomly selected. The &amp;ldquo;high_gamma&amp;rdquo;
block will contain all the electrons with a gamma greater than 1.3.&lt;/p>
&lt;p>There will also be &amp;ldquo;Particles/background/electron/Py&amp;rdquo; and
&amp;ldquo;Particles/background/proton/Py&amp;rdquo; block containing y-momentum for the
same 10% random subset of particles. Finally, the
&amp;ldquo;Particles/All/electron/Pz&amp;rdquo; and &amp;ldquo;Particles/All/proton/Pz&amp;rdquo; will contain
the z-momentum for all particles.&lt;/p>
&lt;p>The final selection criteria given in the list above is &amp;ldquo;id_min&amp;rdquo; and
&amp;ldquo;id_max&amp;rdquo;. As of EPOCH version 4.0, the code can now assign a unique ID
field to every particle in the simulation. This can be useful for
tracking specific particles as they move through a simulation. As this
field adds extra memory requirements to the particles, it is disabled by
default and must be compiled in using the &lt;strong>&lt;code>-DPARTICLE_ID&lt;/code>&lt;/strong> compiler
flag.&lt;/p>
&lt;p>Particle IDs can be written to file using the &amp;ldquo;id&amp;rdquo; variable name in the
&lt;a href="/documentation/input_deck/input_deck_output_block">&amp;ldquo;output&amp;rdquo;&lt;/a> block. Eg.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
particles = always
id = always
end:output
&lt;/code>&lt;/pre>
&lt;h3 id="subsets_of_fields">Subsets of fields&lt;/h3>
&lt;p>Subset blocks can be applied to per-species variables such as current
and temperature. Only particles within the given momentum ranges and of
the selected species are included in the calculations. In addition,
subset blocks can now be applied to field or grid variables. This allows
you to output spatial sections using the &lt;code>{x,y,z}_max,min&lt;/code>
restrictions. The output data will be trimmed to the selected ranges and
a corresponding restricted grid included in the output. Note that
specifying an empty range will lead to output of the entire domain. For
example, the following snippet will output an ex_c_centre variable
restricted to the centre 1/3rd of the domain with a corresponding grid
grid_centre:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:subset
name = centre
x_min = x_min + (x_max - x_min) / 3.0
x_max = x_min + 2.0 * (x_max - x_min) / 3.0
end:subset
begin:output
...
ex = always + centre
end:output
&lt;/code>&lt;/pre>
&lt;h3 id="persistent_subsets">Persistent subsets&lt;/h3>
&lt;p>Persistent subsets are subsets that capture a set of particles once,
given a specified set of parameters, and then track those particles
permanently. Persistent subsets use the same blocks as normal subsets
and take the same parameters as normal subsets (except the skip
parameters which only apply to fields). Subsets are marked as persistent
by setting either&lt;/p>
&lt;ul>
&lt;li>&lt;code>persist_start_time&lt;/code> - Time at which to record the list
of particles to be tracked. Throughout the rest of the simulation
this recorded list will be used whenever requesting output for this
subset. &amp;ldquo;persist_after_time&amp;rdquo; is accepted as an alias. Set to 0
to record from the start of the simulation.&lt;/li>
&lt;li>&lt;code>persist_start_step&lt;/code> - Similar to persist_start_time
except this specifies a simulation step number to use instead of
time. &amp;ldquo;persist_after_step&amp;rdquo; is accepted as an alias.&lt;/li>
&lt;/ul>
&lt;p>If the input deck is edited on restart to add a new persistent subset
then it must be added &lt;strong>after&lt;/strong> existing persistent subsets or problems
may occur on restart.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Constant block</title><link>/documentation/input_deck/input_deck_constant.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_constant.html</guid><description>&lt;p>This block contains information about user defined constants and
expressions. These are designed to simplify the initial condition setup.
See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;p>The &lt;em>constant&lt;/em> block type helps to make the input deck more flexible and
maintainable. It allows you to define constants and maths parser
expressions (see
&lt;a href="/documentation/code_details/maths_parser">EPOCH maths parser&lt;/a>)
which can be used by name later in the deck.
Constants are simply maths parser expressions which are assigned to a
name as shown above. When the name is used on the right hand side of a
deck expression it is replaced by the expression it was assigned with.
This expression may be a simple numerical constant, a mathematical
expression or a function. Constants may contain spatially varying
information without having to pre-calculate them at every location in
the domain. To those familiar with FORTRAN codes which use statement
functions, parameters appearing in the &amp;ldquo;constant&amp;rdquo; block are fairly
similar.
If a constant name is reused in a constant block then the old constant
is deleted and replaced with the new one. This happens without warning.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
lambda = 1.06 * micron
omega = 2.0 * pi * c / lambda
den_crit = critical(omega)
scale = 3.5 * micron
den_max = 5.0 * den_crit
thick = 300e-9
pplength = 6000e-9
widscale = 5.0e-6
t_wid = (10.0e-6) / c
amax = 1.0
wy = 1e-6
y = 0.0
slope = exp(-2.0 * (y/wy)^2)
blob = gauss(sqrt(x^2 + y^2), 0.0, 1.0e-6)
end:constant
&lt;/code>&lt;/pre>
&lt;p>Using constants can be very helpful when dealing with long, complicated
expressions since they allow the expression to be broken down into much
simpler parts. They can also be used to get around the FORTRAN string
length limitation built into many compilers which prevents deck lines
being longer then 512 characters long. As a general rule, it is a good
idea to break down complicated expressions using constants or by other
means, in order to make the deck look more readable.
Constants are persistent for the entire runtime of the code, allowing
them to be used when specifying time profiles for lasers, and also
allowing developers to use maths parser expressions for other internal
parts of the code where needed.
In the above example, several pre-defined constants have been used (&lt;em>pi&lt;/em>
and &lt;em>c&lt;/em>) and also several functions (&lt;em>critical&lt;/em>, &lt;em>exp&lt;/em>, &lt;em>gauss&lt;/em> and
&lt;em>sqrt&lt;/em>). These are described
&lt;a href="/documentation/code_details/maths_parser#constants">here&lt;/a> and
&lt;a href="/documentation/code_details/maths_parser#functions">here&lt;/a>.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Injector block</title><link>/documentation/input_deck/input_deck_injector.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_injector.html</guid><description>&lt;p>The &lt;em>injector&lt;/em> block specifies a particle source to be introduced
through a simulation boundary. Each injector block specifies a source of
a single species of particle defined by a density, centre of mass drift
momentum, temperature and number of simulation particles per cell. Injectors may also be set-up to
inject particles with properties and at times read from files created by the user.
The
current version of the injectors is incompatible with the
&lt;strong>&lt;code>-DPER_SPECIES_WEIGHT&lt;/code>&lt;/strong> compiler flag, and attempting to use an injector
with a version of EPOCH compiled with this flag will fail.&lt;/p>
&lt;h1 id="concepts">Concepts&lt;/h1>
&lt;p>EPOCH can inject particles through any of the simulation boundaries.
This plasma is either a drifting Maxwellian corresponding to a
collisionally thermalized beam or a &amp;ldquo;flux Maxwellian&amp;rdquo; corresponding to
a Maxwellian source accelerated by an electrostatic accelerator. It can
have any temporal or transverse spatial profile of density, temperature
or drift that you wish to specify.&lt;/p>
&lt;p>EPOCH does not automatically make any assumption about the plasma that
you wish to inject and does not correct for currents injected into the
domain. Current due to an injected beam will be smoothly created as the
particles enter the domain. If you wish to inject a neutral beam, you
will have to use multiple injectors to inject electrons and ions so as
to produce a neutral beam. Great care must be taken when introducing
relativistic beams since the current due to a highly relativistic beam
will not be the current due to the centre of mass velocity since EPOCH
does not use the Maxwell-Jüttner distribution for loading particles.&lt;/p>
&lt;p>The user may over-ride this behaviour and inject particles with specific momenta, positions, weights
and ID values, at specific simulation times. These particle parameters are read from files, and syntax
for these is provided
&lt;a href="#inject-particles-from-file">here&lt;/a>.&lt;/p>
&lt;h1 id="boundary_conditions">Boundary conditions&lt;/h1>
&lt;p>The injectors only work properly with certain boundary conditions. For
most purposes the &amp;ldquo;open&amp;rdquo; boundary condition is the only one that makes
sense with injectors since particles are flowing freely through the
boundary. Remember that in any version of EPOCH that supports injectors
you can also use per species boundary conditions to allow you to have
different boundary conditions for injected and bulk particles.&lt;/p>
&lt;h1 id="moving_window">Moving window&lt;/h1>
&lt;p>Injectors and moving windows can be tricky to work with, so the default
behaviour of EPOCH is to stop all injectors when the window starts to
move. If you wish to override this behaviour then simply explicitly set
t_end in the injector block to a value after the window starts to move.
Setting&lt;/p>
&lt;pre>&lt;code class="language-perl"> t_end = t_end
&lt;/code>&lt;/pre>
&lt;p>will cause the injectors to continue running until the end of the
simulation even with the moving window. You must take great care when
specifying injectors for a moving window because you will likely get
gaps or bunches in particles injected through the x boundary and there
will probably be some shearing of particles introduced through y and z
boundaries. It is in general recommended that you specify a velocity
profile for the moving window that stops at times when particles are to
be injected and then starts again once the injection is complete.&lt;/p>
&lt;h1 id="keys">Keys&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;code>boundary&lt;/code> - specifies which boundary to attach the particle source
too. Same specification as the
&lt;a href="/documentation/input_deck/input_deck_laser">laser block&lt;/a>, so
permitted values are x_min, x_max, y_min, y_max, z_min and
z_max&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>species&lt;/code> - specifies which species should be injected through the
boundary. Just specify the name of the species required.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>t_start&lt;/code> - Time at which to start the injector&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>t_end&lt;/code> - Time at which to end the injector&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>npart_per_cell&lt;/code> - target pseudo-particle density for the injector.&lt;/p>
&lt;p>Average number of particles injected will be this value or slightly
higher if very few particles are specified&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>number_density&lt;/code> - Number density of the particle source in $m^{-3}$.
Can be space varying along the boundary to which the injector is
attached and time varying&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>number_density_min&lt;/code> - Minimum number density in $m^{-3}$ below
which pseudo particles are not loaded. Use if the density has a
profile to avoid injecting low weight particles in low density
regions&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>number_density_max&lt;/code> - Maximum particle number density in $m^{-3}$.
When the number density in a cell rises above &lt;em>number_density_max&lt;/em>
the injector clips the density to number_density_max allowing easy
implementation of exponential rises to plateaus for time-varying injectors.
Note that the number of particles per cell is kept fixed and the number
density adjustment is achieved by modifying the particle weight. This
flag has no effect for particles with per-species weighting. If the
flag has a negative value then no clipping is performed.
This is the default.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>temp_x&lt;/code> - Temperature in x direction (K)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>temp_y&lt;/code> - Temperature in y direction (K)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>temp_z&lt;/code> - Temperature in z direction (K)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>temp&lt;/code> - Sets an isotropic temperature distribution in Kelvin. If both temp
and a specific temp_x, temp_y, temp_z parameter is specified then the last
to appear in the deck has precedence. If neither are given then the
injector will have a default temperature of zero Kelvin.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>temp_{x,y,z}_ev, temp_ev&lt;/code> - These are the same as the temperature
parameters described above except the units are given in electronvolts
rather than Kelvin, i.e. using 1ev = 11604.5K .&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>drift_x&lt;/code> - Momentum drift in x direction in $kg.m/s$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>drift_y&lt;/code> - Momentum drift in y direction in $kg.m/s$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>drift_z&lt;/code> - Momentum drift in z direction in $kg.m/s$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>drift_{x,y,z}&lt;/code> - Specifies a momentum space offset in $kg m/s$ to the
distribution function for this injector. By default, the drift is zero.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_flux_maxwellian&lt;/code> - Logical flag to determine whether to use an
accelerated flux Maxwellian rather than a drifting Maxwellian. This
calculates the flux due to passing a Maxwellian source into an
electrostatic accelerator instead of a drifting Maxwellian. If your
particle source is a lab accelerator then you may want to set this to true.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="example_deck">Example Deck&lt;/h1>
&lt;pre>&lt;code class="language-perl">begin:injector
boundary = x_min
species = Electron
number_density = dens
temp_x = temp
drift_x = drift_p
npart_per_cell = 32
end:injector
&lt;/code>&lt;/pre>
&lt;h1 id="inject-particles-from-file">Inject particles from file&lt;/h1>
&lt;p>The plasma injectors may be over-written to allow the user to inject macro-particles
with specific momenta, positions and weight, at given simulation times on given boundaries.
Files containing injected particle properties must be formatted in a particular way.
Each variable type (position, momentum, weight, time) must be stored in a separate file.
Each line of a given file corresponds to a variable value for one particle, and particles must
be arranged in chronological order.&lt;/p>
&lt;p>For example, a user wants to inject 3 particles of weights 10, 20 and 30, at times 1.0e-15 s,
2.0e-15 s and 3.0e-15 s respectively, into a 1D simulation through the &lt;em>x_min&lt;/em> boundary.
The file containing injection time data (&lt;em>inject_t.txt&lt;/em>) would contain:&lt;/p>
&lt;pre>&lt;code class="language-perl">1.0e-15
2.0e-15
3.0e-15
&lt;/code>&lt;/pre>
&lt;p>and the weight data file (&lt;em>inject_w.txt&lt;/em>) would contain:&lt;/p>
&lt;pre>&lt;code class="language-perl">10
20
30
&lt;/code>&lt;/pre>
&lt;p>The user could create similar files to describe the $p_x$, $p_y$ and $p_z$
momentum components of each injected particle, where the first value in
each file would be assigned to the 1.0e-15 macro-particle. In higher
dimensions, injection position on the boundary must also be specified.
Particle ID may be given if &lt;strong>&lt;code>-DPARTICLE_ID&lt;/code>&lt;/strong> or &lt;strong>&lt;code>-DPARTICLE_ID4&lt;/code>&lt;/strong>
are specified.&lt;/p>
&lt;p>The user may have multiple file-injectors running simultaneously, by
defining multiple file-injector blocks. An example block is provided below
for a 2D simulation. In this example, all files are present in the same
directory as the input deck.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:injector
boundary = x_min
species = Electron
inject_from_file = T
y_data = &amp;quot;inject_y.txt&amp;quot;
px_data = &amp;quot;inject_px.txt&amp;quot;
py_data = &amp;quot;inject_py.txt&amp;quot;
w_data = &amp;quot;inject_w.txt&amp;quot;
t_data = &amp;quot;inject_t.txt&amp;quot;
end:injector
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>&lt;code>inject_from_file&lt;/code> - If &amp;ldquo;T&amp;rdquo;, the code will ignore the flux-Maxwellian keys,
and will instead inject particles based on the {&amp;hellip;}_data keys.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{x, y, z}_data&lt;/code> - Files containing the positions of injected particles.
These are not used in 1D simulations, but must be used in 2D and 3D. In this example,
no $x$ file is given, as all particles are injected through &lt;em>x_min&lt;/em>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{px, py, pz}_data&lt;/code> - Files containing the momenta of injected particles.
These are optional parameters - if a momentum component file is missing, this
component will be set to zero for all injected particles.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>w_data&lt;/code> - The file containing the weights of all injected particles. This
data is mandatory.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>t_data&lt;/code> - The file containing the times each particle passes the boundary.
Injected particles will be positioned outside the simulation window, such that
they pass the boundary at the time specified in this file. This data is mandatory.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>id_data&lt;/code> - The file containing the ID values assigned to each injected
particle. This is optional, and may only be used if the code is compiled with
either &lt;strong>&lt;code>-DPARTICLE_ID&lt;/code>&lt;/strong> or &lt;strong>&lt;code>-DPARTICLE_ID4&lt;/code>&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="warnings">Warnings&lt;/h1>
&lt;p>Currently injectors are a beta feature of EPOCH. We believe them to work
correctly, but unusual results must be considered suspect. If you get
unexpected results, please contact the EPOCH development team.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Particles_from_file block</title><link>/documentation/input_deck/input_deck_particle_file.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_particle_file.html</guid><description>&lt;p>This block contains information about the block used to load particles
from file. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more
information on the input deck.&lt;/p>
&lt;p>The particles_from_file block is similar in function to the fields
block, it allows the loading of custom particle data from raw binary
data files. An example usage of the block is shown below&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:particles_from_file
species = &amp;quot;electron&amp;quot;
# Load mandatory data for 3D simulation
x_data = &amp;quot;xdata.dat&amp;quot;
y_data = &amp;quot;ydata.dat&amp;quot;
z_data = &amp;quot;ydata.dat&amp;quot;
w_data = &amp;quot;ydata.dat&amp;quot;
# Load particle ids in 4 byte int format,
# ignoring first 8 bytes of file
#offset = 8
#id4_data = &amp;quot;iddata.dat&amp;quot;
end:particles_from_file
&lt;/code>&lt;/pre>
&lt;p>Specifying a particles_from_file block for a species causes EPOCH to
load the per-particle data from the specified files. Data files are
assumed to be in order such that the first variable in each file will be
attributed to one particle, the second variable in each file to a second
electron, and so on. A target species to load to, as well as particle
position and weight data (unless has been set) must be supplied. With
the exception of particle ID, any optional parameters which are left
unspecified will be initialised to zero.
If the code has been compiled with or then particle IDs may be loaded
from a raw binary file of integers of either size 4 or size 8 regardless
of the compile time flag choice. If no particle ID data is supplied, IDs
will be generated sequentially from 1.
All other data should be in the form of floating point numbers of the
same precision as in the core code.
A particles_from_file block accepts the following parameters:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>species&lt;/code> - Name of the species to which the particles will
be loaded. This is a mandatory parameter and the corresponding species
block must be defined.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{x,y,z}_data&lt;/code> - File containing particle position data in
$m$. This data must be supplied, up to the dimensionality of the
simulation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>w_data&lt;/code> - File containing pseudoparticle weight, this is
the number of real particles the pseudoparticle represents. This data
must be supplied.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{px,py,pz}_data&lt;/code> - File containing particle momentum
data in $kg,ms^{-1}$. The default value is zero.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>id{4,8}_data&lt;/code> - File containing particle IDs in either
4 or 8 byte unsigned integer representation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>offset&lt;/code> - File offset. Number of bytes at the head of
the file to be ignored, may be specified multiple times. see for
more details of behaviour.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Binary files</title><link>/documentation/input_deck/binary_files.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/binary_files.html</guid><description>&lt;p>There are several input deck blocks which can read conditions directly
from a user-specified file. These include the , and . In all such cases,
the files specified must be in a simple binary format, often referred to
as &amp;ldquo;raw&amp;rdquo; binary files.&lt;/p>
&lt;p>Binary files are machine readable, but not human readable. If you try
opening a binary file in a text editor then you will see
incomprehensible characters and some text editors might even crash. Most
languages can write binary files, see &amp;ldquo;writeu&amp;rdquo; (in IDL/GDL), &amp;ldquo;fwrite&amp;rdquo; in
MatLab, the &amp;ldquo;b&amp;rdquo; parameter to &amp;ldquo;open&amp;rdquo; in Python and &amp;ldquo;form=&amp;lsquo;UNFORMATTED&amp;rsquo; &amp;quot;
in Fortran, so please see the documentation for those languages. Note
that standard unformatted output in Fortran also writes some additional
hidden output to the file that alters the offset of the actual binary
array data within the file. It is therefore recommended that you always
use the &amp;ldquo;access=&amp;lsquo;STREAM&amp;rsquo; &amp;quot; modifier whenever writing such files from
Fortran programs.&lt;/p>
&lt;p>For illustration purposes, here is a simple example of writing a 2D
array to file using Fortran:&lt;/p>
&lt;pre>&lt;code class="language-fortran">PROGRAM output_array
INTEGER :: iu, istat
INTEGER, PARAMETER :: nx = 10, ny = 20
DOUBLE PRECISION :: array(nx,ny)
CHARACTER(LEN=*), PARAMETER :: filename = ’array.dat’
array = 2.0d0
OPEN(newunit=iu, file=filename, status=’NEW’, form=’UNFORMATTED’, &amp;amp;amp; access=’STREAM’, iostat=istat)
IF (istat == 0) THEN WRITE(iu) array CLOSE(iu, iostat=istat) ELSE PRINT*, ’ERROR: failed to open file ’, ’“’ // filename // ’”’, &amp;amp;amp; ’ for writing’ END IF
END PROGRAM output_array
&lt;/code>&lt;/pre>
&lt;p>In this example, there are 200 array elements written to file (10 *
20). Each element is a double-precision number which is 8 bytes.
Therefore, the total file size will be 1600 bytes. Note that for
Fortran, arrays are indexed using &amp;ldquo;column-major order&amp;rdquo;. This means that
in the file, the first array element &amp;ldquo;array(1,1)&amp;rdquo; will be followed by
&amp;ldquo;array(2,1)&amp;rdquo; and so on up to &amp;ldquo;array(10,1)&amp;rdquo;. After this, the second index
will be incremented and the array element &amp;ldquo;array(1,2)&amp;rdquo; will be output,
followed by &amp;ldquo;array(2,2)&amp;rdquo;, etc. In contrast, languages such as C and C++
use row-major order. For these languages the array output is transposed,
so the array elements are output in the order: &amp;ldquo;array[0][0],
array[0][1], .. array[0][19], array[1][0], ..&amp;rdquo;&lt;/p>
&lt;p>Simple binary files merely contain a long sequence of real numbers and
do not contain any information about the shape of the arrays that have
been written. This information must be supplied using the input deck.
These should correspond to the values of &amp;ldquo;nx&amp;rdquo;, &amp;ldquo;ny&amp;rdquo;, etc. For example,
to use the array generated by the Fortran code shown above, the input
deck must specify &amp;ldquo;nx = 10&amp;rdquo; and &amp;ldquo;ny = 20&amp;rdquo;.&lt;/p>
&lt;p>It is possible to write multiple arrays into the same binary file and
use the &amp;ldquo;offset&amp;rdquo; comand in the input deck to specify where the next
array in the file is to be located. This can be tricky to work with and
it is therefore recommended to write each separate array to its own
file.&lt;/p></description></item><item><title>EPOCH Makefile</title><link>/developer/makefile.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/makefile.html</guid><description>&lt;p>The makefile supplied with EPOCH is a standard GNU make makefile, which must
be user modified to allow a developer to add new files to the code. EPOCH&amp;rsquo;s
makefile is quite large, so an explanation of how to add new files and new
directories is given below.&lt;/p>
&lt;h2 id="adding-a-new-file-to-be-compiled-with-epoch">Adding a new file to be compiled with EPOCH&lt;/h2>
&lt;p>There are three things that must be done to cause EPOCH to compile a new
file and link it into the final code. Assume that you&amp;rsquo;re adding a file called
&amp;ldquo;newfile.F90&amp;rdquo;. First, find the line which sets the environment variable
&lt;code>SRCFILES&lt;/code> and add a new parameter which reads &amp;ldquo;newfile.F90&amp;rdquo;. This tells the
makefile to compile the final code using your new file, the
next thing to do is to add a line which tells the code about the dependencies
for your file. Lower down in the makefile, you&amp;rsquo;ll find a section with lines
which look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">balance.o: balance.F90 boundary.o mpi_subtype_control.o partlist.o
&lt;/code>&lt;/pre>
&lt;p>Add a new line for describing all the FILES (NOT modules) which are used by
your new file. If you USE shared_data, mpi_subtype_control and stack in
your file then the line would look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">newfile.o: newfile.F90 shared_data.o mpi_subtype_control.o stack.o
&lt;/code>&lt;/pre>
&lt;p>Note the structure of the line with ONLY the source file for the new file
specified, all other used files specify the intermediate .o files. The
remaining element of the makefile which needs to be modified is to add your
new file as a dependency to all the files which USE modules contained in your
new file. This is achieved very simply by adding &amp;ldquo;newfile.o&amp;rdquo; to the dependency
list for those files which USE your modules. For example if you&amp;rsquo;ve written new
boundary conditions and USE your modules in boundary.f90, you&amp;rsquo;d just change
the line for boundary.f90 from:&lt;/p>
&lt;pre>&lt;code class="language-perl">boundary.o: boundary.f90 deck_io_block.o particle_temperature.o partlist.o
&lt;/code>&lt;/pre>
&lt;p>to&lt;/p>
&lt;pre>&lt;code class="language-perl">boundary.o: boundary.f90 deck_io_block.o particle_temperature.o partlist.o \
newfile.o
&lt;/code>&lt;/pre>
&lt;p>Note that the backslash characters are line continuation marks in makefiles.&lt;/p>
&lt;h2 id="adding-new-directories-to-epochs-makefile">Adding new directories to EPOCH&amp;rsquo;s makefile&lt;/h2>
&lt;p>If you want to add an entire new directory to the EPOCH compile path then
you need to add it to the definition of the variable &lt;code>VPATH&lt;/code>.
Remember to use the variable &lt;code>$(SRCDIR)&lt;/code> rather than hard-coding
&lt;code>src&lt;/code> into the path.&lt;/p></description></item><item><title>Maths parser</title><link>/documentation/code_details/maths_parser.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/code_details/maths_parser.html</guid><description>&lt;p>A discussion of the input deck for EPOCH would not be complete without
consideration of the maths parser. The maths parser is the code which
reads the input decks. The parser makes it possible that any parameter
taking a numerical value (integer or real) can be input as a
mathematical expression rather than as a numerical constant. The maths
parser is fairly extensive and includes a range of mathematical
functions, physical and simulation constants and appropriately
prioritised mathematical operators.&lt;/p>
&lt;h3 id="constants">Constants&lt;/h3>
&lt;p>The maths parser in EPOCH has the following constants&lt;/p>
&lt;ul>
&lt;li>pi - The ratio of the circumference of a circle to its diameter.&lt;/li>
&lt;li>kb - Boltzmann&amp;rsquo;s constant.&lt;/li>
&lt;li>me - Mass of an electron.&lt;/li>
&lt;li>qe - Charge of an electron.&lt;/li>
&lt;li>c - Speed of light.&lt;/li>
&lt;li>epsilon0 - Permeability of free space.&lt;/li>
&lt;li>mu0 - Permittivity of free space.&lt;/li>
&lt;li>ev - Electronvolt.&lt;/li>
&lt;li>kev - Kilo-Electronvolt.&lt;/li>
&lt;li>mev - Mega-Electronvolt.&lt;/li>
&lt;li>micron - A convenience symbol for specifying wavelength in microns
rather than metres.&lt;/li>
&lt;li>milli - $10^{-3}$&lt;/li>
&lt;li>micro - $10^{-6}$&lt;/li>
&lt;li>nano - $10^{-9}$&lt;/li>
&lt;li>pico - $10^{-12}$&lt;/li>
&lt;li>femto - $10^{-15}$&lt;/li>
&lt;li>atto - $10^{-18}$&lt;/li>
&lt;li>cc - A convenience symbol for converting from cubic metres to cubic
centimetres (ie. $10^{-6}$)&lt;/li>
&lt;li>time - Initial simulation time.&lt;/li>
&lt;li>x,y,z - Grid coordinates in the x,y,z direction.&lt;/li>
&lt;li>ix,iy,iz - Grid index in the x,y,z direction.&lt;/li>
&lt;li>nx,ny,nz - Number of grid points in the x,y,z direction.&lt;/li>
&lt;li>dx,dy,dz - Grid spacing in the x,y,z direction.&lt;/li>
&lt;li>{x,y,z}_min - Grid coordinate of the minimum x,y,z boundary.&lt;/li>
&lt;li>{x,y,z}_max - Grid coordinate of the maximum x,y,z boundary.&lt;/li>
&lt;li>length_{x,y,z} - The length of the simulation box in the x,y,z
direction.&lt;/li>
&lt;li>nproc_{x,y,z} - The number of processes in the x,y,z directions.&lt;/li>
&lt;li>nsteps - The number of timesteps requested.&lt;/li>
&lt;li>t_end - The end time of the simulation.&lt;/li>
&lt;li>p{x,y,z} - Momentum in the x, y, z directions. Used in specifying
arbitrary distribution functions. EPOCH 4.15 or later required&lt;/li>
&lt;/ul>
&lt;p>It is also possible for an end user to specify custom constants both
within the code and from the input deck. These topics are covered later
in this subsection. An example of using a constant would be:
&lt;strong>length_x = pi&lt;/strong>&lt;/p>
&lt;h3 id="functions">Functions&lt;/h3>
&lt;p>The maths parser in EPOCH has the following functions&lt;/p>
&lt;ul>
&lt;li>abs(a) - Absolute value.&lt;/li>
&lt;li>floor(a) - Convert real to integer rounding down.&lt;/li>
&lt;li>ceil(a) - Convert real to integer rounding up.&lt;/li>
&lt;li>nint(a) - Convert real to integer rounding to nearest integer.&lt;/li>
&lt;li>sqrt(a) - Square root.&lt;/li>
&lt;li>sin(a) - Sine.&lt;/li>
&lt;li>cos(a) - Cosine.&lt;/li>
&lt;li>tan(a) - Tangent.&lt;/li>
&lt;li>asin(a) - Arcsine.&lt;/li>
&lt;li>acos(a) - Arccosine.&lt;/li>
&lt;li>atan(a) - Arctangent.&lt;/li>
&lt;li>atan2(Y,X) - Arctangent using the Fortran ATAN2 function. This computes the
principal value of the argument function of the complex number
$X + i Y$. This function can be used to transform from Cartesian into
polar coordinates and allows to determine the angle in the correct
quadrant.&lt;/li>
&lt;li>sinh(a) - Hyperbolic sine.&lt;/li>
&lt;li>cosh(a) - Hyperbolic cosine.&lt;/li>
&lt;li>tanh(a) - Hyperbolic tangent.&lt;/li>
&lt;li>exp(a) - Exponential.&lt;/li>
&lt;li>loge(a) - Natural logarithm.&lt;/li>
&lt;li>log10(a) - Base-10 logarithm.&lt;/li>
&lt;li>log_base(a,b) - Base-b logarithm.&lt;/li>
&lt;li>gauss($x,x_0,w$) - Calculate a Gaussian profile in variable
&lt;em>&lt;code>x&lt;/code>&lt;/em> centred on &lt;em>&lt;code>$x_0$&lt;/code>&lt;/em> with a
characteristic width &lt;em>&lt;code>w&lt;/code>&lt;/em>.
$f(x) = \exp{(-((x-x_0)/w)^2)}$. In this expression the full width
at half maximum is given by $fwhm = 2 w \sqrt{\ln{2}}$&lt;/li>
&lt;li>supergauss($x,x_0,w,n$) - This is identical to &amp;ldquo;gauss&amp;rdquo; except it
takes a fourth parameter, &lt;em>&lt;code>n&lt;/code>&lt;/em>, which is the power to
raise the exponential argument to.&lt;/li>
&lt;li>semigauss($t,A,A_0,w$) - Calculate a semi Gaussian profile in
variable $t$ with maximum amplitude $A$, amplitude at $t=0$ $A_0$
and width $w$. The parameter $A_0$ is used to calculate $t_0$, the
point at which the Gaussian reaches its maximum value. For $t$ less
than $t_0$ the profile is Gaussian and for $t$ greater than $t_0$ it
is the constant $A$. $t_0 = w\sqrt{-\ln{(A_0/A)}}$&lt;math>f(t) =&lt;/li>
&lt;/ul>
&lt;p>\begin{cases} A \exp{(-((t-t_0)/w)^2)}, &amp;amp; t &amp;lt; t_0 \\ A, &amp;amp;
\mbox{otherwise} \end{cases}&lt;/math>&lt;/p>
&lt;ul>
&lt;li>interpolate(interp_var,.&amp;hellip;,n_pairs) - Linear interpolation
function, explained later.&lt;/li>
&lt;li>if(a,b,c) - Conditional function. If a != 0 the function returns b,
otherwise the function returns c.&lt;/li>
&lt;li>number_density(a) - Returns the number density for species a.&lt;/li>
&lt;li>temp_{x,y,z}(a) - Returns temperature in the x, y or z direction
for species a.&lt;/li>
&lt;li>temp(a) - Returns the isotropic temperature for species a.&lt;/li>
&lt;li>e{x,y,z}(x,y,z) - Returns the x, y or z component of the electric
field at the specified location.&lt;/li>
&lt;li>b{x,y,z}(x,y,z) - Returns the x, y or z component of the magnetic
field at the specified location.&lt;/li>
&lt;li>critical($\omega$) - Returns the critical density for the given
frequency $\omega$. ie.
$n_{crit}(\omega) = \omega^2 m_0 \epsilon_0 / e^2$&lt;/li>
&lt;/ul>
&lt;p>It is also possible for an end user to specify custom functions within
the code. An example of using a function would be:
&lt;strong>length_x = exp(pi)&lt;/strong>
The use of most of these functions is fairly simple, but &amp;ldquo;interpolate&amp;rdquo;
requires some additional explanation. This function allows a user to
specify a set of position,value pairs and have the code linearly
interpolate the values between these control points. This function is
mainly intended for ease of converting initial conditions from other
existing PIC codes, and the same effect can usually be obtained more
elegantly using the &amp;ldquo;if&amp;rdquo; command. The structure of the &amp;ldquo;interpolate&amp;rdquo;
command is as follows: The first parameter is the variable which is to
be used as the axis over which to interpolate the values. This can in
general be any valid expression, but will normally just be a coordinate
axis. The next 2n entries are the position,value pairs and the final
parameter is the number of position,value pairs. The slightly clunky
syntax of this command is unfortunately necessary to allow it to work
with some fairly fundamental features of the maths parser used in EPOCH.&lt;/p>
&lt;h3 id="operators">Operators&lt;/h3>
&lt;p>The maths parser in EPOCH allows the following operators&lt;/p>
&lt;ul>
&lt;li>a + b - Addition operator.&lt;/li>
&lt;li>a - b - Subtraction operator or unary negation operator
(auto-detected).&lt;/li>
&lt;li>a * b - Multiplication operator.&lt;/li>
&lt;li>a / b - Division operator.&lt;/li>
&lt;li>a ^ b - Power raise operator.&lt;/li>
&lt;li>a e b - Power of ten operator (1.0e3 = 1000).&lt;/li>
&lt;li>a lt b - Less than operator. Returns 1 if a $&amp;lt;$ b, otherwise
returns 0. Intended for use with if.&lt;/li>
&lt;li>a gt b - Greater than operator. Returns 1 if a $&amp;gt;$ b, otherwise
returns 0.&lt;/li>
&lt;li>a eq b - Equality operator. Returns 1 if a == b, otherwise
returns 0.&lt;/li>
&lt;li>a and b - Logical and operator. Returns 1 if a != 0 and b != 0,
otherwise returns 0.&lt;/li>
&lt;li>a or b - Logical or operator. Returns 1 if a != 0 or b != 0,
otherwise returns 0.&lt;/li>
&lt;/ul>
&lt;p>These follow the usual rules for operator precedence, although it is
best to surround more complex expressions in parenthesis if the
precedence is important. It is not possible at this time to specify
custom operators without major changes to the code. An example of using
an operator would be:&lt;/p>
&lt;pre>&lt;code class="language-perl"> length_x = 10.0 + 12.0
&lt;/code>&lt;/pre></description></item><item><title>General layout of the EPOCH code</title><link>/developer/source_code_files.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/source_code_files.html</guid><description>&lt;p>The names of the source files in EPOCH are fairly self explanatory but, for
clarity, they are explained here. Some files have the normal Fortran file
extension &lt;code>.f90&lt;/code>, while some have the slightly unusual &lt;code>.F90&lt;/code>. The difference is
that files with the &lt;code>.F90&lt;/code> extension are passed through the preprocessor before
they are compiled allowing the use of precompiler directives (the &lt;code>#ifdef&lt;/code>
commands).&lt;/p>
&lt;h2 id="directories">Directories&lt;/h2>
&lt;p>All source files are contained in the &lt;code>src&lt;/code> directory and its
subdirectories. There is a stylistic reason for the layout of the files, which
is explained here&lt;/p>
&lt;ul>
&lt;li>&lt;code>src&lt;/code> - Files in this directory are the core files for the
basic EPOCH code, such as the field solvers, the particle pusher, the
boundary conditions and the lasers.&lt;/li>
&lt;li>&lt;code>src/deck&lt;/code> - Files in this directory are responsible for
dealing with the permanent input deck parser and include the core parts of
the deck handler, and also the routines which deal with the blocks in the
input deck files.&lt;/li>
&lt;li>&lt;code>src/housekeeping&lt;/code> - Files in this directory deal with those
parts of the code operation which are not physics; including the load
balancer, the MPI setup routines and the moving window.&lt;/li>
&lt;li>&lt;code>src/include&lt;/code> - This directory contains the shape function
code fragments which are inserted into the particle push at compile time.&lt;/li>
&lt;li>&lt;code>src/io&lt;/code> - The files involved in all I/O activities, including
the distribution functions and the particle probes.&lt;/li>
&lt;li>&lt;code>src/parser&lt;/code> - The files for the maths expression parser are
in this directory, including both the core implementation of the shunting yard
algorithm and the routines for implementing the permanent functions,
constants and operators for the input deck.&lt;/li>
&lt;li>&lt;code>src/physics_packages&lt;/code> - Contains routines which implement
additional physics for the code.&lt;/li>
&lt;li>&lt;code>src/user_interaction&lt;/code> - Contains any Fortran routines which
a user has to modify to use the code with internal initial conditions, or to
temporarily extend the maths parser or the input deck.&lt;/li>
&lt;/ul>
&lt;h2 id="the-files-in-src">The files in &lt;code>src&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;code>boundary.F90&lt;/code> - Includes all boundary conditions except laser
and transmissive boundaries; including field and particle MPI boundaries, and
field and particle domain boundaries.&lt;/li>
&lt;li>&lt;code>constants.F90&lt;/code> - A collection of physical constants, and also integer flags
for I/O, boundaries, and other variables.&lt;/li>
&lt;li>&lt;code>epoch1d.F90&lt;/code>, &lt;code>epoch2d.F90&lt;/code>, &lt;code>epoch3d.F90 &lt;/code> - Main driver for the code.
Reading this routine gives the basic layout of the code flow.&lt;/li>
&lt;li>&lt;code>fields.f90&lt;/code> - The Maxwell field solver.&lt;/li>
&lt;li>&lt;code>laser.f90&lt;/code> - Includes laser and transmissive boundary
conditions for each boundary and also the housekeeping routines for the laser
objects.&lt;/li>
&lt;li>&lt;code>particles.F90&lt;/code> - The particle pusher.&lt;/li>
&lt;li>&lt;code>shared_data.F90&lt;/code> - This file includes all the global variable
and type definitions. Usually new variables should be defined in this file.&lt;/li>
&lt;li>&lt;code>gen_commit_string&lt;/code> - This is a script used to generate an ID
string when compiling the code.&lt;/li>
&lt;li>&lt;code>gen_src_module&lt;/code> - This is a script which is used at build
time to generate a Fortran module containing the source code. This is used for
embedding the EPOCH source code into restart dumps.&lt;/li>
&lt;/ul>
&lt;h2 id="the-files-in-srcdeck">The files in &lt;code>src/deck&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;code>deck.F90&lt;/code> - The main input deck routines. Deals with opening
files, reading data and MPI distribution of the data to all processes. Also
includes the routines which deal with calling the right reader routines to
deal with a given block.&lt;/li>
&lt;li>&lt;code>deck_boundaries_block.f90&lt;/code> - Reader routine for the
&amp;ldquo;boundaries&amp;rdquo; block of the input deck.&lt;/li>
&lt;li>&lt;code>deck_bremsstrahlung_block.f90&lt;/code> - Reader routine for the
&amp;ldquo;bremsstrahlung&amp;rdquo; block of the input deck.&lt;/li>
&lt;li>&lt;code>deck_collision_block.f90&lt;/code> - Reader routine for &amp;ldquo;collision&amp;rdquo;
blocks in the input deck.&lt;/li>
&lt;li>&lt;code>deck_constant_block.f90&lt;/code> - Reader routine for &amp;ldquo;constant&amp;rdquo;
blocks in the input deck.&lt;/li>
&lt;li>&lt;code>deck_control_block.f90&lt;/code> - Reader routine for &amp;ldquo;control&amp;rdquo;
block in the input deck.&lt;/li>
&lt;li>&lt;code>deck_dist_fn_block.f90&lt;/code> - Reader routine for &amp;ldquo;dist_fn&amp;rdquo;
blocks in the input deck.&lt;/li>
&lt;li>&lt;code>deck_fields_block.f90&lt;/code> - Reader routine for &amp;ldquo;fields&amp;rdquo;
blocks in the input deck.&lt;/li>
&lt;li>&lt;code>deck_io_block.F90&lt;/code> - Reader routine for the &amp;ldquo;io&amp;rdquo; block in
the input deck.&lt;/li>
&lt;li>&lt;code>deck_io_global_block.F90&lt;/code> - Reader routine for the &amp;ldquo;io_global&amp;rdquo; block in
the input deck.&lt;/li>
&lt;li>&lt;code>deck_laser_block.f90&lt;/code> - Reader routine for &amp;ldquo;laser&amp;rdquo; blocks
in the input deck.&lt;/li>
&lt;li>&lt;code>deck_part_from_file_block.F90&lt;/code> - Reader routine for the &amp;ldquo;part_from_file&amp;rdquo;
block in the input deck.&lt;/li>
&lt;li>&lt;code>deck_particle_probe_block.F90&lt;/code> - Reader routine for
&amp;ldquo;particle_probe&amp;rdquo; blocks in the input deck.&lt;/li>
&lt;li>&lt;code>deck_species_block.F90&lt;/code> - Reader routine for &amp;ldquo;species&amp;rdquo;
blocks in the input deck. This contains scripts which create the species_list
array which holds the particle lists for each species.&lt;/li>
&lt;li>&lt;code>deck_stencil_block.F90&lt;/code> - Reader routine for &amp;ldquo;stencil&amp;rdquo;
blocks in the input deck.&lt;/li>
&lt;li>&lt;code>deck_subset_block.F90&lt;/code> - Reader routine for &amp;ldquo;subset&amp;rdquo;
blocks in the input deck.&lt;/li>
&lt;li>&lt;code>deck_window_block.f90&lt;/code> - Reader routine for the &amp;ldquo;window&amp;rdquo;
block in the input deck.&lt;/li>
&lt;li>&lt;code>strings.f90&lt;/code> - Basic string handling routines such as
&amp;ldquo;str_cmp&amp;rdquo; and routines for converting strings to numbers WITHOUT using the
maths parser are covered in this routine.&lt;/li>
&lt;li>&lt;code>strings_advanced.f90&lt;/code> - The routines which pass maths along
to the maths parser routines are here.&lt;/li>
&lt;/ul>
&lt;h2 id="the-files-in-srchousekeeping">The files in &lt;code>src/housekeeping&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;code>balance.F90&lt;/code> - Contains the routines for the load balancer
and related routines.&lt;/li>
&lt;li>&lt;code>current_smooth.F90&lt;/code> - Contains the current smoothing routines.&lt;/li>
&lt;li>&lt;code>epoch_source_info_dummy.f90&lt;/code> - A dummy module used when the
code is being built without the ability to write the source code into restart
dumps.&lt;/li>
&lt;li>&lt;code>finish.F90&lt;/code> - Deallocates fields, species, subsets and physics packages at
the end of the simulation.&lt;/li>
&lt;li>&lt;code>mpi_routines.F90&lt;/code> - Contains the routines dealing with the
setup of the MPI layer and the creation of the communicator. Also allocates
all arrays for the first time before load balancing.&lt;/li>
&lt;li>&lt;code>mpi_subtype_control.f90&lt;/code> - Contains the routines that setup
the mpi types required by the I/O subsystem.&lt;/li>
&lt;li>&lt;code>particle_id_hash.F90&lt;/code> - Stores scripts responsible for identifying particles
in persistent subsets.&lt;/li>
&lt;li>&lt;code>particle_pointer_advance.f90&lt;/code> - Contains subroutines which
walk through the lists of particles and species for I/O purposes.&lt;/li>
&lt;li>&lt;code>partlist.F90&lt;/code> - Contains the routines which deal with the
particle lists which are used for inter-processor communication of particles.&lt;/li>
&lt;li>&lt;code>prefetch.F90&lt;/code> - Hold scripts for pre-fetching particles. This requires Intel
compilation of the code, and can improve performance.&lt;/li>
&lt;li>&lt;code>random_generator.f90&lt;/code> - Contains the random number generator
routines.&lt;/li>
&lt;li>&lt;code>redblack_module.f90&lt;/code> - Contains MPI routines used for the load-balancer.&lt;/li>
&lt;li>&lt;code>setup.F90&lt;/code> - Deals with the setup of the grids and domains and
restarting from previous output dumps.&lt;/li>
&lt;li>&lt;code>shape_functions.F90&lt;/code> - Contains the particle shape functions
used for calculating the particle weighting.&lt;/li>
&lt;li>&lt;code>split_particle.F90&lt;/code> - Is the implementation of a
demonstration of particle splitting routines.&lt;/li>
&lt;li>&lt;code>terminal_controls.F90&lt;/code> - Makes the logo colourful on startup.&lt;/li>
&lt;li>&lt;code>timer.f90&lt;/code> - Tracks the run-time of the code.&lt;/li>
&lt;li>&lt;code>utilities.f90&lt;/code> - Contains growable arrays used by the species
block parser.&lt;/li>
&lt;li>&lt;code>version_data.F90&lt;/code> - Contains version information for the
current EPOCH code.&lt;/li>
&lt;li>&lt;code>welcome.F90&lt;/code> - The routine which prints the banner message and
compiler options info.&lt;/li>
&lt;li>&lt;code>window.F90&lt;/code> - The routines which deal with the moving window.&lt;/li>
&lt;/ul>
&lt;h2 id="the-files-in-srcio">The files in &lt;code>src/io&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;code>calc_df.F90&lt;/code> - Despite the slightly confusing name, this
subroutine deals with derived functions like number density, charge density
and mass density.&lt;/li>
&lt;li>&lt;code>diagnostics.F90&lt;/code> - Contains the routines which actually dump
the data, decide what to dump and also the routine to calculate the timestep.&lt;/li>
&lt;li>&lt;code>dist_fn.F90&lt;/code> - Contains the routines to calculate the
distribution functions, and also the routines handling the requests for
distribution functions.&lt;/li>
&lt;li>&lt;code>iterators.F90&lt;/code> - Contains the iterator functions used to write
particle data into SDF files.&lt;/li>
&lt;li>&lt;code>probes.F90&lt;/code> - Contains the routines which write the data from
the particle probes. Also includes the routines which deal with user requests
to add new particle probes.&lt;/li>
&lt;li>&lt;code>simple_io.f90&lt;/code> - Contains routines for performing the simple
binary I/O required by species_external and fields_external blocks.&lt;/li>
&lt;/ul>
&lt;h2 id="the-files-in-srcparser">The files in &lt;code>src/parser&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;code>evaluate.f90&lt;/code> - Contains the routines which actually evaluate
a tokenized expression. The core of this is a simple implementation of an
RPN calculator.&lt;/li>
&lt;li>&lt;code>evaluator_blocks.f90&lt;/code> - Contains the routines which evaluate
a given token into a numerical values. Actually implements the functions,
constants and operators in EPOCH&amp;rsquo;s maths parser.&lt;/li>
&lt;li>&lt;code>shunt.F90&lt;/code> - EPOCH&amp;rsquo;s implementation of the
&amp;ldquo;shunting yard&amp;rdquo; algorithm used to simultaneously tokenize the input and
convert it from infix notation to RPN.&lt;/li>
&lt;li>&lt;code>stack.f90&lt;/code> - Deals with routines for pushing onto and popping
off stacks.&lt;/li>
&lt;li>&lt;code>tokenizer_blocks.f90&lt;/code> - Deal with converting strings found
in a string being tokenized into tokens. Essentially a large collection of
&amp;ldquo;str_cmp&amp;rdquo; commands testing a string against a known name.&lt;/li>
&lt;/ul>
&lt;h2 id="the-files-in-srcphysics_packages">The files in &lt;code>src/physics_packages&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;code>TABLES&lt;/code> - Subdirectory containing tables
for QED emissions, bremsstrahlung radiation, and both collisional and field
ionisation.&lt;/li>
&lt;li>&lt;code>background_collisions.F90&lt;/code> - Package handling particle collisions for special
cases. Faster than the &lt;code>collisions.F90&lt;/code> model, but assumes a heavy species
remains immobile during the collision. Appropriate for hot electron scatter
through cold ions.&lt;/li>
&lt;li>&lt;code>bethe_heitler.F90&lt;/code> - Package sampling pair-production via the Bethe-Heitler
process. This is run during the bremsstrahlung update.&lt;/li>
&lt;li>&lt;code>bremsstrahlung.F90&lt;/code> - Runs bremsstrahlung radiation of electrons and positrons,
discussed in Appendix B of
&lt;a href="https://aip.scitation.org/doi/10.1063/5.0055398" target="_blank" rel="noopener">Morris et al&lt;/a>.&lt;/li>
&lt;li>&lt;code>collision_ionise.F90&lt;/code> - Package sampling collisional ionisation triggered by
incident electrons. See
&lt;a href="https://aip.scitation.org/doi/abs/10.1063/5.0126336" target="_blank" rel="noopener">here&lt;/a>
for details.&lt;/li>
&lt;li>&lt;code>collisions.F90&lt;/code> - Package handling particle collisions. Estimates the
number of binary Coulomb collisions over a simulation time-step, and samples a
cumulative scatter angle. See
&lt;a href="https://aip.scitation.org/doi/abs/10.1063/1.4742167" target="_blank" rel="noopener">here&lt;/a>
for details.&lt;/li>
&lt;li>&lt;code>file_injectors.F90&lt;/code> - Injects particles from user-written text files (ASCII).&lt;/li>
&lt;li>&lt;code>injectors.F90&lt;/code> - Package dealing with particle injection through
a boundary. Currently this handles drifting and non-drifting Maxwellian and
flux-Maxwellian distributions.&lt;/li>
&lt;li>&lt;code>ionise.F90&lt;/code> - Physics package dealing with field ionisation.
Field ionisation consists of three distinct regimes; multiphoton in which
ionisation is best described as absorption of multiple photons, tunnelling
in which deformation of the atomic Coulomb potential is the dominant factor,
and barrier suppression ionisation in which the electric field is strong enough
for an electron to escape classically. It is possible to turn off multiphoton or
barrier suppression ionisation through the input deck.&lt;/li>
&lt;li>&lt;code>numerics.f90&lt;/code> - Some additional numerics
routines, primarily for the photons (QED) package.&lt;/li>
&lt;li>&lt;code>photons.F90&lt;/code> - Package for some QED effects.
Models Breit-Wheeler pair production, synchrotron emission and radiation
reaction as described in
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/53/1/015009" target="_blank" rel="noopener">Duclous et al&lt;/a> and
&lt;a href="https://www.sciencedirect.com/science/article/pii/S0021999113008061?via" target="_blank" rel="noopener">Ridgers et al&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="the-files-in-srcuser_interaction">The files in &lt;code>src/user_interaction&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;code>custom_deck.f90&lt;/code> - This file is where and end user can
temporarily extend the input deck.&lt;/li>
&lt;li>&lt;code>custom_laser.f90&lt;/code> - The file where an end user specifies
laser time profiles without using the input deck.&lt;/li>
&lt;li>&lt;code>custom_parser.f90&lt;/code> - The file where an end user can
temporarily add new functions and constants to the input deck.&lt;/li>
&lt;li>&lt;code>deltaf_loader.F90&lt;/code> - Sets up parameters for the delta-f model.&lt;/li>
&lt;li>&lt;code>helper.F90&lt;/code> - This file contains all the internal workings of
the autoloader. This is in user_interaction for historical reasons, since
early versions of the code required the end user to modify some parts of the
functions contained in this file. As the autoloader has increased in
complexity, this has ceased to be the case, so it is likely that soon this
file will be move to &amp;ldquo;housekeeping&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>ic_module.f90&lt;/code> - This file is where the internal and manual
initial conditions are set.&lt;/li>
&lt;li>&lt;code>particle_temperature.F90&lt;/code> - Contains the routines for
thermally loading a particle species.&lt;/li>
&lt;/ul></description></item><item><title>Using EPOCH in practice</title><link>/documentation/code_details/using_epoch_in_practice.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/code_details/using_epoch_in_practice.html</guid><description>&lt;h1 id="specifying_initial_conditions_for_particles_using_the_input_deck">Specifying initial conditions for particles using the input deck&lt;/h1>
&lt;p>If the initial conditions for the plasma you wish to model can be
described by a number density and temperature profile on the underlying
grid then EPOCH can create an appropriate particle distribution for you.
The set of routines which accomplish this task are known as the
autoloader. For many users, this functionality is sufficient to make use
of the code and there is no need to deal with the internal
representation of particles in EPOCH.&lt;/p>
&lt;p>The autoloader randomly loads particles in space to reproduce the number
density profile that was requested. It then sets the momentum components
of the particles to approximate a Maxwell-Boltzmann distribution
corresponding to the temperature profile. Sometimes this is not the
desired behaviour, for example you may wish to model a bump-on-tail
velocity distribution. It is currently not possible to specify these
initial conditions from the input deck and the particles must be setup
by modifying the source code.&lt;/p>
&lt;p>There are two stages to the particle setup in EPOCH&lt;/p>
&lt;ul>
&lt;li>auto_load - This routine is called after reading and parsing the
input deck. It takes care of allocating particles and setting up
their initial positions and momenta using the initial conditions
supplied in deck file. It is not necessary to recompile the code, or
even have access to the source to change the initial conditions
using this method.&lt;/li>
&lt;li>manual_load - Once particles have been allocated they can have
their properties altered in this routine. By default it is an empty
routine which does nothing.&lt;/li>
&lt;/ul>
&lt;h3 id="setting_autoloader_properties_from_the_input_deck">Setting autoloader properties from the input deck&lt;/h3>
&lt;p>To illustrate using the autoloader in practice, we present an example
for setting up an isolated plasma block in 2D. This would look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = s1
# First set number_density in the range 0 &amp;gt; 1
# Cut down number_density in x direction
number_density = if ((x gt -1) and (x lt 1), 1.0, 0.2)
# Cut down number_density in y direction
number_density = if ((y gt -1) and (y lt 1), number_density(s1), 0.2)
# Multiply number_density by real particle number_density
number_density = number_density(s1) * 100.0
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * 100.0
end:species
begin:species
# Just copy the number_density for species s1
number_density = number_density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * 100.0
end:species
&lt;/code>&lt;/pre>
&lt;p>An important point to notice is that the two parts of the logical
expressions in the input deck are enclosed within their own brackets.
This helps to remove some ambiguities in the functioning of the input
deck parser. It is hoped that this will soon be fixed, but at present
ALWAYS enclose logical expressions in brackets.&lt;/p>
&lt;h1 id="manually_overriding_particle_parameters_set_by_the_autoloader">Manually overriding particle parameters set by the autoloader&lt;/h1>
&lt;p>Since not all problems in plasma physics can be described in terms of an
initial distribution of thermal plasma, it is also possible to manually
control properties of each individual pseudoparticle for an initial
condition. This takes place in the subroutine &lt;code>manual_load&lt;/code> in the file
user_interaction/ic_module.f90. Manual loading takes place after all
the autoloader phase, to allow manual tweaking of autoloader specified
initial conditions.&lt;/p>
&lt;h3 id="epoch_internal_representation_of_particles">EPOCH internal representation of particles&lt;/h3>
&lt;p>Before we can go about manipulating particle properties in
&lt;code>manual_load&lt;/code>, we first need an overview of how the particles are
defined in EPOCH. Inside the code, particles are represented by a
Fortran90 TYPE called &lt;strong>&lt;code>particle&lt;/code>&lt;/strong>. The current definition of this
type (in 1D) is:&lt;/p>
&lt;pre>&lt;code class="language-fortran"> TYPE particle
REAL(num), DIMENSION(3) :: part_p
REAL(num) :: part_pos
#if !defined(PER_SPECIES_WEIGHT) || defined(PHOTONS)
REAL(num) :: weight
#endif
#ifdef DELTAF_METHOD
REAL(num) :: pvol
#endif
#ifdef PER_PARTICLE_CHARGE_MASS
REAL(num) :: charge
REAL(num) :: mass
#endif
TYPE(particle), POINTER :: next, prev
#ifdef PARTICLE_DEBUG
INTEGER :: processor
INTEGER :: processor_at_t0
#endif
#ifdef PARTICLE_ID4
INTEGER :: id
#elif PARTICLE_ID
INTEGER(i8) :: id
#endif
#ifdef WORK_DONE_INTEGRATED
REAL(num) :: work_x
REAL(num) :: work_y
REAL(num) :: work_z
REAL(num) :: work_x_total
REAL(num) :: work_y_total
REAL(num) :: work_z_total
#endif
#ifdef PHOTONS
REAL(num) :: optical_depth
REAL(num) :: particle_energy
#ifdef TRIDENT_PHOTONS
REAL(num) :: optical_depth_tri
#endif
#endif
END TYPE particle
&lt;/code>&lt;/pre>
&lt;p>Here, most of the preprocessing directives have been stripped out for
clarity. We have left &lt;code>#ifdef PARTICLE_DEBUG&lt;/code> as an example. Here, the
&amp;ldquo;processor&amp;rdquo; and &amp;ldquo;processor_at_t0&amp;rdquo; variables only exist if the
&lt;code>-DPARTICLE_DEBUG&lt;/code> define was put in the makefile. If you want to access
a property that does not seem to be present, check the
&lt;a href="/documentation/basic_usage/compiler_flags">preprocessor
defines&lt;/a>.&lt;/p>
&lt;p>The &amp;ldquo;particle&amp;rdquo; properties can be explained as follows:&lt;/p>
&lt;ul>
&lt;li>part_p - The momentum in 3 dimensions for the particle. This is
always of size 3.&lt;/li>
&lt;li>part_pos - The position of the particle in space. This is of the
same size as the dimensionality of the code.&lt;/li>
&lt;li>weight - The weight of this particle. The number of real particles
represented by this pseudoparticle.&lt;/li>
&lt;li>charge - The particle charge. If the code was compiled without per
particle charge, then the code uses the charge property from
TYPE(particle_species).&lt;/li>
&lt;li>mass - The particle rest mass. If the code was compiled without per
particle mass, then the code uses the mass property from
TYPE(particle_species).&lt;/li>
&lt;li>next, prev - The next and previous particle in the linked list which
represents the particles in the current species. This will be
explained in more detail later.&lt;/li>
&lt;li>processor - The rank of the processor which currently holds the
particle.&lt;/li>
&lt;li>processor_at_t0 - The rank of the processor on which the particle
started.&lt;/li>
&lt;li>id - Unique particle ID.&lt;/li>
&lt;li>optical_depth - Optical depth used in the QED routines.&lt;/li>
&lt;li>particle_energy - Particle energy used in the QED routines.&lt;/li>
&lt;li>optical_depth_tri - Optical depth for the trident process in the
QED routines.&lt;/li>
&lt;/ul>
&lt;p>Collections of particles are represented by another Fortran TYPE, called
&lt;strong>&lt;code>particle_list&lt;/code>&lt;/strong>. This type represents all the properties of a
collection of particles and is used behind the scenes to deal with
inter-processor communication of particles. The definition of the type
is:&lt;/p>
&lt;pre>&lt;code class="language-fortran"> TYPE particle_list
TYPE(particle), POINTER :: head
TYPE(particle), POINTER :: tail
INTEGER(i8) :: count
INTEGER :: id_update
! Pointer is safe if the particles in it are all unambiguously linked
LOGICAL :: safe
! Does this partlist hold copies of particles rather than originals
LOGICAL :: holds_copies
TYPE(particle_list), POINTER :: next, prev
END TYPE particle_list
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>head - The first particle in the linked list.&lt;/li>
&lt;li>tail - The last particle in the linked list.&lt;/li>
&lt;li>count - The number of particles in the list. Note that this is NOT
MPI aware, so reading count only gives you the number of particles
on the local processor.&lt;/li>
&lt;li>safe - Any particle_list which a user should come across will be a
safe particle_list. Don&amp;rsquo;t change this property.&lt;/li>
&lt;li>next, prev - For future expansion it is possible to attach
particle_lists together in another linked list. This is not
currently used anywhere in the code.&lt;/li>
&lt;/ul>
&lt;p>An entire species of particles is represented by another Fortran TYPE,
this time called &lt;strong>&lt;code>particle_species&lt;/code>&lt;/strong>. This represents all the
properties which are common to all particles in a species. The current
definition is:&lt;/p>
&lt;pre>&lt;code class="language-fortran"> TYPE particle_species
! Core properties
CHARACTER(string_length) :: name
TYPE(particle_species), POINTER :: next, prev
INTEGER :: id
INTEGER :: dumpmask
INTEGER :: count_update_step
REAL(num) :: charge
REAL(num) :: mass
REAL(num) :: weight
INTEGER(i8) :: count
TYPE(particle_list) :: attached_list
LOGICAL :: immobile
LOGICAL :: fill_ghosts
! Parameters for relativistic and arbitrary particle loader
INTEGER :: ic_df_type
REAL(num) :: fractional_tail_cutoff
TYPE(primitive_stack) :: dist_fn
TYPE(primitive_stack) :: dist_fn_range(3)
#ifndef NO_TRACER_PARTICLES
LOGICAL :: zero_current
#endif
! ID code which identifies if a species is of a special type
INTEGER :: species_type
! particle cell division
INTEGER(i8) :: global_count
LOGICAL :: split
INTEGER(i8) :: npart_max
! Secondary list
TYPE(particle_list), DIMENSION(:), POINTER :: secondary_list
! Injection of particles
REAL(num) :: npart_per_cell
TYPE(primitive_stack) :: density_function, temperature_function(3)
TYPE(primitive_stack) :: drift_function(3)
! Thermal boundaries
REAL(num), DIMENSION(:), POINTER :: ext_temp_x_min, ext_temp_x_max
! Species_ionisation
LOGICAL :: electron
LOGICAL :: ionise
INTEGER :: ionise_to_species
INTEGER :: release_species
INTEGER :: n
INTEGER :: l
REAL(num) :: ionisation_energy
! Attached probes for this species
#ifndef NO_PARTICLE_PROBES
TYPE(particle_probe), POINTER :: attached_probes
#endif
! Particle migration
TYPE(particle_species_migration) :: migrate
! Initial conditions
TYPE(initial_condition_block) :: initial_conditions
! Per-species boundary conditions
INTEGER, DIMENSION(2*c_ndims) :: bc_particle
END TYPE particle_species
&lt;/code>&lt;/pre>
&lt;p>This definition is for the 1D version of the code. The only difference
for the other two versions is the number of dimensions in the arrays
&amp;ldquo;secondary_list&amp;rdquo; and &amp;ldquo;ext_temp_*&amp;rdquo;. There are quite a lot of
fields here, so we will just document some of the most important ones.&lt;/p>
&lt;ul>
&lt;li>name - The name of the particle species, used in the output dumps
etc.&lt;/li>
&lt;li>next, prev - Particle species are also linked together in a linked
list. This is used internally by the output dump routines, but
should not be used by end users.&lt;/li>
&lt;li>id - The species number for this species. This is the same number as
is used in the input deck to designate the species.&lt;/li>
&lt;li>dumpmask - Determine when to include this species in output dumps.
Note that the flag is ignored for restart dumps.&lt;/li>
&lt;li>charge - The charge in Coulombs. Even if PER_PARTICLE_CHARGE_MASS
is specified, this is still populated from the input deck, and now
refers to the reference charge for the species.&lt;/li>
&lt;li>mass - The mass in kg.&lt;/li>
&lt;li>weight - The per-species particle weight.&lt;/li>
&lt;li>count - The global number of particles of this species (NOTE may not
be accurate). This will only ever be the number of particles on this
processor when running on a single processor. While this property
will be accurate when setting up initial conditions, it is only
guaranteed to be accurate for the rest of the code if the code is
compiled with the correct preprocessor options.&lt;/li>
&lt;li>attached_list - The list of particles which belong to this species.&lt;/li>
&lt;li>immobile - If set to &lt;code>.TRUE.&lt;/code> then the species is ignored during the
particle push.&lt;/li>
&lt;li>zero_current - If set to &lt;code>.TRUE.&lt;/code> then the current is not updated
for this particle species.&lt;/li>
&lt;/ul>
&lt;h3 id="setting_the_particle_properties">Setting the particle properties&lt;/h3>
&lt;p>The details of exactly what a linked list means in EPOCH requires a more
in-depth study of the source code. For now, all we really need to know
is that each species has a list of particles. A pointer to the first
particle in the list is contained in
&lt;code>species_list(ispecies)%attached_list%head&lt;/code>. Once you have a pointer to
a particle (eg. current), you advance to the next pointer in the list
with &lt;code>current =&amp;gt; current%next&lt;/code>. After all the descriptions of the types,
actually setting the properties of the particles is fairly simple. The
following is an example which positions the particles uniformly in 1D
space, but doesn&amp;rsquo;t set any momentum.&lt;/p>
&lt;pre>&lt;code class="language-fortran"> SUBROUTINE manual_load
TYPE(particle), POINTER :: current
INTEGER :: ispecies
REAL(num) :: rpos, dx
DO ispecies = 1, n_species
current =&amp;gt; species_list(ispecies)%attached_list%head
dx = length_x / species_list(ispecies)%attached_list%count
rpos = x_min
DO WHILE(ASSOCIATED(current))
current%part_pos = rpos
current%weight = 1.0_num
rpos = rpos + dx
current =&amp;gt; current%next
ENDDO
ENDDO
END SUBROUTINE manual_load
&lt;/code>&lt;/pre>
&lt;p>This will take the particles which have been placed at random positions
by the autoloader and repositions them in a uniform manner. In order to
adjust the particle positions, you need to know about the grid used in
EPOCH. In this example we only required the length of the domain,
&amp;ldquo;length_x&amp;rdquo; and the minimum value of x, &amp;ldquo;x_min&amp;rdquo;. A more exhaustive list
is given in the following section. Note that I completely ignored the
question of domain decomposition when setting up the particles. The code
automatically moves the particles onto the correct processor without
user interaction.&lt;/p>
&lt;p>In the above example, note that particle momentum was not specified and
particle weight was set to be a simple constant. Setting particle weight
can be very simple if you can get the pseudoparticle distribution to
match the real particle distribution, or quite tricky if this isn&amp;rsquo;t
possible. The weight of a pseudoparticle is calculated such that the
number of pseudoparticles in a cell multiplied by their weights equals
the number of physical particles in that cell. This can be quite tricky
to get right, so in more complicated cases it is probably better to use
the autoloader than to manually set up the number density distribution.&lt;/p>
&lt;h3 id="grid_coordinates_used_in_epoch" class="">Grid coordinates used in EPOCH.&lt;/h3>
&lt;p>When setting up initial conditions within the EPOCH source (rather than
using the input deck) there are several constants that you may need to
use. These constants are:&lt;/p>
&lt;ul>
&lt;li>nx - Number of gridpoints on the local processor in the x direction.&lt;/li>
&lt;li>ny - Number of gridpoints on the local processor in the y direction
(2D and 3D).&lt;/li>
&lt;li>nz - Number of gridpoints on the local processor in the z direction
(3D).&lt;/li>
&lt;li>length_{x,y,z} - Length of domain in the x, y, z directions.&lt;/li>
&lt;li>{x,y,z}_min - Minimum value of x, y, z for the whole domain.&lt;/li>
&lt;li>{x,y,z}_max - Maximum value of x, y, z for the whole domain.&lt;/li>
&lt;li>n_species - The number of species in the code.&lt;/li>
&lt;/ul>
&lt;p>There are also up to three arrays which are available for use.&lt;/p>
&lt;ul>
&lt;li>x(-2:nx+3) - Position of a given gridpoint in real units in the x
direction.&lt;/li>
&lt;li>y(-2:ny+3) - Position of a given gridpoint in real units in the y
direction (2D and 3D).&lt;/li>
&lt;li>z(-2:nz+3) - Position of a given gridpoint in read units in the z
direction (3D).&lt;/li>
&lt;/ul>
&lt;h3 id="loading_a_separable_non_thermal_particle_distribution" class="">Loading a separable non-thermal particle distribution.&lt;/h3>
&lt;p>While the autoloader is capable of dealing with most required initial
thermal distributions, you may want to set up non-thermal initial
conditions. The code includes a helper function to select a point from
an arbitrary distribution function which can be used to deal with most
non-thermal distributions. To use the helper function, you need to
define two 1D arrays which are the x and y axes for the distribution
function. This approach is only possible if the distribution function
can be represented as a set of 1D distribution functions in px, py and
pz separately. If this is possible then this method is preferred since
it is significantly faster than the arbitrary method detailed in the
next section. An example of using the helper function is given below.&lt;/p>
&lt;pre>&lt;code class="language-fortran"> SUBROUTINE manual_load
TYPE(particle), POINTER :: current
INTEGER, PARAMETER :: np_local = 1000
INTEGER :: ispecies, ip
REAL(num) :: temperature, stdev2, tail_width, tail_height, tail_drift
REAL(num) :: frac, tail_frac, min_p, max_p, dp_local, p2, tail_p2
REAL(num), DIMENSION(np_local) :: p_axis, distfn_axis
temperature = 1e4_num
tail_width = 0.05_num
tail_height = 0.2_num
tail_drift = 0.5_num
DO ispecies = 1, n_species
stdev2 = kb * temperature * species_list(ispecies)%mass
frac = 1.0_num / (2.0_num * stdev2)
tail_frac = 1.0_num / (2.0_num * stdev2 * tail_width)
max_p = 5.0_num * SQRT(stdev2)
min_p = -max_p
dp_local = (max_p - min_p) / REAL(np_local-1, num)
DO ip = 1, np_local
p_axis(ip) = min_p + (ip - 1) * dp_local
p2 = p_axis(ip)**2
tail_p2 = (p_axis(ip) - tail_drift * max_p)**2
distfn_axis(ip) = EXP(-p2 * frac) &amp;amp;amp;
+ tail_height * EXP(-tail_p2 * tail_frac)
ENDDO
current=&amp;gt;species_list(ispecies)%attached_list%head
DO WHILE(ASSOCIATED(current))
current%part_p(1) = sample_dist_function(p_axis, distfn_axis)
current=&amp;gt;current%next
ENDDO
ENDDO
END SUBROUTINE manual_load
&lt;/code>&lt;/pre>
&lt;p>This example will set the particles to have a bump-on-tail velocity
distribution, a setup which is not possible to do using only the input
deck. It is not necessary to normalise the distribution function, as
this is done automatically by the
&lt;em>&lt;code>*sample_dist_function*&lt;/code>&lt;/em> function.&lt;/p>
&lt;h1 id="lasers">Lasers&lt;/h1>
&lt;p>EPOCH has the ability to add EM wave sources such as lasers at
boundaries. To use lasers, set the boundary that you wish to have a
laser on to be of type &lt;code>simple_laser&lt;/code> and then specify one or more
lasers attached to that boundary. Lasers may be specified anywhere
initial conditions are specified.&lt;/p>
&lt;h1 id="laser_blocks_in_multiple_dimensions" class="">Laser blocks in multiple dimensions.&lt;/h1>
&lt;p>When running EPOCH in 2D or 3D, the laser can be modified spatially via
the &lt;code>profile&lt;/code> and &lt;code>phase&lt;/code> parameters. These are briefly outlined
&lt;a href="/documentation/input_deck/input_deck_laser">here&lt;/a> but in this section we will
describe them in a little more depth.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>profile&lt;/code> - The spatial profile for the laser. This is
essentially an array defined along the edge (or surface) that the laser
is attached to. It is clear that the spatial profile is only meaningful
perpendicular to the laser&amp;rsquo;s direction of travel and so it is just a
single constant in 1D. The laser profile is evaluated as an initial
condition and so cannot include any temporal information which must be
encoded in &lt;code>t_profile&lt;/code>. The spatial profile is evaluated at the boundary
where the laser is attached and so only spatial information in the plane
of the boundary is significant. This is most clearly explained through a
couple of examples. In these examples the spatial profile of the laser
is set to vary between a flat uniform profile (&lt;code>profile = 1&lt;/code>) and a
Gaussian profile in y (&lt;code>profile = gauss(y,0,2.5e-6)&lt;/code>). The difference
between these profiles is obvious but the important point is that a
laser travelling parallel to the x-direction has a profile in the y
direction. Similarly a laser propagating in the y-direction has a
profile in the x direction. In 3D this is extended so that a laser
propagating in a specified direction has a profile in both orthogonal
directions. So a laser travelling parallel to the x axis in 3D would
have a profile in y and z. Since 3D lasers are very similar to 2D
lasers, they will not be considered here in greater detail, but in 3D,
it is possible to freely specify the laser profile across the entire
face where a laser is attached.
&lt;img src="Profile_flat.png" alt="Uniform laser profile inEPOCH2D">
&lt;img src="Profile_gauss.png" alt="Gaussian laser profile inEPOCH2D">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>phase&lt;/code> - Phase shift for the laser in radians. This is a
spatial variable which is also defined across the whole of the
boundary on which the laser is attached. This allows a user to add a
laser travelling at an angle to a boundary as shown in
Figure [angle]. The setup for this is not entirely straightforward
and requires a little bit of explanation. Figure [wave]
illustrates a laser being driven at an angle on the x_min boundary.
Different wave fronts cross the $y$-axis at different places and
this forms a sinusoidal profile along $y$ that represents the phase.
The wavelength of this profile is given by
$\lambda_\phi = \lambda / \sin\theta$, where $\lambda$ is the
wavelength of the laser and $\theta$ is the angle of the propagation
direction with respect to the $x$-axis. The actual phase to use will
be $\phi(y) = -k_\phi y = -2\pi y / \lambda_\phi$. It is negative
because the phase of the wave is propagating in the positive $y$
direction. It is also necessary to alter the wavelength of the
driver since this is given in the direction perpendicular to the
boundary. The new wavelength to use will be $\lambda\cos\theta$.
Figure [angle] shows the resulting $E_y$ field for a laser driven
at an angle of $\pi / 8$. Note that since the boundary conditions in
the code are derived for propagation perpendicular to the boundary,
there will be artefacts on the scale of the grid for lasers driven
at an angle.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="Profile_angle.png" alt="Laser propagating at an angle inEPOCH2D">
&lt;img src="Wave_angle.png" alt="Schematic diagram of a laser propagating at an angle in2D">&lt;/p>
&lt;p>Using this technique it is also possible to focus a laser. This is done
by using the same technique as above but making the angle of
propagation, $\theta$, a function of $y$ such that the laser is focused
to a point along the $x$-axis. A simple example is given
&lt;a href="/documentation/examples/basic_examples#focussing_a_gaussian_beam">here&lt;/a>.&lt;/p>
&lt;h1 id="restarting_epoch_from_previous_output_dumps">Restarting EPOCH from previous output dumps&lt;/h1>
&lt;p>Another possible way of setting up initial conditions in EPOCH is to
load in a previous output dump and use it to specify initial conditions
for the code. The effect of this is to restart the code from the state
that it was in when the dump was made. To do this, you just set the
field &amp;ldquo;restart_snapshot&amp;rdquo; in the
&lt;a href="/documentation/input_deck/input_deck_control"> control
block&lt;/a> to the number of the output
dump from which you want the code to restart. Because of the way in
which the code is written you cannot guarantee that the code will
successfully restart from any output dump. To restart properly, the
following &lt;em>&lt;code>must&lt;/code>&lt;/em> have been dumped&lt;/p>
&lt;ul>
&lt;li>Particle positions.&lt;/li>
&lt;li>Particle momenta.&lt;/li>
&lt;li>Particle species.&lt;/li>
&lt;li>Particle weights.&lt;/li>
&lt;li>Relevant parts of the electric field (If for example it is known
that ez == 0 then it is not needed).&lt;/li>
&lt;li>Relevant parts of the magnetic field.&lt;/li>
&lt;/ul>
&lt;p>It is possible to use the manual particle control part of the initial
conditions to make changes to a restarted initial condition after the
restart dump is loaded. The output files don&amp;rsquo;t include all of the
information needed to restart the code fully since some of this
information is contained in the input deck. However, a restart dump also
contains a full copy of the input deck used and this can be unpacked
before running the code.
If specific &amp;ldquo;restart&amp;rdquo; dumps are specified in the input deck, or the
&amp;ldquo;force_final_to_be_restartable&amp;rdquo; flag is set then in some cases the
output is forced to contain enough information to output all the data.
These restart dumps can be very large, and also override the &amp;ldquo;dumpmask&amp;rdquo;
parameter specified for a species and output the data for that species
anyway.&lt;/p>
&lt;h1 id="parameterising_input_decks">Parameterising input decks&lt;/h1>
&lt;p>The simplest way to allow someone to use EPOCH as a black box is to give
them the input.deck files that control the setup and initial conditions
of the code. The input deck is simple enough that a quick read through
of the relevant section of the manual should make it fairly easy for a
new user to control those features of the code, but the initial
conditions can be complex enough to be require significant work on the
part of an unfamiliar user to understand. In this case, it can be
helpful to use the ability to specify constants in an input deck to
parameterise the file. So, to go back to a slight variation on an
earlier example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = s1
# First set number_density in the range 0-&amp;amp;gt;1
# Cut down number_density in x direction
number_density = if ((x gt -1) and (x lt 1), 1.0, 0.2)
# Cut down number_density in y direction
number_density = if ((y gt -1) and (y lt 1), number_density(s1), 0.2)
# Multiply number_density by real particle number density
number_density = number_density(s1) * 100.0
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * 100.0
end:species
begin:species
name = s2
# Just copy the number_density for species s1
number_density = number_density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * 100.0
end:species
&lt;/code>&lt;/pre>
&lt;p>The particle number density (100.0) is hard coded into the deck file in
several places. It would be easier if this was given to a new user as:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
particle_number_density = 100.0 # Particle number density
end:constant
begin:species
name = s1
# First set number_density in the range 0-&amp;amp;gt;1
# Cut down number_density in x direction
number_density = if ((x gt -1) and (x lt 1), 1.0, 0.2)
# Cut down number_density in y direction
number_density = if ((y gt -1) and (y lt 1), number_density(s1), 0.2)
# Multiply number_density by real particle number density
number_density = number_density(s1) * particle_number_density
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
begin:species
name = s2
# Just copy the number density for species s1
number_density = number_density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
&lt;/code>&lt;/pre>
&lt;p>It is also possible to parameterise other elements of initial conditions
in a similar fashion. This is generally a good idea, since it makes the
initial conditions easier to read an maintain.&lt;/p>
&lt;h1 id="using_spatially_varying_functions_to_further_parameterise_initial_conditions">Using spatially varying functions to further parameterise initial conditions&lt;/h1>
&lt;p>Again, this is just a readability change to the normal input.deck file,
but it also makes changing and understanding the initial conditions
rather simpler. In this case, entire parts of the initial conditions are
moved into a spatially varying constant in order to make changing them
at a later date easier. For example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
particle_number_density = 100.0 # Particle number density
profile_x = if((x gt -1) and (x lt 1), 1.0, 0.2)
profile_y = if((y gt -1) and (y lt 1), 1.0, 0.2)
end:constant
begin:species
name = s1
# Multiply number_density by real particle number density
number_density = particle_number_density * profile_x * profile_y
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
begin:species
name = s2
# Just copy the number_density for species s1
number_density = number_density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
&lt;/code>&lt;/pre>
&lt;p>This creates the same output as before. It is now trivial to modify the
profiles later. For example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
particle_number_density = 100.0 # Particle number density
profile_x = gauss(x, 0.0, 1.0)
profile_y = gauss(y, 0.0, 1.0)
end:constant
begin:species
name = s1
# Multiply number_density by real particle number density
number_density = particle_number_density * profile_x * profile_y
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
begin:species
name = s2
# Just copy the number density for species s1
number_density = number_density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
&lt;/code>&lt;/pre>
&lt;p>This changes the code to run with a Gaussian density profile rather then
a step function. Again, this can be extended as far as required.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Using delta f</title><link>/documentation/code_details/using_delta_f.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/code_details/using_delta_f.html</guid><description>&lt;p>To help reduce the impact of numerical noise in certain simulations, the
delta-f method may be used in for specified particle species. The
delta-f method effectively subtracts a background distribution $f_0$
when calculating currents due to the motion of markers; when the
particle distribution function $f$ is close to $f_0$, this substantially
reduces the statistical noise in the currents. Only current deposition
is implemented differently, and the equations of motion of the markers
are not modified in this delta-f approach.&lt;/p>
&lt;p>The component of the currents associated with the background $f_0$ may
in principle be calculated analytically, but the delta-f
implementation in EPOCH assumes (but does not check) that the total
background current is zero.&lt;/p>
&lt;p>In order to use the delta-f method EPOCH must be compiled with the
#DELTAF_METHOD precompiler flag enabled. Standard input simulations
are not affected by switching on this flag, but the user may then choose
to treat certain species in the plasma using the delta-f method. To
enable delta-f calculation for a species the background distribution
function $f_0$ must be defined in the input block. $f_0$ is specified
using variables similar to those used to specify $f$. The current
implementation of delta-f allows only a spatially uniform drifting
Maxwellian $f_0$, with temperatures $T_x$, $T_y$ and $T_z$ allowed to
differ from each other. In 3D, for the case where the temperature in
each direction is equal, we have
$f_0 = n_0 (2 \pi T)^{-3/2} \exp\left(\frac{m (\mathbf{v} - \mathbf{v_d})^2}{2 k_B T } \right).$&lt;/p>
&lt;p>The parameters number_density_back, temp(x,y,z)_back and
drift(x,y,z)_back in each species specification in the input deck set
$f_0$. number_density_back=0 is the default and is equivalent to not
using the delta-f method.&lt;/p>
&lt;p>For example, the electron species component of an input deck solved
using delta-f might be written:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = electron
charge = -1.0
mass = 1.0
frac = 0.3
temp = 1e8
temp_back = 1e8
number_density = 1e20
number_density_back = 1e20
end:species
&lt;/code>&lt;/pre>
&lt;p>Additional distribution function diagnostic options are supplied for the
Delta-f version. Standard diagnostics work as usual based on the total
distribution function $f$ but it is also possible to output the Delta-f
component of the distribution functions by adding output_deltaf = T in
dist_fn components of the input deck.&lt;/p>
&lt;p>An example input deck is supplied in the 1D version as
twostream_deltaf.deck. This uses the delta-f method to solve the
weak-beam two stream instability. The bulk plasma species is solved
using the delta-f method, since this evolves very little, and mostly
supports the Langmuir waves that the weak beam interacts with. The
relative change to the beam species is large, and the standard PIC
method, rather than delta-f is used to model this species. A comparison
of the electric field diagnostics between standard and delta-f
simulations shows a substantial decrease in noise.&lt;/p>
&lt;p>The rest of this page features slides detailing the model:&lt;/p>
&lt;p>&lt;img src="page_0000.png" alt="Delta_f method">
&lt;img src="page_0001.png" alt="Delta_f method">
&lt;img src="page_0002.png" alt="Delta_f method">
&lt;img src="page_0003.png" alt="Delta_f method">
&lt;img src="page_0004.png" alt="Delta_f method">
&lt;img src="page_0005.png" alt="Delta_f method">
&lt;img src="page_0006.png" alt="Delta_f method">
&lt;img src="page_0007.png" alt="Delta_f method">
&lt;img src="page_0008.png" alt="Delta_f method">
&lt;img src="page_0009.png" alt="Delta_f method">
&lt;img src="page_0010.png" alt="Delta_f method">
&lt;img src="page_0011.png" alt="Delta_f method">
&lt;img src="page_0012.png" alt="Delta_f method">
&lt;img src="page_0013.png" alt="Delta_f method">
&lt;img src="page_0014.png" alt="Delta_f method">
&lt;img src="page_0015.png" alt="Delta_f method">
&lt;img src="page_0016.png" alt="Delta_f method">
&lt;img src="page_0017.png" alt="Delta_f method">
&lt;img src="page_0018.png" alt="Delta_f method">
&lt;img src="page_0019.png" alt="Delta_f method">
&lt;img src="page_0020.png" alt="Delta_f method">&lt;/p></description></item><item><title>Previous versions</title><link>/documentation/code_details/previous_versions.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/code_details/previous_versions.html</guid><description>&lt;h1 id="changes_between_version_3" class="1_and_4 0">Changes between version 3.1 and 4.0&lt;/h1>
&lt;h1 id="changes_to_the_makefile">Changes to the Makefile&lt;/h1>
&lt;p>Some changes have been made to the Makefile. These are documented
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a>.
The following compile-time defines have been added to the Makefile:&lt;/p>
&lt;ul>
&lt;li>NO_IO&lt;/li>
&lt;li>PARTICLE_ID&lt;/li>
&lt;li>PARTICLE_ID4&lt;/li>
&lt;li>COLLISIONS_TEST&lt;/li>
&lt;li>PHOTONS&lt;/li>
&lt;li>TRIDENT_PHOTONS&lt;/li>
&lt;li>PREFETCH&lt;/li>
&lt;/ul>
&lt;p>The following compile-time defines have been removed from the Makefile:&lt;/p>
&lt;ul>
&lt;li>COLLISIONS&lt;/li>
&lt;li>SPLIT_PARTICLES_AFTER_PUSH&lt;/li>
&lt;li>PARTICLE_IONISE&lt;/li>
&lt;/ul>
&lt;h1 id="major_features_and_new_blocks_added_to_the_input_deck">Major features and new blocks added to the input deck&lt;/h1>
&lt;ul>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_boundaries#cpml_boundary_conditions">CPML boundary
conditions&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_boundaries#thermal_boundary_conditions">Thermal boundary
conditions&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_collisions">Collisions&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_qed">QED&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_subset">Subsets&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_species#ionisation">Ionisation&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_output_block#single-precision_output">Single-precision
output&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_output_block#multiple_output_blocks">Multiple output
blocks&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_species#particle_migration_between_species">Particle
migration&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="additional_output_block_parameters">Additional output block parameters&lt;/h1>
&lt;p>The following parameters have also been added to the &amp;ldquo;output&amp;rdquo; block (see
&lt;a href="/documentation/input_deck/input_deck_output#directives">here&lt;/a>):&lt;/p>
&lt;ul>
&lt;li>dump_first&lt;/li>
&lt;li>dump_last&lt;/li>
&lt;li>force_first_to_be_restartable&lt;/li>
&lt;li>ejected_particles&lt;/li>
&lt;li>absorption&lt;/li>
&lt;li>id&lt;/li>
&lt;li>name&lt;/li>
&lt;li>restartable&lt;/li>
&lt;/ul>
&lt;h1 id="other_additions_to_the_input_deck">Other additions to the input deck&lt;/h1>
&lt;ul>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_species">npart_per_cell&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_dist_fn">dir_{xy,yz,zx}_angle&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_control">particle_tstart&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/documentation/input_deck/input_deck_species">identify&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Finally, the input deck now has a method for writing continuation lines.
If the deck contains a &amp;ldquo;&amp;quot; character then the rest of the line is
ignored and the next line becomes a continuation of the current one.&lt;/p>
&lt;h1 id="changes_between_version_4" class="0_and_4 3">Changes between version 4.0 and 4.3&lt;/h1>
&lt;h1 id="changes_to_the_makefile_1">Changes to the Makefile&lt;/h1>
&lt;p>Some changes have been made to the Makefile. These are documented
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a> .
The following compile-time define has been added to the Makefile:&lt;/p>
&lt;ul>
&lt;li>MPI_DEBUG&lt;/li>
&lt;/ul>
&lt;p>The following compile-time define has been removed from the Makefile:&lt;/p>
&lt;ul>
&lt;li>FIELD_DEBUG&lt;/li>
&lt;/ul>
&lt;h1 id="additions_to_the_input_deck">Additions to the input deck&lt;/h1>
&lt;p>The following parameters have been added to the
&lt;a href="/documentation/input_deck/input_deck_control">&amp;ldquo;control&amp;rdquo;&lt;/a> block of the input
deck:&lt;/p>
&lt;ul>
&lt;li>nproc{x,y,z}&lt;/li>
&lt;li>smooth_currents&lt;/li>
&lt;li>field_ionisation&lt;/li>
&lt;li>use_exact_restart&lt;/li>
&lt;li>allow_cpu_reduce&lt;/li>
&lt;li>check_stop_file_frequency&lt;/li>
&lt;li>stop_at_walltime&lt;/li>
&lt;li>stop_at_walltime_file&lt;/li>
&lt;li>simplify_deck&lt;/li>
&lt;li>print_constants&lt;/li>
&lt;li>The &amp;ldquo;restart_snapshot&amp;rdquo; parameter now accepts filenames&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the
&lt;a href="/documentation/input_deck/input_deck_output_block">&amp;ldquo;output&amp;rdquo;&lt;/a> block of the input
deck:&lt;/p>
&lt;ul>
&lt;li>disabled&lt;/li>
&lt;li>time_start&lt;/li>
&lt;li>time_stop&lt;/li>
&lt;li>nstep_start&lt;/li>
&lt;li>nstep_stop&lt;/li>
&lt;li>dump_at_times&lt;/li>
&lt;li>dump_at_nsteps&lt;/li>
&lt;li>dump_cycle&lt;/li>
&lt;li>dump_cycle_first_index&lt;/li>
&lt;li>filesystem&lt;/li>
&lt;li>file_prefix&lt;/li>
&lt;li>rolling_restart&lt;/li>
&lt;li>particle_energy&lt;/li>
&lt;li>relativistic_mass&lt;/li>
&lt;li>gamma&lt;/li>
&lt;li>total_energy_sum&lt;/li>
&lt;li>optical_depth&lt;/li>
&lt;li>qed_energy&lt;/li>
&lt;li>trident_optical_depth&lt;/li>
&lt;li>The default value of &amp;ldquo;dump_first&amp;rdquo; is now &amp;ldquo;T&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>The following parameter has been added to the
&lt;a href="/documentation/input_deck/input_deck_collisions">&amp;ldquo;collisions&amp;rdquo;&lt;/a> block of the
input deck:&lt;/p>
&lt;ul>
&lt;li>collisional_ionisation&lt;/li>
&lt;/ul>
&lt;p>The following parameter has been added to the
&lt;a href="/documentation/input_deck/input_deck_qed">&amp;ldquo;qed&amp;rdquo;&lt;/a> block of the input deck:&lt;/p>
&lt;ul>
&lt;li>use_radiation_reaction&lt;/li>
&lt;/ul>
&lt;p>The following parameter has been added to the
&lt;a href="/documentation/input_deck/input_deck_species">&amp;ldquo;species&amp;rdquo;&lt;/a> block of the input
deck:&lt;/p>
&lt;ul>
&lt;li>immobile&lt;/li>
&lt;/ul>
&lt;p>The following parameters were changed in the
&lt;a href="/documentation/input_deck/input_deck_laser">&amp;ldquo;laser&amp;rdquo;&lt;/a> block of the input deck:&lt;/p>
&lt;ul>
&lt;li>The &amp;ldquo;phase&amp;rdquo; parameter can now be time varying&lt;/li>
&lt;li>The &amp;ldquo;profile&amp;rdquo; parameter can now be time varying&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the list of pre-defined
&lt;a href="/documentation/code_details/maths_parser#constants">constants&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>nproc_{x,y,z}&lt;/li>
&lt;li>nsteps&lt;/li>
&lt;li>t_end&lt;/li>
&lt;li>cc&lt;/li>
&lt;/ul>
&lt;p>There has also been a new
&lt;a href="/documentation/input_deck/input_deck_output_global">&amp;ldquo;output_global&amp;rdquo;&lt;/a> block
added to the input deck.&lt;/p>
&lt;h1 id="changes_in_behaviour_which_are_not_due_to_changes_in_the_input_deck">Changes in behaviour which are not due to changes in the input deck&lt;/h1>
&lt;ul>
&lt;li>The species &amp;ldquo;drift&amp;rdquo; property is now applied to particles whilst the
moving window model is active. In previous versions of the code,
this property was ignored once the moving window began.&lt;/li>
&lt;li>Ionisation species now inherit their &amp;ldquo;dumpmask&amp;rdquo;. See
&lt;a href="/documentation/input_deck/input_deck_species#ionisation">here&lt;/a> for details.&lt;/li>
&lt;li>Default values for ignorable directions were added. This change
allows submitting 3D or 2D input decks to a 1D version of and 3D
input decks to a 2D version of . Any references to y/z will be set
equal to zero unless overridden by a deck constant. Other y/z values
also assume sensible defaults, eg. 1 grid cell, 1 metre thick, etc.&lt;/li>
&lt;li>Automatic byte swapping is carried out by the SDF library. The
library now checks the endianness of the SDF file and byte-swaps the
data if required.&lt;/li>
&lt;li>&amp;ldquo;qed&amp;rdquo; blocks may now be present even if the code was not compiled
using the &amp;ldquo;-DPHOTONS&amp;rdquo; flag. The code will only halt if &amp;ldquo;use_qed=T&amp;rdquo;
inside the &amp;ldquo;qed&amp;rdquo; block.&lt;/li>
&lt;li>The code now checks for the Data directory in a file named
&amp;ldquo;USE_DATA_DIRECTORY&amp;rdquo; before prompting at the command-line. This
allows the code to be run without waiting for input at the
command-line.&lt;/li>
&lt;li>The field and particle grids are now automatically written to SDF
output files if they are needed.&lt;/li>
&lt;li>The Data directory may now contain a &amp;lsquo;&lt;code>/&lt;/code>&amp;rsquo; character.&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="3_and_4 8">Changes between version 4.3 and 4.8&lt;/h1>
&lt;h1 id="changes_to_the_makefile_2">Changes to the Makefile&lt;/h1>
&lt;p>Some changes have been made to the Makefile. These are documented
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a>.
The following compile-time define has been added to the Makefile:&lt;/p>
&lt;ul>
&lt;li>PER_SPECIES_WEIGHT&lt;/li>
&lt;li>NO_TRACER_PARTICLES&lt;/li>
&lt;li>NO_PARTICLE_PROBES&lt;/li>
&lt;li>PARSER_CHECKING&lt;/li>
&lt;/ul>
&lt;p>The following compile-time define has been removed from the Makefile:&lt;/p>
&lt;ul>
&lt;li>PER_PARTICLE_WEIGHT&lt;/li>
&lt;li>TRACER_PARTICLES&lt;/li>
&lt;li>PARTICLE_PROBES&lt;/li>
&lt;/ul>
&lt;h1 id="additions_to_the_input_deck_1">Additions to the input deck&lt;/h1>
&lt;p>The following parameters have been added to the
&lt;a href="/documentation/input_deck/input_deck_control">&amp;ldquo;control&amp;rdquo;&lt;/a> block of the input
deck:&lt;/p>
&lt;ul>
&lt;li>allow_missing_restart&lt;/li>
&lt;li>print_eta_string&lt;/li>
&lt;li>n_zeros&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the
&lt;a href="/documentation/input_deck/input_deck_output_block">&amp;ldquo;output&amp;rdquo;&lt;/a> block of the input
deck):&lt;/p>
&lt;ul>
&lt;li>weight (synonym for particle_weight)&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the
&lt;a href="/documentation/input_deck/input_deck_output_global">&amp;ldquo;output_global&amp;rdquo;&lt;/a> block of
the input deck:&lt;/p>
&lt;ul>
&lt;li>dump_first_after_restart&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the
&lt;a href="/documentation/input_deck/input_deck_subset">&amp;ldquo;subset&amp;rdquo;&lt;/a> block of the input deck:&lt;/p>
&lt;ul>
&lt;li>skip, skip_&lt;code>x,y,z&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="8_and_4 9">Changes between version 4.8 and 4.9&lt;/h1>
&lt;h1 id="new_capabilities">New capabilities&lt;/h1>
&lt;p>Version 4.9 adds significant new capabilities as follows:&lt;/p>
&lt;ul>
&lt;li>delta-f version: particle distributions can be expressed as
$f_0 + f_1$ where $f_0$ is a specified background plasma and all
simulation particles are used to describe the $f_1$ component,
documented in .&lt;/li>
&lt;li>selectable field solvers: 3 new solvers have been added for fields,
fully documented in .&lt;/li>
&lt;/ul>
&lt;h1 id="changes_to_the_makefile_3">Changes to the Makefile&lt;/h1>
&lt;p>Some changes have been made to the Makefile. These are documented in .
The following compile-time define has been added to the Makefile:&lt;/p>
&lt;ul>
&lt;li>DELTAF_METHOD&lt;/li>
&lt;li>DELTAF_DEBUG&lt;/li>
&lt;li>USE_ISATTY&lt;/li>
&lt;/ul>
&lt;h1 id="additions_to_the_input_deck_2">Additions to the input deck&lt;/h1>
&lt;p>The following alterations were made to the input deck:&lt;/p>
&lt;ul>
&lt;li>ioniz* (with a &amp;ldquo;z&amp;rdquo;) aliases have been added for ionis* keywords.&lt;/li>
&lt;li>y and z parameters can now appear in the input deck in EPOCH 1D and
2D.&lt;/li>
&lt;/ul>
&lt;p>A new deck block has been added. The particles_from_file block allows
loading of custom particle data from raw binary data files. See for
details. This block accepts the following parameters:&lt;/p>
&lt;ul>
&lt;li>species&lt;/li>
&lt;li>{xyz}_data&lt;/li>
&lt;li>w_data&lt;/li>
&lt;li>{xyz}_data&lt;/li>
&lt;li>id{4,8}_data&lt;/li>
&lt;li>offset&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the &amp;ldquo;control&amp;rdquo; block of the
input deck (see ):&lt;/p>
&lt;ul>
&lt;li>maxwell_solver&lt;/li>
&lt;li>use_current_correction&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the &amp;ldquo;species&amp;rdquo; block of the
input deck (see ):&lt;/p>
&lt;ul>
&lt;li>maxwell_solver&lt;/li>
&lt;li>number_density_back&lt;/li>
&lt;li>drift_{x,y,z}_back&lt;/li>
&lt;li>temp_{x,y,z}_back&lt;/li>
&lt;li>temp_{x,y,z}_back_ev&lt;/li>
&lt;li>temp_back&lt;/li>
&lt;li>temp_back_ev&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the &amp;ldquo;dist_fn' block of the
input deck (see ):&lt;/p>
&lt;ul>
&lt;li>dir may now take the value mod_p&lt;/li>
&lt;li>restrict_mod_p&lt;/li>
&lt;/ul>
&lt;h1 id="changes_not_resulting_from_changes_to_the_deck">Changes not resulting from changes to the deck&lt;/h1>
&lt;ul>
&lt;li>Lasers can be specified with time-varying frequency profile.&lt;/li>
&lt;li>The existing subset blocks can now be applied to field and derived
grid variables. If spatial restrictions are used, subsections will
be output, along with a corresponding grid. Note that these are not
compatible with the &amp;ldquo;skip&amp;rdquo; parameter to subset blocks.&lt;/li>
&lt;li>The dist_fn block &amp;ldquo;range&amp;rdquo; keyword is now respected for spatial
directions, allowing a spatial subset of the distribution function
to be output directly.&lt;/li>
&lt;li>Some corrections were applied to calculation of thermal boundary
conditions for particles.&lt;/li>
&lt;li>The load balancer may now be disabled by setting a 0 or negative
threshold.&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="9_and_4 10">Changes between version 4.9 and 4.10&lt;/h1>
&lt;h1 id="new_capabilities_1">New capabilities&lt;/h1>
&lt;p>Version 4.10 adds the following new capabilities:&lt;/p>
&lt;ul>
&lt;li>Time varying particle injectors. See
&lt;a href="/documentation/input_deck/input_deck_injector">
here&lt;/a>&lt;/li>
&lt;li>Per-species particle boundaries. You can now specify bc_x_min and
bc_x_max to a species block. This overrides the global boundaries
for that species. See
&lt;a href="/documentation/input_deck/input_deck_species#species_boundary_conditions">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;particles_per_cell&amp;rdquo; output diagnostic. See
&lt;a href="/documentation/input_deck/input_deck_output_block#derived_variables">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="10_and_4 11">Changes between version 4.10 and 4.11&lt;/h1>
&lt;h1 id="new_capabilities_2">New capabilities&lt;/h1>
&lt;p>Version 4.11 adds the following new capabilities:&lt;/p>
&lt;ul>
&lt;li>Added time dependent moving window. No new input deck parameters
have been added, but it is now possible to specify &amp;ldquo;window_v_x&amp;rdquo; to
be a function that varies in time. See
&lt;a href="/documentation/input_deck/input_deck_window">here&lt;/a>&lt;/li>
&lt;li>If &amp;ldquo;print_constants=T&amp;rdquo; in the control block (see
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>) deck constants are now
output to a separate file named &amp;ldquo;const.status&amp;rdquo;. This allows for
easier post-processing.&lt;/li>
&lt;li>Added COMPILER=auto option to automatically detect compiler. See
&lt;a href="/documentation/basic_usage/compiling">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>The following correction has been made:&lt;/p>
&lt;ul>
&lt;li>Fractional numbers of particles-per-cell now function as expected
when used in conjunction with the moving window.&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="11_and_4 12">Changes between version 4.11 and 4.12&lt;/h1>
&lt;h1 id="new_capabilities_3">New capabilities&lt;/h1>
&lt;p>Version 4.12 adds the following new capabilities:&lt;/p>
&lt;ul>
&lt;li>Added &amp;ldquo;average_weight&amp;rdquo; output diagnostic. See
&lt;a href="/documentation/input_deck/input_deck_output_block#derived_variables">here&lt;/a>&lt;/li>
&lt;li>Removed the &amp;ldquo;PARTICLE_COUNT_UPDATE&amp;rdquo; Makefile flag and replaced it
with a &amp;ldquo;use_particle_count_update&amp;rdquo; parameter in the control
block. See
&lt;a href="/documentation/input_deck/input_deck_control#basics">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;use_flux_maxwellian&amp;rdquo; option to the &amp;ldquo;injector&amp;rdquo; block. See
&lt;a href="/documentation/input_deck/input_deck_injector#keys">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;lehe_{x,y,z}&amp;rdquo; flags to the &amp;ldquo;maxwell_solver&amp;rdquo; option in the
control block. See
&lt;a href="/documentation/input_deck/input_deck_control#maxwell_solvers">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;use_accurate_n_zeros&amp;rdquo; control block parameter. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;custom&amp;rdquo; flag to the &amp;ldquo;maxwell_solver&amp;rdquo; option in the control
block. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a> and
&lt;a href="/documentation/input_deck/input_deck_control#stencil_block">here&lt;/a>&lt;/li>
&lt;li>Added the &amp;ldquo;WORK_DONE_INTEGRATED&amp;rdquo; Makefile flag and corresponding
dumpmask directives &amp;ldquo;work_{x,y,z}&amp;rdquo; and &amp;ldquo;work_{x,y,z}_total&amp;rdquo;.
These add a diagnostic for the work done on a particle by the
electric field. See
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a> and
&lt;a href="/documentation/input_deck/input_deck_output_block#particle_variables">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="12_and_4 14">Changes between version 4.12 and 4.14&lt;/h1>
&lt;h1 id="new_capabilities_4">New capabilities&lt;/h1>
&lt;p>Version 4.14 adds the following new capabilities:&lt;/p>
&lt;ul>
&lt;li>Added the &amp;ldquo;reset_walltime&amp;rdquo; flag to the control block. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Changed the default value of &amp;ldquo;print_eta_string&amp;rdquo; to &amp;ldquo;T&amp;rdquo; in the
control block.&lt;/li>
&lt;li>Added the ability to request an output dump at run time. See
&lt;a href="/documentation/input_deck/input_deck_control#requesting_output_dumps_at_run_time">here&lt;/a>&lt;/li>
&lt;li>Added the &amp;ldquo;window_stop_time&amp;rdquo; parameter to the window block. See
&lt;a href="/documentation/input_deck/input_deck_window">here&lt;/a>&lt;/li>
&lt;li>Added the &amp;ldquo;atan2&amp;rdquo; function to the maths parser. See
&lt;a href="/documentation/code_details/maths_parser#functions">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;dlb_maximum_interval&amp;rdquo; parameter to the control block. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;dlb_force_interval&amp;rdquo; parameter to the control block. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;balance_first&amp;rdquo; parameter to the control block. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Added y and z versions of the &amp;ldquo;bc_x_min_after_move&amp;rdquo; and
&amp;ldquo;bc_x_max_after_move&amp;rdquo; parameters to the window block. See
&lt;a href="/documentation/input_deck/input_deck_window">here&lt;/a>&lt;/li>
&lt;li>Added a &amp;ldquo;dump_at_walltimes&amp;rdquo; parameter to the output block. See
&lt;a href="/documentation/input_deck/input_deck_output_block#multiple_output_blocks">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;walltime_start&amp;rdquo; and &amp;ldquo;walltime_stop&amp;rdquo; parameters to the
output block and output_global block. See
&lt;a href="/documentation/input_deck/input_deck_output_block#directives">here&lt;/a> and
&lt;a href="/documentation/input_deck/input_deck_output_global">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;walltime_interval&amp;rdquo; parameter to the output block. See
&lt;a href="/documentation/input_deck/input_deck_output_block#multiple_output_blocks">here&lt;/a>&lt;/li>
&lt;li>Added the Higuera-Cary particle push. This can be enabled using the
&amp;ldquo;HC_PUSH&amp;rdquo; Makefile flag. See
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="14_and_4 15">Changes between version 4.14 and 4.15&lt;/h1>
&lt;ul>
&lt;li>Added averaging of &amp;ldquo;poynt_flux&amp;rdquo; and &amp;ldquo;ekflux&amp;rdquo; variables.&lt;/li>
&lt;li>The initial problem setup can now be load-balanced before any
particles are loaded. This enables some heavily imbalanced setups to
be run that were not previously possible.
&lt;ul>
&lt;li>Added the &amp;ldquo;use_pre_balance&amp;rdquo; flag to the control block. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Allow the load balancer to adjust the processor topology
&lt;ul>
&lt;li>Added the &amp;ldquo;use_optimal_layout&amp;rdquo; flag to the control block. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Added control block option &amp;ldquo;use_more_setup_memory&amp;rdquo; for
controlling the way that species are setup. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Added strided multipass digital current filtering (See
&lt;a href="/documentation/input_deck/input_deck_control#strided_current_filtering">here&lt;/a>).
This adds the following flags to the control block.
&lt;ul>
&lt;li>smooth_iterations&lt;/li>
&lt;li>smooth_compensation&lt;/li>
&lt;li>smooth_strides&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Added persistent subsets. See
&lt;a href="/documentation/input_deck/input_deck_subset">here&lt;/a>. This adds the following
flags to the subset block
&lt;ul>
&lt;li>persist_start_time&lt;/li>
&lt;li>persist_start_step&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Added loading of relativistic particle species using the
Maxwell-Jüttner distribution. See
&lt;a href="/documentation/input_deck/input_deck_species#maxwell_juttner_distributions">here&lt;/a>.
This adds the following flags to the species block
&lt;ul>
&lt;li>use_maxwell_juttner&lt;/li>
&lt;li>fractional_tail_cutoff&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Added loading of particle species using an arbitrary distribution
function for sampling the momentum components. See
&lt;a href="/documentation/input_deck/input_deck_species#arbitrary_distribution_functions">here&lt;/a>.
This adds the following flags to the species block
&lt;ul>
&lt;li>dist_fn&lt;/li>
&lt;li>dist_fn_p{x,y,z}_range&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Added &amp;ldquo;temperature_{x,y,z}&amp;rdquo; derived output variables to the output
block. See
&lt;a href="/documentation/input_deck/input_deck_output_block#derived_variables">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="15_and_4 16">Changes between version 4.15 and 4.16&lt;/h1>
&lt;ul>
&lt;li>
&lt;dl>
&lt;dt>Added &amp;ldquo;number_density&amp;rdquo; aliases for &amp;ldquo;density&amp;rdquo; in the species and&lt;/dt>
&lt;dt>injector blocks (see
&lt;a href="/documentation/input_deck/input_deck_species">here&lt;/a> and&lt;/dt>
&lt;dt>
&lt;a href="/documentation/input_deck/input_deck_injector">here&lt;/a>).&lt;/dt>
&lt;dd>
&lt;p>These aliases include:&lt;/p>
&lt;/dd>
&lt;/dl>
&lt;ul>
&lt;li>number_density for density&lt;/li>
&lt;li>promote_number_density for promote_density&lt;/li>
&lt;li>demote_number_density for demote_density&lt;/li>
&lt;li>number_density_min for density_min&lt;/li>
&lt;li>number_density_max for density_max&lt;/li>
&lt;li>number_density_back for density_back&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Replaced &amp;ldquo;USE_ISATTY&amp;rdquo; Makefile flag with &amp;ldquo;NO_USE_ISATTY&amp;rdquo;. See
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Added &amp;ldquo;NO_MPI3&amp;rdquo; Makefile flag. See
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Added a &amp;ldquo;zero_current&amp;rdquo; alias for &amp;ldquo;tracer&amp;rdquo; in the species blocks.
See
&lt;a href="/documentation/input_deck/input_deck_species">here&lt;/a>. The use of &amp;ldquo;tracer&amp;rdquo;
has now been deprecated and will be removed in version 5.0. At that
time, the compiler flag will also be renamed.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>IDL or GDL</title><link>/documentation/visualising_output/visualising_sdf_files_with_idl_or_gdl.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/visualising_output/visualising_sdf_files_with_idl_or_gdl.html</guid><description>&lt;h1 id="using_idl_to_visualise_data">Using IDL to visualise data&lt;/h1>
&lt;p>The EPOCH distribution comes with procedures for loading and inspecting
SDF self-describing data files. The IDL routines are held in the
&lt;code>SDF/IDL/&lt;/code> directory. There is also a procedure named
&lt;code>Start.pro&lt;/code> in each of the &lt;code>epoch\*d/&lt;/code> directories
which is used to set up the IDL environment.&lt;/p>
&lt;p>To load data into IDL, navigate to one of the base directories (eg.
&lt;code>epoch/epoch2d/&lt;/code> where &lt;code>epoch/&lt;/code> is the directory in which you have
checked out the git repository) and type the following:&lt;/p>
&lt;pre>&lt;code>$&amp;amp;gt; idl Start.pro
IDL Version 8.1 (linux x86_64 m64). (c) 2011, ITT Visual Information Solutions
Installation number: .
+Licensed for use by: STAR404570-5University of Warwick
.
% Compiled module: TRACKEX_EVENT.
% Compiled module: ISOPLOT.
% Compiled module: READVAR.
% Compiled module: LOADSDFFILE.
% Compiled module: SDFHANDLEBLOCK.
% Compiled module: SDFGETPLAINMESH.
% Compiled module: SDFGETLAGRANMESH.
% Compiled module: SDFGETPOINTMESH.
% Compiled module: SDFGETPLAINVAR.
% Compiled module: SDFGETPOINTVAR.
% Compiled module: SDFGETCONSTANT.
% Compiled module: SDFCHECKNAME.
% Compiled module: INIT_SDFHELP.
% Compiled module: GETDATA.
% Compiled module: GETSTRUCT.
% Compiled module: EXPLORE_DATA.
% Compiled module: EXPLORE_STRUCT.
% Compiled module: LIST_VARIABLES.
% Compiled module: QUICK_VIEW.
% Compiled module: GET_WKDIR.
% Compiled module: SET_WKDIR.
% Compiled module: INIT_STARTPIC.
% Compiled module: INIT_WIDGET.
% Compiled module: GENERATE_FILENAME.
% Compiled module: COUNT_FILES.
% Compiled module: LOAD_RAW.
% Compiled module: GET_SDF_METATEXT.
% Compiled module: VIEWER_EVENT_HANDLER.
% Compiled module: EXPLORER_EVENT_HANDLER.
% Compiled module: XLOADCT_CALLBACK.
% Compiled module: LOAD_DATA.
% Compiled module: DRAW_IMAGE.
% Compiled module: LOAD_META_AND_POPULATE_SDF.
% Compiled module: CLEAR_DRAW_SURFACE.
% Compiled module: SDF_EXPLORER.
% Compiled module: EXPLORER_LOAD_NEW_FILE.
% Compiled module: CREATE_SDF_VISUALIZER.
% Compiled module: VIEWER_LOAD_NEW_FILE.
% LOADCT: Loading table RED TEMPERATURE
IDL&amp;amp;gt;
&lt;/code>&lt;/pre>
&lt;p>This starts up the IDL interpreter and loads in all of the libraries for
loading and inspecting SDF files.&lt;/p>
&lt;p>We begin by inspecting SDF file contents and finding out what variables
it contains. To do this we execute the &lt;strong>list variables&lt;/strong> procedure call
which is provided by the EPOCH IDL library.&lt;/p>
&lt;p>At each timestep for which EPOCH is instructed to dump a set of
variables a new data file is created. These files take the form
&lt;em>0000.sdf&lt;/em>. For each new dump the number is incremented. The procedure
call accepts up to two arguments. The first argument is mandatory and
specifies the number of the SDF file to be read in. This argument can be
any integer from 0 to 9999. It is padded with zeros and the suffix
&amp;lsquo;.sdf&amp;rsquo; appended to the end to give the name of the data file. eg. 99 ⇒
&amp;lsquo;0099.sdf&amp;rsquo;. The next arguments is optional. The keyword &lt;strong>wkdir&lt;/strong>
specifies the directory in which the data files are located. If this
argument is omitted then the currently defined global default is used.
Initially, this takes the value &lt;strong>Data&lt;/strong> but this can be changed using
the &lt;strong>set_wkdir&lt;/strong> procedure and queried using the &lt;strong>get_wkdir()&lt;/strong>
function.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; list_variables,0,&amp;amp;quot;Data&amp;amp;quot;
Available elements are
1) EX (ELECTRIC_FIELD) : 2D Plain variable
2) EY (ELECTRIC_FIELD) : 2D Plain variable
3) EZ (ELECTRIC_FIELD) : 2D Plain variable
4) BX (MAGNETIC_FIELD) : 2D Plain variable
5) BY (MAGNETIC_FIELD) : 2D Plain variable
6) BZ (MAGNETIC_FIELD) : 2D Plain variable
7) JX (CURRENT) : 2D Plain variable
8) JY (CURRENT) : 2D Plain variable
9) JZ (CURRENT) : 2D Plain variable
10) WEIGHT_ELECTRON (PARTICLES) : 1D Point variable
11) WEIGHT_PROTON (PARTICLES) : 1D Point variable
12) PX_ELECTRON (PARTICLES) : 1D Point variable
13) PX_PROTON (PARTICLES) : 1D Point variable
14) GRID_ELECTRON (GRID) : 2D Point mesh
15) GRID_PROTON (GRID) : 2D Point mesh
16) EKBAR (DERIVED) : 2D Plain variable
17) EKBAR_ELECTRON (DERIVED) : 2D Plain variable
18) EKBAR_PROTON (DERIVED) : 2D Plain variable
19) CHARGE_DENSITY (DERIVED) : 2D Plain variable
20) NUMBER_DENSITY (DERIVED) : 2D Plain variable
21) NUMBER_DENSITY_ELECTRON (DERIVED) : 2D Plain variable
22) NUMBER_DENSITY_PROTON (DERIVED) : 2D Plain variable
23) GRID (GRID) : 2D Plain mesh
24) GRID_EN_ELECTRON (GRID) : 1D Plain mesh
25) EN_ELECTRON (DIST_FN) : 3D Plain variable
26) GRID_X_EN_ELECTRON (GRID) : 2D Plain mesh
27) X_EN_ELECTRON (DIST_FN) : 3D Plain variable
28) GRID_X_PX_ELECTRON (GRID) : 2D Plain mesh
29) X_PX_ELECTRON (DIST_FN) : 3D Plain variable
IDL&amp;amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Each variable in the SDF self-describing file format is assigned a name
and a class as well as being defined by a given variable type. The
&amp;ldquo;list_variables&amp;rdquo; procedure prints out the variable name
followed by the variable&amp;rsquo;s class in parenthesis. Following the colon is
a description of the variable type.&lt;/p>
&lt;p>To retrieve the data, you must use the &lt;strong>getdata()&lt;/strong> function call. The
function must be passed a snapshot number, either as the first argument
or as a keyword parameter &amp;ldquo;snapshot&amp;rdquo;. It also accepts the wkdir as
either the second argument or the keyword parameter &amp;ldquo;wkdir&amp;rdquo;. If it is
omitted altogether, the current global default is used. Finally, it
accepts a list of variables or class of variables to load. Since it is a
function, the result must be assigned to a variable. The object returned
is an IDL data structure containing a list of named variables.&lt;/p>
&lt;p>To load either a specific variable or a class of variables, specify the
name prefixed by a forward slash. It should be noted here that the IDL
scripting language is not case sensitive so $P_x$ can be specified as
either &amp;ldquo;/Px&amp;rdquo; or &amp;ldquo;/px&amp;rdquo;.&lt;/p>
&lt;p>We will now load and inspect the &amp;ldquo;Grid&amp;rdquo; class, this time omitting the
optional &amp;ldquo;wkdir&amp;rdquo; parameter. This time we will load from the third dump
file generated by the EPOCH run, which is found in the file &lt;em>0002.sdf&lt;/em>
since the dump files are numbered starting from zero.&lt;/p>
&lt;h1 id="inspecting_data">Inspecting Data&lt;/h1>
&lt;pre>&lt;code>IDL&amp;amp;gt; gridclass = getdata(1,/grid)
IDL&amp;amp;gt; help,gridclass,/structures
** Structure &amp;amp;lt;22806408&amp;amp;gt;, 11 tags, length=536825024, data length=536825016, refs=1:
FILENAME STRING 'Data/0001.sdf'
TIMESTEP LONG 43
TIME DOUBLE 5.0705572e-15
GRID_ELECTRON STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
GRID_PROTON STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
GRID STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
X DOUBLE Array[1024]
Y DOUBLE Array[512]
GRID_EN_ELECTRON
STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
GRID_X_EN_ELECTRON
STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
GRID_X_PX_ELECTRON
STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
IDL&amp;amp;gt; help,gridclass.grid,/structures
** Structure &amp;amp;lt;1701168&amp;amp;gt;, 5 tags, length=12376, data length=12376, refs=2:
X DOUBLE Array[1025]
Y DOUBLE Array[513]
LABELS STRING Array[2]
UNITS STRING Array[2]
NPTS LONG Array[2]
&lt;/code>&lt;/pre>
&lt;p>Here we have used IDL&amp;rsquo;s built in &amp;ldquo;help&amp;rdquo; routine and passed the
&amp;ldquo;/structures&amp;rdquo; keyword which prints information about a structure&amp;rsquo;s
contents rather than just the structure itself.&lt;/p>
&lt;p>Since &amp;ldquo;Grid&amp;rdquo; is a class name, all variables of that class have been
loaded into the returned data structure. It is a nested type so many of
the variables returned are structures themselves and those variables may
contain structures of their own.&lt;/p>
&lt;p>The &amp;ldquo;Grid&amp;rdquo; variable itself contains x&amp;quot; and &amp;ldquo;y&amp;rdquo; arrays containing the $x$
and $y$ coordinates of the 2D cartesian grid. The other variables in
&amp;ldquo;Grid&amp;rdquo; the structure are metadata used to identify the type and
properties of the variable. In order to access the &amp;ldquo;Grid&amp;rdquo; variable
contained within the &amp;ldquo;gridclass&amp;rdquo; data structure we have used the &amp;ldquo;.&amp;rdquo;
operator. In a similar way, we would access the &amp;ldquo;x&amp;rdquo; array contained
within the &amp;ldquo;Grid&amp;rdquo; variable using the identifier &amp;ldquo;gridclass.grid.x&amp;rdquo;.&lt;/p>
&lt;h1 id="getting_help_in_idl">Getting Help in IDL&lt;/h1>
&lt;p>IDL is a fairly sophisticated scripting environment with a large library
of tools for manipulating data. Fortunately, it comes with a fairly
comprehensive array of documentation. This can be accessed by typing
&lt;strong>?&lt;/strong> at the IDL prompt.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; ?
% ONLINE_HELP: Starting the online help browser.
IDL&amp;amp;gt;
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="Idl_help.png" alt="The IDL help browser">&lt;/p>
&lt;p>The documentation is divided into books aimed at users or developers and
is fully searchable and cross indexed.&lt;/p>
&lt;h1 id="manipulating_and_plotting_data">Manipulating And Plotting Data&lt;/h1>
&lt;p>Once the data has been loaded from the SDF file we will want to extract
the specific data we wish to analyse, perhaps perform some mathematical
operations on it and then plot the results.&lt;/p>
&lt;p>To do this we must learn a few basic essentials about the IDL scripting
language. Since we are all familiar with the basic concepts shared by
all computer programming languages, I will just provide a brief overview
of the essentials and leave other details to the excellent on-line
documentation.&lt;/p>
&lt;p>IDL supports multidimensional arrays similar to those found in the
FORTRAN programming language. Whole array operations are supported such
as &amp;ldquo;5*array&amp;rdquo; to multiply every element of &amp;ldquo;array&amp;rdquo; by 5. Also matrix
operations such as addition and multiplication are supported.&lt;/p>
&lt;p>The preferred method for indexing arrays is to use brackets. It is
possible to use parenthesis instead but this usage is deprecated. Column
ordering is the same as that used by FORTRAN, so to access the
$(i,j,k)$th element of an array you would use &amp;ldquo;array[i,j,k]&amp;rdquo;. IDL
arrays also support ranges so &amp;ldquo;array[5:10,3,4]&amp;rdquo; will return a one
dimensional array with five elements. &amp;ldquo;array[5:*]&amp;rdquo; specifies elements
five to $n$ of an $n$ element array. &amp;ldquo;array[*,3]&amp;rdquo; picks out the third
row of an array.&lt;/p>
&lt;p>There are also a wide range of routines for querying and transforming
arrays of data. For example, finding minimum and maximum values,
performing FFTs, etc. These details can all be found by searching the
on-line documentation.&lt;/p>
&lt;p>Finally, IDL is a full programming language so you can write your own
functions and procedures for processing the data to suit your needs.&lt;/p>
&lt;h1 id="d_plotting_in_idl">1D Plotting in IDL&lt;/h1>
&lt;p>The most commonly performed plot and perhaps the most useful data
analysis tool is the 1D plot. In IDL, this is performed by issuing the
command &lt;strong>plot,x,y&lt;/strong> where &amp;ldquo;x&amp;rdquo; and &amp;ldquo;y&amp;rdquo; are one dimensional arrays of
equal length. For each element &amp;ldquo;x[i]&amp;rdquo; plotted on the $x$-axis the
corresponding value &amp;ldquo;y[i]&amp;rdquo; is plotted along the $y$-axis. As a simple
example:&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; plot,[1,2,3],[2,2,5]
&lt;/code>&lt;/pre>
&lt;p>Gives rise to the following plot:&lt;/p>
&lt;p>&lt;img src="Idl_simple_plot.png" alt="A simple IDL plot">&lt;/p>
&lt;p>As a more concrete example, we will now take a one-dimensional slice
through the 2D array &amp;ldquo;Number Density&amp;rdquo; read in from our SDF data file. In
this example we will give the $x$ and $y$ axes labels by passing extra
parameters to the &amp;ldquo;plot&amp;rdquo; routine. A full list of parameters can be found
in the on-line documentation. In this example we also make use of the
&amp;ldquo;$&amp;rdquo; symbol which is IDL&amp;rsquo;s line continuation character.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; data = getdata(0)
IDL&amp;amp;gt; plot,data.x,data.number_density[*,256],xtitle='x', $
IDL&amp;amp;gt; ytitle='number density'
&lt;/code>&lt;/pre>
&lt;p>This command generates the following plot:&lt;/p>
&lt;p>&lt;img src="Idl_plot.png" alt="A slice of a 2D array">&lt;/p>
&lt;h1 id="postscript_plots">Postscript Plots&lt;/h1>
&lt;p>The plots shown so far have just been screen-shots of the interactive
IDL plotting window. These are fairly low quality and could included as
figures in a paper.&lt;/p>
&lt;p>In order to generate publication quality plots, we must output to the
postscript device. IDL maintains a graphics context which is set using
&lt;strong>set plot&lt;/strong> the command. The two most commonly used output devices are
&amp;ldquo;x&amp;rdquo; which denotes the X-server and &amp;ldquo;ps&amp;rdquo; which is the postscript device.
Once the desired device has been selected, various attributes of its
behaviour can be altered using the &lt;strong>device&lt;/strong> procedure. For example, we
can set the output file to use for the postscript plot. By default, a
file with the name &amp;ldquo;idl.ps&amp;rdquo; is used.&lt;/p>
&lt;p>Note that this file is not fully written until the postscript device is
closed using the &lt;strong>device,/close&lt;/strong> command. When we have finished our
plot we can resume plotting to screen by setting the device back to &amp;ldquo;x&amp;rdquo;.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; set_plot,'ps'
IDL&amp;amp;gt; device,filename='out.ps'
IDL&amp;amp;gt; plot,data.x,data.number_density[*,256],xtitle='x', $
IDL&amp;amp;gt; ytitle='number density',charsize=1.5
IDL&amp;amp;gt; device,/close
IDL&amp;amp;gt; set_plot,'x'
&lt;/code>&lt;/pre>
&lt;p>This set of commands results in the following plot being written to a
file named &amp;ldquo;out.ps&amp;rdquo;.&lt;/p>
&lt;p>&lt;img src="Idl_ps_plot.png" alt="A simple PS plot">&lt;/p>
&lt;p>By default, IDL draws its own set of fonts called &amp;ldquo;Hershey vector
fonts&amp;rdquo;. Much better looking results can be obtained by using a
postscript font instead. These options are passed as parameters to the
&lt;strong>device&lt;/strong> procedure. More details can be found in the on-line
documentation under &amp;ldquo;Reference Guides $\Rightarrow$ IDL Reference Guide
$\Rightarrow$ Appendices $\Rightarrow$ Fonts&amp;rdquo;.&lt;/p>
&lt;h1 id="contour_plots_in_idl">Contour Plots in IDL&lt;/h1>
&lt;p>Whilst 1D plots are excellent tools for quantitive analysis of data, we
can often get a better qualitative overview of the data using 2D or 3D
plots.&lt;/p>
&lt;p>One commonly used plot for 2D is the contour plot. The aptly named
&lt;strong>contour,z,x,y&lt;/strong> procedure takes a 2D array of data values, &amp;ldquo;z&amp;rdquo;, and
plots them against $x$ and $y$ axes which are specified in the 1D &amp;ldquo;x&amp;rdquo;
and &amp;ldquo;y&amp;rdquo; arrays. The number of contour lines to plot is specified by the
&amp;ldquo;nlevels&amp;rdquo; parameter. If the &amp;ldquo;/fill&amp;rdquo; parameter is used then IDL will fill
each contour level with a solid colour rather than just drawing a line
at the contour value.&lt;/p>
&lt;p>The example given below plots a huge number of levels so that a smooth
looking plot is produced. &amp;ldquo;xstyle=1&amp;rdquo; requests that the $x$ axes drawn
exactly matches the data in the variable rather than just using a nearby
rounded value and similarly for &amp;ldquo;ystyle=1&amp;rdquo;.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; n=100
IDL&amp;amp;gt; levels=max(data.number_density)*findgen(n)/(n-1)
IDL&amp;amp;gt; colors=253.*findgen(n)/(n-1)+1
IDL&amp;amp;gt; contour,data.number_density,data.x,data.y,xstyle=1,ystyle=1, $
IDL&amp;amp;gt; levels=levels,/fill,c_colors=colors
&lt;/code>&lt;/pre>
&lt;p>Issuing these commands gives us the contour plot shown below. Note that
the colour table used is not the default one but has been constructed to
be similar to the one used by VisIt.&lt;/p>
&lt;p>&lt;img src="Idl_contour.png" alt="A simple contour plot">&lt;/p>
&lt;h1 id="shaded_surface_plots_in_idl">Shaded Surface Plots in IDL&lt;/h1>
&lt;p>Another method for visualising 2D datasets is to produce a 3D plot in
which the data is elevated in the $z$ direction by a height proportional
to its value. IDL has two versions of the surface plot. &lt;strong>surface&lt;/strong>
produces a wireframe plot and &lt;strong>shade surf&lt;/strong> produces a filled and
shaded one. As we can see from the following example, many of IDL&amp;rsquo;s
plotting routines accept the same parameters and keywords.&lt;/p>
&lt;p>The first command shown here, &lt;strong>loadct,3&lt;/strong>, asks IDL to load the third
colour table which is&amp;quot;RED_TEMPERATURE&amp;quot;.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; loadct,3
IDL&amp;amp;gt; shade_surf,data.number_density,data.x,data.y,xstyle=1, $
IDL&amp;amp;gt; ystyle=1,xtitle='x',ytitle='y',ztitle='number density',charsize=3
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="Idl_shade_surf.png" alt="A shaded surface plot">&lt;/p>
&lt;h1 id="interactive_plotting">Interactive Plotting&lt;/h1>
&lt;p>Finally, in recent versions of IDL (not GDL) it is now possible to
perform all of these plot types in an interactive graphical user
interface. The corresponding procedures are launched with the commands
&lt;strong>iplot&lt;/strong>, &lt;strong>icontour&lt;/strong> and &lt;strong>isurface&lt;/strong>.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; iplot,data.x,data.number_density[*,256]
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="Idl_iplot.png" alt="Interactive plotting">&lt;/p>
&lt;p>IDL is an extremely useful tool but it also comes with a fairly hefty
price tag. If you are not part of an organisation that will buy it for
you then you may wish to look into a free alternative. It is also a
proprietary tool and you may not wish to work within the restrictions
that this imposes.&lt;/p>
&lt;p>There are a number of free tools available which offer similar
functionality to that of IDL, occasionally producing superior results.&lt;/p>
&lt;p>For a simple drop-in replacement, the GDL project aims to be fully
compatible and works with the existing EPOCH IDL libraries after a
couple of small changes. Other tools worth investigating are
&lt;em>&lt;code>&amp;quot;yorick&amp;quot;&lt;/code>&lt;/em> and &lt;em>&lt;code>&amp;quot;python&amp;quot;&lt;/code>&lt;/em> with the
&lt;em>&lt;code>&amp;quot;SciPy&amp;quot;&lt;/code>&lt;/em> libraries. The python SDF reader documentation
will be added soon. At present there is no SDF reader for yorick but one
may be developed if there is sufficient demand.&lt;/p></description></item><item><title>LLNL VisIt</title><link>/documentation/visualising_output/visualising_sdf_files_with_llnl_visit.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/visualising_output/visualising_sdf_files_with_llnl_visit.html</guid><description>&lt;h1 id="using_visit_to_visualise_data">Using VisIt to visualise data&lt;/h1>
&lt;h1 id="llnl_visit">LLNL VisIt&lt;/h1>
&lt;p>LLNL&amp;rsquo;s VisIt software is a parallel data visualisation package (
&lt;a href="https://wci.llnl.gov/simulation/computer-codes/visit" target="_blank" rel="noopener">LLNL
VisIt&lt;/a>). EPOCH
comes with source code for the plug-in needed to allow VisIt to load the
SDF output files which are generated by EPOCH. There are full manuals
for VisIt which can be downloaded from the above link so no further
details will be given here. To build the plug-in, first ensure that the
visit binary is in the $PATH environment variable. Then simply type
&amp;ldquo;make visit&amp;rdquo; in one of the &lt;strong>epoch{1,2,3}d&lt;/strong> directories. For more
experienced users of VisIt, the xml file which is used to generate the
plug-in is supplied in the VisIt subdirectory, called &lt;strong>SDF2.xml&lt;/strong>.&lt;/p>
&lt;p>Whilst IDL is an excellent tool for visualising 1D and 2D datasets, it
is extremely poor when it comes to dealing with 3D data. For this
purpose, we recommend the use of the &lt;em>&lt;code>&amp;quot;VisIt&amp;quot;&lt;/code>&lt;/em>
visualisation tool.&lt;/p>
&lt;p>The other great advantage that VisIt has over IDL is the ability to
render in parallel, enabling the visualisation of huge datasets which
IDL would be incapable of dealing with.&lt;/p>
&lt;ul>
&lt;li>Initially developed by the Department of Energy (DOE) Advanced
Simulation and Computing Initiative (ASCI)&lt;/li>
&lt;li>Now developed and maintained by the Lawrence Livermore National
Laboratory along with a group of external contributors&lt;/li>
&lt;li>Written in C++ and supports python and Java interfaces&lt;/li>
&lt;li>Available for UNIX (Irix, Tru64, AIX, Linux, Solaris), Mac OS X
(10.3 - Current), and Windows platforms&lt;/li>
&lt;li>Open source and freely available under the BSD license&lt;/li>
&lt;li>Plots, operators and database readers are implemented as plugins
allowing the VisIt to be dynamically extended at run-time&lt;/li>
&lt;li>Powerful set of tools for manipulating, analysing and visualising 3D
datasets&lt;/li>
&lt;li>Parallel and distributed architecture for visualising huge data sets&lt;/li>
&lt;/ul>
&lt;h1 id="obtaining_and_installing_visit">Obtaining And Installing VisIt&lt;/h1>
&lt;p>Both the source code and pre-compiled binaries are available for
download from the projects web page which is found at the URL
&lt;a href="https://wci.llnl.gov/simulation/computer-codes/visit">https://wci.llnl.gov/simulation/computer-codes/visit&lt;/a>&lt;/p>
&lt;p>&lt;img src="Visit_web.png" alt="The LLNL VisIT website">&lt;/p>
&lt;p>There are full instructions for compiling the project from source code
along with build scripts written to help ease the process. However, this
is not recommended as it is an extremely large tool and the compilation
takes hours to complete. It is usually far easier to download a
pre-compiled binary which matches your system architecture.&lt;/p>
&lt;p>However, occasionally compilation may be a necessary step. Linux in
particular is a moving target and it is not always possible to find a
binary which matches the particular combination of libraries installed
on your system.&lt;/p>
&lt;p>The easiest way to install the VisIt tool is to ask the system
administrator to do it for you. However, this may not always be the best
option. The system in question may be run by someone who is not
concerned with your particular software needs or has insufficient skills
to deal with the task. In any case, VisIt has a fairly rapid release
schedule and you may find that some functionality you need is not
present in the version installed on the machine.&lt;/p>
&lt;p>Fortunately, for all these scenarios it is usually quite easy to install
a copy in your own home directory. Just find a binary on the web page
&lt;a href="https://wci.llnl.gov/codes/visit/executables.html">https://wci.llnl.gov/codes/visit/executables.html&lt;/a> which
closely matches your machine and download it. This can be unpacked into
your home directory with the command
&lt;code>tar xzf visit2_10_2.linux-x86_64-ubuntu14.tar.gz&lt;/code> . The actual name
of the file will vary depending on which version you downloaded. This
will unpack the VisIt binary into a subdirectory named &lt;code>visit/&lt;/code>. Now all
that is necessary is to add this to your search path. e.g.
&lt;code>export PATH=$HOME/visit/bin:$PATH&lt;/code>&lt;/p>
&lt;p>These instructions illustrate the steps required for installing your own
copy of VisIt when you have no other choice. VisIt is an extremely large
program, so if a version is already available then it is usually better
to use the installed version.&lt;/p>
&lt;p>The CSC machines at Warwick have a recent version of VisIt installed
which is available via the system. To make use of it you must first
issue the command &lt;code>module load visit&lt;/code>.&lt;/p>
&lt;h1 id="compiling_the_reader_plugin">Compiling The Reader Plugin&lt;/h1>
&lt;p>One piece of compilation which is almost always necessary is that of the
SDF reader plugin. This is shipped as source code in a subdirectory of
the repository. It is located in the &lt;code>SDF/VisIt&lt;/code> subdirectory of the
main &lt;code>epoch&lt;/code> directory. The reader will work for any SDF file generated
by any code which uses the SDF I/O routines. You do not need a separate
reader for each version of EPOCH.&lt;/p>
&lt;p>To compile, first navigate to one of the &lt;code>epoch*d&lt;/code> directories in your
repository. Just type &amp;ldquo;make visit&amp;rdquo; and the build scripts should take
care of the rest. The SDF reader plugin will be installed into the
&lt;code>$HOME/.visit/linux-intel/plugins/databases/&lt;/code> directory on your system.
Note that the &lt;code>linux-intel&lt;/code> component will vary depending on your
machine operating system and architecture.&lt;/p>
&lt;p>Each time you install a new version of VisIt you must recompile the
reader to match the new installation. It will also occasionally be
necessary to recompile when changes occur to the SDF data format or the
reader plugin itself. The developers will notify users if this is the
case, although it does no harm to regularly recompile the reader as a
matter of course.&lt;/p>
&lt;p>We will see later that it is possible to do remote data visualisation
with VisIt in which the GUI is launched and interacted with on one
machine and the data files are located on a separate machine entirely.
In this situation the reader must be installed on the remote machine and
must match the setup there. The setup on the local machine is
unimportant. In fact it is not even necessary to have the plugin
installed on the local machine. This is particularly useful when using a
Windows environment to analyse data located on a remote UNIX
workstation.&lt;/p>
&lt;h1 id="loading_data_into_visit">Loading Data Into VisIt&lt;/h1>
&lt;p>&lt;img src="Visit_db_list.png" alt="The VisIt load databasedialog">&lt;/p>
&lt;p>The most straightforward method for loading data into VisIt is to start
the application and then browse the filesystem for the dataset you are
interested in. This is done by selecting &amp;ldquo;File ⇒ Open file&amp;rdquo; from the
VisIt menu bar. A file selection dialogue will appear allowing you to
browse directories along with the options to filter the results
according to a given regular expression and grouping options. By
default, VisIt will attempt to group all files containing the same
suffix and some kind of numbering system into a sort of virtual
database.&lt;/p>
&lt;p>The right-hand pane of this window shows a list of selected files which
will appear in the main VisIt window when you are finished.&lt;/p>
&lt;p>An alternative method of specifying the data file to open is to pass a
command line option when the tool is launched. An example of this method
is &lt;code>visit -o Data/0000.sdf&lt;/code>. When the file is specified in this manner
the list of files shown in the VisIt window will also include the full
list of files in the dataset&amp;rsquo;s subdirectory and all the files in the
current working directory. The other SDF files will be grouped together
in a virtual database.&lt;/p>
&lt;p>Yet another method for selecting the dataset to use is by opening a
previously saved session file. We will discuss this further in a later
section.&lt;/p>
&lt;p>&lt;img src="Visit_select_var.png" alt="The Visit select plot type and variabledropdown">&lt;/p>
&lt;p>Once an SDF file has been successfully loaded the &amp;ldquo;Add&amp;rdquo; menu item will
become un-greyed and the cycle numbers for each file in the virtual
database will be displayed. If we navigate to one of the plot types we
are able to select the variable to plot from a drop-down list.&lt;/p>
&lt;h1 id="contour_plots_in_visit">Contour Plots in VisIt&lt;/h1>
&lt;p>We will now replicate each of the plots which we generated using IDL in
earlier sections. For reasons which will soon become clear we begin with
the contour plot and move on to the 1D plot in the next section.&lt;/p>
&lt;p>Having opened the same dataset we were using in the IDL discussion we
now select the &amp;ldquo;Add&amp;rdquo; menu item. Notice that many of the plot types
listed here are greyed out and cannot be selected. This is because many
of the plots are dependent on the type or dimensionality of the variable
to be plotted. If our dataset contains no variables which match the
required properties for a plot, the plot menu will be disabled.&lt;/p>
&lt;p>For the current dataset there is no &amp;ldquo;Boundary&amp;rdquo; plot available since this
requires multi-material data and none of our variables meet that
criteria.&lt;/p>
&lt;p>The list contains a menu item for a &amp;ldquo;Contour&amp;rdquo; plot. We are not going to
select this item since it only generates a contour plot with lines
indicating each contour level and not a filled version. Instead we
choose &amp;ldquo;Add ⇒ Pseudocolor ⇒ Derived ⇒ Number Density&amp;rdquo; and then hit the
&amp;ldquo;Draw&amp;rdquo; button.&lt;/p>
&lt;p>&lt;img src="Visit_contour.png" alt=" VisIT contour plotoutput">&lt;/p>
&lt;p>There are many settings which can alter the visual appearance of plots
generated by VisIt. The first point of call is usually to open up the
&amp;ldquo;Plot Attributes&amp;rdquo; or &amp;ldquo;Operator Attributes&amp;rdquo; dialogue corresponding to the
plot in question. A simpler method for accomplishing this task is to
double-click on the plot in the main VisIt menu pane which will launch
the corresponding &amp;ldquo;Plot Attributes&amp;rdquo; dialogue.&lt;/p>
&lt;p>If it is the operator attributes you wish to change, click on the white
arrow on the left hand side of the plot in the main VisIt menu pane.
This will drop down to reveal a list containing the plot and all
operators acting on it. Double-clicking on an operator will launch the
corresponding &amp;ldquo;Operator Attributes&amp;rdquo; dialogue.&lt;/p>
&lt;p>&lt;img src="Visit_attrib.png" alt="image">&lt;/p>
&lt;p>Another important tool for controlling the appearance of plots can be
found in &amp;ldquo;Controls ⇒ Annotation&amp;rdquo; from the VisIt menu bar. This allows
all of the plot annotations to be modified such as the legend, title,
axis labels, etc.&lt;/p>
&lt;p>&lt;img src="Visit_annot.png" alt="The VisIT annotationsdialog">&lt;/p>
&lt;h1 id="d_plotting_in_visit">1D Plotting in VisIt&lt;/h1>
&lt;p>A 1D plot in VisIt is called a &amp;ldquo;Curve&amp;rdquo; plot. We already mentioned that
this was greyed out because we have no one dimensional variables in our
data file.&lt;/p>
&lt;p>The solution to this dilemma is the lineout operator which extracts a
one dimensional array from a 2D or 3D variable. This operator is
selected by pressing the button with red and blue lines located at the
top of the plot window.&lt;/p>
&lt;p>&lt;img src="Visit_lineout.png" alt="image">&lt;/p>
&lt;p>Once the button has been pressed, we can click and drag anywhere in the
&amp;ldquo;Pseudocolor&amp;rdquo; plot window. When we release the mouse button a new plot
window pops up containing a &amp;ldquo;Curve&amp;rdquo; plot of the data just selected.&lt;/p>
&lt;p>&lt;img src="Visit_curve.png" alt="VisIt curve plot example">&lt;/p>
&lt;p>In order to change the attributes for this plot, we must first select
Active window&amp;quot; number 2 in the main VisIt pane.&lt;/p>
&lt;h1 id="shaded_surface_plots_in_visit">Shaded Surface Plots in VisIt&lt;/h1>
&lt;p>Again, we will confusingly refuse to pick the obvious plot type for this
task. There is &amp;ldquo;Surface&amp;rdquo; plot listed in the menu. However, most of the
time the &amp;ldquo;Elevator&amp;rdquo; operator does what we want and also gives us more
flexibility.&lt;/p>
&lt;p>The first step is to do a &amp;ldquo;Pseudocolor&amp;rdquo; plot of &amp;ldquo;Number Density&amp;rdquo; as we
did before. Next select the &amp;ldquo;Operator Attributes ⇒ Transforms ⇒ Elevate&amp;rdquo;
menu item. In the pop up dialogue click on the &amp;ldquo;Elevation height
relative to XY limits?&amp;rdquo; and then &amp;ldquo;Apply&amp;rdquo;. Click &amp;ldquo;Yes&amp;rdquo; when the warning
dialogue pops up.&lt;/p>
&lt;p>&lt;img src="Visit_shade_surf.png" alt="VisIt shaded surfaceplots">&lt;/p>
&lt;p>To make this plot look similar to the one generated by IDL, we have
changed the colour table using &amp;ldquo;Controls ⇒ Color table&amp;rdquo;. We also changed
the axis appearance with the annotations menu discussed earlier and
changed the height of the elevation using the min and max operator
attributes.&lt;/p>
&lt;h1 id="creating_user_defined_expressions">Creating User-Defined Expressions&lt;/h1>
&lt;p>VisIt comes with an extremely powerful method of manipulating data
before visualising the results. The basic idea is that an array is
transformed by applying a set of mathematical functions on all its
elements and then the result is defined as a new variable. Once defined,
this variable behaves in exactly the same way as any of the variables
read from the data file.&lt;/p>
&lt;p>As an example, we can combine the three components of electric field to
generate a single electric field vector.&lt;/p>
&lt;p>&lt;img src="Visit_expression_vector.png" alt=" VisIT expression dialog showing an example vectorexpression">&lt;/p>
&lt;p>Now when we return to the &amp;ldquo;Add&amp;rdquo; menu we see that the &amp;ldquo;Vector&amp;rdquo; and
&amp;ldquo;Streamline&amp;rdquo; and plot types now have an entry for our newly defined
vector.&lt;/p>
&lt;h1 id="creating_movies">Creating Movies&lt;/h1>
&lt;p>A compelling visualisation of numerically generated data is often made
by combining a series of images into a movie. This can be an invaluable
method for illustrating the basic behaviour of a system as it changes
over time. Alternatively rotating around a 3D scene can sometimes give a
much better idea of the structure in the model being presented. There
can also be much to gain by constructing visual fly-throughs of a scene,
dynamically slicing through sets of data or combinations of all these
techniques.&lt;/p>
&lt;p>VisIt provides several facilities for generating movies from your data.
The simplest of these is to select the &amp;ldquo;File ⇒ Save movie&amp;rdquo; menu item.
This pops up a movie wizard which will walk you through the process of
generating a simple linear movie based on the time-advancing snapshots
represented by your virtual database of files. Alternatively you can
select one of the pre-defined movie templates which manipulate the
currently selected plot and create a movie from that.&lt;/p>
&lt;p>Creating a simple time advancing movie is as simple as walking through
the wizard dialogue and selecting from the self-explanatory options
presented to you.&lt;/p>
&lt;p>For many uses, the wizard will give exactly the desired results. However
it is occasionally useful to have a little more control over how the
movie is created. In such cases it can be useful to specify an image
format such as &amp;ldquo;PNG&amp;rdquo; to save to rather than &amp;ldquo;MPEG&amp;rdquo;. VisIt will then
generate one image per frame and number them consecutively. At the end
of the process the images can be converted into a movie using whatever
tool best accomplishes the task.&lt;/p>
&lt;p>&lt;img src="Visit_movie.png" alt="VisIt create moviedialog">&lt;/p>
&lt;p>Another useful tip is to select the &amp;ldquo;Later, tell me the command to run&amp;rdquo;
radio button. This will output a long command which can run from a UNIX
terminal screen. The advantage is that no X session is required so the
command can be run in the background. It also becomes a simple task to
interrupt the job at any point and resume it from where it left off at a
later date. In a similar manner it is easy to resume a job which crashes
half way through for any reason.&lt;/p>
&lt;p>More complex movies can be created by using VisIt&amp;rsquo;s keyframing facility
which allows you to change animation attributes such as view or plot
attributes as the animation progresses. Further information about this
somewhat complex task can be found in the on-line help.&lt;/p>
&lt;p>Finally, you can use VisIt&amp;rsquo;s python scripting interface to
programmatically describe the details of each frame as the movie
progresses. This approach offers far more flexibility in what can be
achieved but is also much more involved and time consuming than the
previous two methods. Again, further information on this subject can be
found in the on-line help system.&lt;/p>
&lt;h1 id="remote_visualisation">Remote Visualisation&lt;/h1>
&lt;p>It was mentioned earlier that it is possible to perform remote
visualisation using VisIt. This is a process in which the data files
being interrogated reside on a different machine to the one on which the
VisIt GUI runs and where the results are plotted.&lt;/p>
&lt;p>This method of working can be extremely useful when the data is
generated on a powerful machine located in an external environment such
as a large cluster. Another common use is when EPOCH is executed on a
UNIX machine and the desktop used for visualisation is running Windows.&lt;/p>
&lt;p>It is sometimes possible to run a graphical tool on the remote machine
and tunnel the X-server session through to the local machine but this
can be quite slow and unstable. When connecting to a remote VisIt
instance the only data which needs to be sent between machines is the
pre-rendered image and a few simple plotting commands. Naturally, this
can be a &lt;em>&lt;code>much&lt;/code>&lt;/em> faster approach.&lt;/p>
&lt;p>Also, as mentioned before, it is possible to use a machine on which the
reader plugin is difficult or impossible to compile for and connect to a
machine on which the reader is already installed.&lt;/p>
&lt;p>In order to use the remote visualisation facility, you must first set up
a &amp;ldquo;Host profile&amp;rdquo; for the remote machine using the &amp;ldquo;Options ⇒ Host
profiles&amp;rdquo; menu item. The pre-compiled binaries are shipped with a long
list of pre-defined host profiles. These are unnecessary for anyone not
affiliated and can safely be removed by deleting the directory
&lt;code>$HOME/visit/current/.visit&lt;/code> (assuming you have unpacked the VisIt
tarball into your home directory).&lt;/p>
&lt;p>&lt;img src="Visit_host_profile.png" alt="VisIT remote host configurationdialog">&lt;/p>
&lt;p>Create a new profile by clicking on the &amp;ldquo;New Host&amp;rdquo; button and filling
out some of the form fields. The important ones to change are &amp;ldquo;Host
nickname&amp;rdquo;, &amp;ldquo;Remote host name&amp;rdquo;, &amp;ldquo;Host name aliases&amp;rdquo; and &amp;ldquo;Username&amp;rdquo;. If
the visit binary is not in your default search path on the remote
machine then you must specify its location by filling in the &amp;ldquo;Path to
VisIt installation&amp;rdquo; field.&lt;/p>
&lt;p>Now click &amp;ldquo;Apply&amp;rdquo; and &amp;ldquo;Dismiss&amp;rdquo; followed by the &amp;ldquo;Options ⇒ Save
Settings&amp;rdquo; menu item to ensure that the profile is saved for future
sessions.&lt;/p>
&lt;p>Data on the remote machine can now be loaded by selecting and picking
the desired host profile from the drop down list of &amp;ldquo;Hosts&amp;rdquo;. VisIt will
wait for the remote process to launch and then continue with the file
selection procedure but now displaying files located on the remote
machine rather than the local one. From this point on everything should
work as before except you should see the name of the remote machine in
the &amp;ldquo;Selected files&amp;rdquo; dialogue.&lt;/p>
&lt;p>&lt;img src="Visit_host_files.png" alt=" VisIT load file dialog showing files on remotehost">&lt;/p>
&lt;h1 id="parallel_visualisation">Parallel Visualisation&lt;/h1>
&lt;p>Parallel visualisation is performed in almost exactly the same manner as
remote visualisation. Again, you must create a host profile for the
purpose except this time you need to set up a parallel launch profile in
the &amp;ldquo;Launch Profiles&amp;rdquo; tab pane. Click the &amp;ldquo;New Profile&amp;rdquo; button, give the
profile a name and then set the required options in the &amp;ldquo;Parallel&amp;rdquo; tab
on the bottom section of the page. Selecting the &amp;ldquo;Launch parallel
engine&amp;rdquo; radio button will allow you to set the various launch options
which relate to the cluster on which the job will run.&lt;/p>
&lt;p>The major difference now is due to the fact that VisIt must be launched
by an external job script which fits in with the queueing system used by
the parallel machine. Usually you will need to consult with the system
administrator of the cluster to confirm which launch method and
arguments to use.&lt;/p>
&lt;p>The details of job launch can be better understood by reading through
the &amp;ldquo;User documentation&amp;rdquo; section provided at
&lt;a href="http://www.visitusers.org" target="_blank" rel="noopener">1&lt;/a> . Of particular help here is the &amp;ldquo;Getting
VisIt to run in parallel&amp;rdquo; section and the &amp;ldquo;How VisIt Launching works&amp;rdquo;
entry in the &amp;ldquo;Developer documentation&amp;rdquo; section.&lt;/p></description></item><item><title>Python BEAM</title><link>/documentation/visualising_output/python_beam.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/visualising_output/python_beam.html</guid><description>&lt;p>&lt;img src="BEAM.png" alt="BEAM logo">&lt;br>
&lt;em>Original logo produced by Oscar Adams CC BY-SA 4.0&lt;/em>&lt;/p>
&lt;p>&lt;strong>BEAM&lt;/strong> (Broad EPOCH Analysis Modules) is a collection of independent yet complementary open-source tools for analysing EPOCH simulations in Python, designed to be modular, allowing researchers to adopt only the components they require without being constrained by a rigid framework. In line with the &lt;strong>FAIR principles — Findable&lt;/strong>, &lt;strong>Accessible&lt;/strong>, &lt;strong>Interoperable&lt;/strong>, and &lt;strong>Reusable&lt;/strong> — each package is openly published with clear documentation and versioning (Findable), distributed via public repositories (Accessible), designed to follow common standards for data structures and interfaces (Interoperable), and includes licensing and metadata to support long-term use and adaptation (Reusable).&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/epochpic/sdf-xarray" target="_blank" rel="noopener">sdf-xarray&lt;/a>: Processing and plotting of SDF files and converting them to
&lt;a href="https://docs.xarray.dev/en/stable/" target="_blank" rel="noopener">xarray&lt;/a>.&lt;/li>
&lt;li>
&lt;a href="https://github.com/epochpic/epydeck" target="_blank" rel="noopener">epydeck&lt;/a>: Input deck reader and writer.&lt;/li>
&lt;li>
&lt;a href="https://github.com/epochpic/epyscan" target="_blank" rel="noopener">epyscan&lt;/a>: Create campaigns over a given parameter space using various sampling methods.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="BEAM_PlasmaFAIR.svg" alt="PlasmaFAIR logo">&lt;/p>
&lt;p>Originally developed by Joel Adams and the
&lt;a href="https://plasmafair.github.io" target="_blank" rel="noopener">PlasmaFAIR&lt;/a> Team at the York Plasma Institute under the EPSRC Grant EP/V051822/1.&lt;/p>
&lt;h2 id="installation">Installation&lt;/h2>
&lt;p>All of the packages are available on PyPI and can be installed using pip:&lt;/p>
&lt;pre>&lt;code class="language-bash">pip install sdf-xarray epydeck epyscan
&lt;/code>&lt;/pre>
&lt;p>Each package can be used independently or combined, depending on your needs.&lt;/p>
&lt;h2 id="citation">Citation&lt;/h2>
&lt;p>If any of the BEAM packages contribute to a project that leads to publication, please acknowledge this by citing the module in question. This can be done by clicking the &amp;ldquo;Cite this repository&amp;rdquo; button located near the top right of their respective GitHub pages.&lt;/p>
&lt;h2 id="contribution">Contribution&lt;/h2>
&lt;p>We welcome contributions to the BEAM ecosystem! Whether it&amp;rsquo;s reporting issues, suggesting features, or submitting pull requests, your input helps improve these tools for the community. Please follow the contribution guidelines in each repository and feel free to reach out via GitHub discussions or issues.&lt;/p>
&lt;h2 id="sdf-xarray">sdf-xarray: analysing EPOCH output&lt;/h2>
&lt;p>&lt;code>sdf-xarray&lt;/code> is a lightweight wrapper that reads EPOCH&amp;rsquo;s SDF files into &lt;code>xarray.Dataset&lt;/code> objects. This provides:&lt;/p>
&lt;ul>
&lt;li>Lazy loading and memory-efficient handling of large datasets&lt;/li>
&lt;li>Easy slicing and plotting using &lt;code>matplotlib&lt;/code>, &lt;code>xarray.plot&lt;/code>, or &lt;code>hvplot&lt;/code>&lt;/li>
&lt;li>Automatic normalisation of grid and variable names&lt;/li>
&lt;li>Integration with Jupyter notebooks and Dask for parallel analysis&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>The key features for this module are highlighted below, for in-depth documentation please visit &lt;a href="https://sdf-xarray.readthedocs.io">https://sdf-xarray.readthedocs.io&lt;/a>&lt;/strong>&lt;/p>
&lt;h3 id="single_file_loading">Single file loading&lt;/h3>
&lt;pre>&lt;code class="language-python">import xarray as xr
ds = xr.open_dataset(&amp;quot;0010.sdf&amp;quot;)
ds[&amp;quot;Electric_Field_Ex&amp;quot;]
# &amp;lt;xarray.DataArray 'Electric_Field_Ex' (X_x_px_deltaf_electron_beam: 16)&amp;gt; Size: 128B
# [16 values with dtype=float64]
# Coordinates:
# * X_x_px_deltaf_electron_beam (X_x_px_deltaf_electron_beam) float64 128B 1...
# Attributes:
# units: V/m
# full_name: &amp;quot;Electric Field/Ex&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="multi_file_loading">Multi file loading&lt;/h3>
&lt;p>To open a whole simulation at once, pass &lt;code>preprocess=sdf_xarray.SDFPreprocess()&lt;/code>
to &lt;code>xarray.open_mfdataset&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-python">import xarray as xr
from sdf_xarray import SDFPreprocess
ds = xr.open_mfdataset(&amp;quot;*.sdf&amp;quot;, preprocess=SDFPreprocess())
print(ds)
# Dimensions:
# time: 301, X_Grid_mid: 128, ...
# Coordinates: (9) ...
# Data variables: (18) ...
# Indexes: (9) ...
# Attributes: (22) ...
&lt;/code>&lt;/pre>
&lt;p>&lt;code>SDFPreprocess&lt;/code> checks that all the files are from the same simulation, as
ensures that there&amp;rsquo;s a &lt;code>time&lt;/code> dimension so the files are correctly concatenated.&lt;/p>
&lt;p>If your simulation has multiple &lt;code>output&lt;/code> blocks so that not all variables are
output at every time step, then those variables will have &lt;code>NaN&lt;/code> values at the
corresponding time points.&lt;/p>
&lt;p>After loading a series of datasets, we can select a simulation file by calling the .isel() function and passing the parameter time=0, where 0 can be any number between 0 and the total number of simulation files.&lt;/p>
&lt;p>We can also use the &lt;code>.sel()&lt;/code> function if we know the exact simulation time we want to select. There must be a corresponding dataset with this time for it to work correctly.&lt;/p>
&lt;pre>&lt;code class="language-python">print(f&amp;quot;There are a total of {ds[&amp;quot;time&amp;quot;].size} time steps. (This is the same as the number of SDF files in the folder)&amp;quot;)
# There are a total of 41 time steps. (This is the same as the number of SDF files in the folder)
print(f&amp;quot;The time steps are: {ds[&amp;quot;time&amp;quot;].values}&amp;quot;)
# The time steps are: [2.60596949e-17 5.00346143e-15 1.00069229e-14, ..., 2.00034218e-13]
sim_time = ds['time'].isel(time=20).values
print(f&amp;quot;The time at the 20th simulation step is {sim_time:.2e} s&amp;quot;)
# The time at the 20th simulation step is 1.00e-13 s
ds[&amp;quot;Electric_Field_Ex&amp;quot;].isel(time=20)
# OR
# ds[&amp;quot;Electric_Field_Ex&amp;quot;].sel(time=sim_time)
&lt;/code>&lt;/pre>
&lt;h3 id="plotting">Plotting&lt;/h3>
&lt;p>Since this package converts SDF files to xarray, we can leverage the plotting features that are included in xarray. For example we can load in a SDF file and plot the number density of the electrons:&lt;/p>
&lt;pre>&lt;code class="language-python">import xarray as xr
ds = xr.open_dataset(&amp;quot;0010.sdf&amp;quot;)
# NOTE: EPOCH saves the x and y axes in SDF files in the inverse order of what is expected by xarray, so we must specify which axis is which; otherwise, our plot will be inverted.
ds[&amp;quot;Derived_Number_Density_Electron&amp;quot;].plot(x=&amp;quot;X_Grid_mid&amp;quot;, y=&amp;quot;Y_Grid_mid&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="BEAM_Derived_Number_Density_Electron.png" alt="Derived Number Density Electron Plot">&lt;/p>
&lt;h3 id="animating">Animating&lt;/h3>
&lt;p>This package also contains custom functionality to generate time-resolved animations by loading in all the SDF files in a given simulation run:&lt;/p>
&lt;pre>&lt;code class="language-python">import xarray as xr
from sdf_xarray import SDFPreprocess
ds = xr.open_mfdataset(&amp;quot;*.sdf&amp;quot;, preprocess=SDFPreprocess())
ani = ds[&amp;quot;Derived_Number_Density_Electron&amp;quot;].epoch.animate()
ani.save(&amp;quot;Derived_Number_Density_Electron.gif&amp;quot;, fps=5)
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="BEAM_Derived_Number_Density_Electron.gif" alt="Derived Number Density Electron Animation">&lt;/p>
&lt;h2 id="epydeck">epydeck: Writing input deck files with Python&lt;/h2>
&lt;p>Writing a large number of EPOCH input files by hand can be tedious and error-prone. &lt;code>epydeck&lt;/code> (short for &lt;em>EPOCH Python deck&lt;/em>) allows you to create and manipulate input decks in Python:&lt;/p>
&lt;ul>
&lt;li>Build decks using standard Python data structures&lt;/li>
&lt;li>Load, modify, and save EPOCH-style &lt;code>.deck&lt;/code> files&lt;/li>
&lt;li>Designed to preserve comments and formatting where possible&lt;/li>
&lt;/ul>
&lt;p>The interface follows the standard Python
&lt;a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">&lt;code>json&lt;/code>&lt;/a> module:&lt;/p>
&lt;ul>
&lt;li>&lt;code>epydeck.load&lt;/code> to read from a &lt;code>file&lt;/code> object&lt;/li>
&lt;li>&lt;code>epydeck.loads&lt;/code> to read from an existing string&lt;/li>
&lt;li>&lt;code>epydeck.dump&lt;/code> to write to a &lt;code>file&lt;/code> object&lt;/li>
&lt;li>&lt;code>epydeck.dumps&lt;/code> to write to a string&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>The key features for this module are highlighted below, for in-depth documentation please visit &lt;a href="https://github.com/epochpic/epydeck">https://github.com/epochpic/epydeck&lt;/a>&lt;/strong>&lt;/p>
&lt;h3 id="epydeck_example">Example&lt;/h3>
&lt;pre>&lt;code class="language-python">import epydeck
# Read from a file with `epydeck.load`
with open(filename) as f:
deck = epydeck.load(f)
print(deck.keys())
# dict_keys(['control', 'boundaries', 'constant', 'species', 'laser', 'output_global', 'output', 'dist_fn'])
# Modify the deck as a usual python dict:
deck[&amp;quot;species&amp;quot;][&amp;quot;proton&amp;quot;][&amp;quot;charge&amp;quot;] = 2.0
# Write to file
with open(filename, &amp;quot;w&amp;quot;) as f:
epydeck.dump(deck, f)
print(epydeck.dumps(deck))
# ...
# begin:species
# name = proton
# charge = 2.0
# mass = 1836.2
# fraction = 0.5
# number_density = if((r gt ri) and (r lt ro), den_cone, 0.0)
# number_density = if((x gt xi) and (x lt xo) and (r lt ri), den_cone, number_density(proton))
# number_density = if(x gt xo, 0.0, number_density(proton))
# end:species
# ...
&lt;/code>&lt;/pre>
&lt;h2 id="epyscan">epyscan: Campaign generation and parameter sampling&lt;/h2>
&lt;p>&lt;code>epyscan&lt;/code> (short for &lt;em>EPOCH Python scan&lt;/em>) generates
&lt;a href="https://epochpic.github.io/" target="_blank" rel="noopener">EPOCH&lt;/a> campaigns over a parameter space using different sampling methods. It supports the following features:&lt;/p>
&lt;ul>
&lt;li>Defining scans over one or more input variables&lt;/li>
&lt;li>Support for grid and Latin hypercube sampling methods&lt;/li>
&lt;/ul>
&lt;p>Parameter space to be sampled is described by a &lt;code>dict&lt;/code> where keys
should be in the form of &lt;code>block_name:parameter&lt;/code>, and values should
be dicts with the following keys:&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;quot;min&amp;quot;&lt;/code>: minimum value of the parameter&lt;/li>
&lt;li>&lt;code>&amp;quot;max&amp;quot;&lt;/code>: maximum value of the parameter&lt;/li>
&lt;li>&lt;code>&amp;quot;log&amp;quot;&lt;/code>: (optional) &lt;code>bool&lt;/code>, if &lt;code>True&lt;/code> then grid is done in
log space for this parameter&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>The key features for this module are highlighted below, for in-depth documentation please visit &lt;a href="https://github.com/epochpic/epyscan">https://github.com/epochpic/epyscan&lt;/a>&lt;/strong>&lt;/p>
&lt;h3 id="epyscan_example">Example&lt;/h3>
&lt;pre>&lt;code class="language-python">import pathlib
import epyscan
import epydeck
# Define the parameter space to be sampled. Here, we are varying the intensity
# and density
parameters = {
# Intensity varies logarithmically between 1.0e22 and 1.0e24
&amp;quot;constant:intens&amp;quot;: {&amp;quot;min&amp;quot;: 1.0e22, &amp;quot;max&amp;quot;: 1.0e24, &amp;quot;log&amp;quot;: True},
# Density varies logarithmically between 1.0e20 and 1.0e24
&amp;quot;constant:nel&amp;quot;: {&amp;quot;min&amp;quot;: 1.0e20, &amp;quot;max&amp;quot;: 1e24, &amp;quot;log&amp;quot;: True},
}
# Load a deck file to use as a template for the simulations
with open(&amp;quot;template_deck_filename&amp;quot;) as f:
deck = epydeck.load(f)
# Create a grid scan object that will generate 4 different sets of parameters
# within the specified ranges
grid_scan = epyscan.GridScan(parameters, n_samples=4)
# Define the root directory where the simulation folders will be saved.
# This directory will be created if it does not already exist
run_root = pathlib.Path(&amp;quot;example_campaign&amp;quot;)
# Initialize a campaign object with the template deck and the root directory.
# This will manage the creation of simulation cases
campaign = epyscan.Campaign(deck, run_root)
# Generate the folders and deck files for each set of parameters in the
# grid scan
paths = [campaign.setup_case(sample) for sample in grid_scan]
# Save the paths of the generated simulation folders to a file
with open(&amp;quot;paths.txt&amp;quot;, &amp;quot;w&amp;quot;) as f:
[f.write(f&amp;quot;{path}\n&amp;quot;) for path in paths]
# Example content of paths.txt
# example_campaign/run_0_1000000/run_0_10000/run_0_100/run_0
# example_campaign/run_0_1000000/run_0_10000/run_0_100/run_1
# example_campaign/run_0_1000000/run_0_10000/run_0_100/run_2
# ...
&lt;/code>&lt;/pre></description></item><item><title>Basic examples</title><link>/documentation/examples/basic_examples.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/examples/basic_examples.html</guid><description>&lt;p>In this section we outline a few worked examples of setting up problems
using the EPOCH input deck.&lt;/p>
&lt;h1 id="electron_two_stream_instability">Electron two stream instability&lt;/h1>
&lt;p>An obvious simple test problem to do with EPOCH is the electron two
stream instability. An example of a nice dramatic two stream instability
can be obtained using EPOCH1D by setting the code with the following
input deck file:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 400
# Size of domain
x_min = 0
x_max = 5.0e5
# Final time of simulation
t_end = 1.5e-1
stdout_frequency = 400
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
end:boundaries
begin:constant
drift_p = 2.5e-24
temp = 273
dens = 10
end:constant
begin:species
# Rightwards travelling electrons
name = Right
charge = -1
mass = 1.0
temp = temp
drift_x = drift_p
number_density = dens
npart = 4 * nx
end:species
begin:species
# Leftwards travelling electrons
name = Left
charge = -1
mass = 1.0
temp = temp
drift_x = -drift_p
number_density = dens
npart = 4 * nx
end:species
begin:output
# Number of timesteps between output dumps
dt_snapshot = 1.5e-3
# Properties at particle positions
particles = always
px = always
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
ekbar = always
mass_density = never + species
charge_density = always
number_density = always + species
temperature = always + species
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="Two_Stream_Late.png" alt="The final state of the electron phase space for the two streaminstabilityexample">
In this example, the constant block sets up constants for the momentum
space drift, the temperature and the electron number density. The two
species blocks set up the two drifting Maxwellian distributions and the
constant density profile. The final output from this simulation is shown
in the figure.&lt;/p>
&lt;h1 id="structured_density_profile_in_epoch2d">Structured density profile in EPOCH2D&lt;/h1>
&lt;p>&lt;img src="EPOCH_density_example.png" alt="Complex 2D densitystructure">&lt;/p>
&lt;p>A simple but useful example for EPOCH2D is to have a highly structured
initial condition to show that this is still easy to implement in EPOCH.
A good example initial condition would be:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 500
ny = nx
x_min = -10 * micron
x_max = -x_min
y_min = x_min
y_max = x_max
nsteps = 0
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:constant
den_peak = 1.0e19
end:constant
begin:species
name = Electron
number_density = den_peak * (sin(4.0 * pi * x / length_x + pi / 4)) \
* (sin(8.0 * pi * y / length_y) + 1)
number_density_min = 0.1 * den_peak
charge = -1.0
mass = 1.0
npart = 20 * nx * ny
end:species
begin:species
name = Proton
number_density = number_density(Electron)
charge = 1.0
mass = 1836.2
npart = 20 * nx * ny
end:species
begin:output
number_density = always + species
end:output
&lt;/code>&lt;/pre>
&lt;p>The species block for &lt;strong>Electron&lt;/strong> is specified first, setting up the
electron density to be a structured 2D sinusoidal profile. The species
block for &lt;strong>Proton&lt;/strong> is then set to match the density of &lt;strong>Electron&lt;/strong>,
enforcing charge neutrality. On its own this initial condition does
nothing and so only needs to run for 0 timesteps (&lt;strong>nsteps = 0&lt;/strong> in
input.deck). The resulting electron number density should look like the
figure.&lt;/p>
&lt;h1 id="a_hollow_cone_in_3d">A hollow cone in 3D&lt;/h1>
&lt;p>A more useful example of an initial condition is to create a hollow
cone. This is easy to do in both 2D and 3D, but is presented here in 3D
form.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 250
ny = nx
nz = nx
x_min = -10 * micron
x_max = -x_min
y_min = x_min
y_max = x_max
z_min = x_min
z_max = x_max
nsteps = 0
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = simple_outflow
bc_y_min = periodic
bc_y_max = periodic
bc_z_min = periodic
bc_z_max = periodic
end:boundaries
begin:output
number_density = always + species
end:output
begin:constant
den_cone = 1.0e22
ri = abs(x - 5.0e-6) - 0.5e-6
ro = abs(x - 5.0e-6) + 0.5e-6
xi = 3.0e-6 - 0.5e-6
xo = 3.0e-6 + 0.5e-6
r = sqrt(y^2 + z^2)
end:constant
begin:species
name = proton
charge = 1.0
mass = 1836.2
number_density = if((r gt ri) and (r lt ro), den_cone, 0.0)
number_density = if((x gt xi) and (x lt xo) and (r lt ri), \
den_cone, number_density(proton))
number_density = if(x gt xo, 0.0, number_density(proton))
npart = nx * ny * nz
end:species
begin:species
name = electron
charge = -1.0
mass = 1.0
number_density = number_density(proton)
npart = nx * ny * nz
end:species
&lt;/code>&lt;/pre>
&lt;h4 id="3d_cone">Cone initial conditions in 3D&lt;/h4>
&lt;p>&lt;img src="3dcone.png" alt="Cone initial conditions in 3D">&lt;/p>
&lt;h4 id="2d_cone">Cone initial conditions in 2D&lt;/h4>
&lt;p>&lt;img src="2dcone.png" alt="Cone initial conditions in 2D">&lt;/p>
&lt;p>To convert this to 2D, simply replace the line &lt;code>r = sqrt(y^2+z^2)&lt;/code> with
the line &lt;code>r = abs(y)&lt;/code>. The actual work in these initial conditions is
done by the three lines inside the block for the &lt;strong>Proton&lt;/strong> species.
Each of these lines performs a very specific function:&lt;/p>
&lt;ol>
&lt;li>Creates the outer cone. Simply tests whether &lt;strong>r&lt;/strong> is within the
range of radii which corresponds to the thickness of the cone and if
so fills it with the given density. Since the inner radius is x
dependent this produces a cone rather than a cylinder. On its own,
this line produces a pair of cones joined at the tip.&lt;/li>
&lt;li>Creates the solid tip of the cone. This line just tests whether the
point in space is within the outer radius of the cone and within a
given range in &lt;strong>x&lt;/strong>, and fills it with the given density if true.&lt;/li>
&lt;li>Cuts off all of the cone beyond the solid tip. Simply tests if &lt;strong>x&lt;/strong>
is greater than the end of the cone tip and sets the density to zero
if so.&lt;/li>
&lt;/ol>
&lt;p>This deck produces an initial condition as in the Figures in
&lt;a href="#3d_cone">3D&lt;/a> and
&lt;a href="#2d_cone">2D&lt;/a>
respectively.&lt;/p></description></item><item><title>Python sdf_helper</title><link>/documentation/visualising_output/python_sdf_helper.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/visualising_output/python_sdf_helper.html</guid><description>&lt;h1 id="installing_sdf_via_pip">Installing SDF via pip&lt;/h1>
&lt;p>The simplest way to read sdf files in python is to use the
&lt;a href="https://pypi.org/project/sdfr/" target="_blank" rel="noopener">sdfr package&lt;/a>, available via pip:&lt;/p>
&lt;p>&lt;code>pip install sdfr&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>Note the name of the required package is sdfr.
The similarly named sdf package is unrelated to EPOCH.&lt;/p>
&lt;/blockquote>
&lt;h1 id="building_the_python_sdf_readers">Building the python sdf readers&lt;/h1>
&lt;p>To install the python sdf readers you need to have an installation of
python (2 or 3) with the numpy library. The automated plotting library
requires the matplotlib library. Both numpy and matplotlib are available
through most system package managers or are installable through
&lt;a href="https://pip.pypa.io/en/stable/" target="_blank" rel="noopener">pip&lt;/a>.&lt;/p>
&lt;p>Once you have a working python install, just go into one of the epoch
directories (epoch1d, epoch2d or epoch3d) and type&lt;/p>
&lt;p>&lt;code>make sdfutils&lt;/code>&lt;/p>
&lt;p>This will build the SDF python library and install the sdf_helper
wrapper and utility layer.&lt;/p>
&lt;h1 id="using_the_sdf_helper_wrapper_layer">Using the sdf_helper wrapper layer&lt;/h1>
&lt;p>The low level python SDF library is not user friendly, so a wrapper
layer called sdf_helper has been written. This wrapper layer simplifies
loading SDF files and provides simple plotting routines using
matplotlib.&lt;/p>
&lt;h3 id="importing_sdf_helper">Importing sdf_helper&lt;/h3>
&lt;p>Importing sdf_helper is as simple as&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper
&lt;/code>&lt;/pre>
&lt;p>In these examples, the numpy and matplotlib libraries are usually loaded
too, and an alias is created for sdf_helper, so the boilerplate code
looks like&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
import numpy as np
import matplotlib.pyplot as plt
&lt;/code>&lt;/pre>
&lt;h3 id="loading_an_sdf_file_using_sdf_helper">Loading an sdf file using sdf_helper&lt;/h3>
&lt;p>To load a file, use the &lt;code>getdata&lt;/code> function. This function takes either a
string which it loads as a filename, so to load the file &lt;code>Data/0010.df&lt;/code>
you would run&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
data=sh.getdata('Data/0010.sdf')
&lt;/code>&lt;/pre>
&lt;p>or it takes a number which is the dump number, and optionally a second
parameter which is the directory name as a string, so you would run&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
data=sh.getdata(10, 'Data')
&lt;/code>&lt;/pre>
&lt;p>Because memory is only allocated when needed in the SDF python reader
there is no way of specifying which variables to load using getdata. All
variables are available when the file is first loaded, and memory is
allocated when the variable is first used.&lt;/p>
&lt;h3 id="listing_the_available_variables_in_an_sdf_file">Listing the available variables in an sdf file&lt;/h3>
&lt;p>To see what variables are available use the list_variables method&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
data=sh.getdata('Data/0010.sdf')
sh.list_variables(data)
&lt;/code>&lt;/pre>
&lt;p>This produces an output that looks something like&lt;/p>
&lt;pre>&lt;code class="language-text">CPUs_Current_rank &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [0]
CPUs_Original_rank &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [2]
Current_Jx &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Derived_Charge_Density &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Derived_Number_Density &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Derived_Number_Density_Left &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Derived_Number_Density_Right &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Electric_Field_Ex &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Grid_CPUs_Original_rank &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [3]
Grid_CPUs_Original_rank_mid &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [2]
Grid_Grid &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [401]
Grid_Grid_mid &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [400]
Grid_x_px_Left &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [400, 200]
Grid_x_px_Left_mid &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [399, 199]
Grid_x_px_Right &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [400, 200]
Grid_x_px_Right_mid &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [399, 199]
Wall_time &amp;lt;class 'sdf.BlockConstant'&amp;gt; [1]
dist_fn_x_px_Left &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400, 200]
dist_fn_x_px_Right &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400, 200]
&lt;/code>&lt;/pre>
&lt;p>These are the names of the variables in the data structure. This example
is taken from the supplied &lt;code>two_stream.deck&lt;/code> example in 1D.&lt;/p>
&lt;h3 id="working_with_the_data_in_an_sdf_file">Working with the data in an SDF file&lt;/h3>
&lt;p>You can access the underlying data using the names obtained from
&lt;code>list_variables&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">variable = data.Electric_Field_Ex
&lt;/code>&lt;/pre>
&lt;p>This returns an instance of either &lt;code>sdf.BlockPlainVariable&lt;/code> or
&lt;code>sdf.BlockPointVariable&lt;/code> depending on whether you have requested a grid
variable (such as Ex, Ey or a distribution function) or a particle
variable (such as particle momentum or weight). The raw contents of the
variable is a numpy array. It is then available using the &lt;code>data&lt;/code> element
of these objects.&lt;/p>
&lt;pre>&lt;code class="language-python">import numpy as np
variable = data.Electric_Field_Ex
raw = variable.data
print(type(raw))
print(np.mean(raw))
&lt;/code>&lt;/pre>
&lt;p>produces the output&lt;/p>
&lt;pre>&lt;code class="language-text">&amp;lt;type 'numpy.ndarray'&amp;gt;
-1.27980874427008e-06
&lt;/code>&lt;/pre>
&lt;h3 id="plotting_using_sdf_helper">Plotting using sdf_helper&lt;/h3>
&lt;p>The sdf_helper wrapper script comes with some plotting routines. They
are incomplete currently, but aim to provide as close as possible to
press ready figures in a single command. You need the &lt;code>matplotlib&lt;/code>
library to use these routines, and they are only available for 1D and 2D
data at present. To plot data, simply provide an
&lt;code>sdf.BlockPlainVariable&lt;/code> object to the routine &lt;code>plot_auto&lt;/code>. An example
of plotting a 1D variable, using the &lt;code>two_stream.deck&lt;/code> example deck to
generate the figures would be&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
import matplotlib.pyplot as plt
plt.ion()
data=sh.getdata('Data/0010.sdf')
sh.plot_auto(data.Current_Jx)
&lt;/code>&lt;/pre>
&lt;p>This will produce a window similar to the image shown here, with slight
difference depending on your version of matplotlib and your operating
system. The code &lt;code>plt.ion()&lt;/code> sets matplotlib to interactive mode, so
control will be returned to you as soon as the plot has finished
drawing.&lt;/p>
&lt;p>
&lt;a href="Matplotlib1D_screenshot.png">Example 1D plot generated by sdf_helper.plot_auto&lt;/a>&lt;/p>
&lt;p>Plotting a 2D function is the same basic idea, and the code&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
import matplotlib.pyplot as plt
plt.ion()
data=sh.getdata('Data/0010.sdf')
sh.plot_auto(data.dist_fn_x_px_Right, iso=0)
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="Matplotlib2D.png" alt=" thumb \| 200px \| Example 2D plot generated bysdf_helper.plot_auto">&lt;/p>
&lt;p>will produce the figure on the right. The procedure for variables from
EPOCH2D data is exactly the same.&lt;/p>
&lt;h3 id="changing_colour_tables">Changing colour tables&lt;/h3>
&lt;p>The easiest solution to changing colour tables is to set the global
colour table. This is done by&lt;/p>
&lt;pre>&lt;code class="language-python">import matplotlib.pyplot as plt
plt.set_cmap(tablename)
&lt;/code>&lt;/pre>
&lt;p>where &lt;code>tablename&lt;/code> is a string describing the colour table to be used.
The available strings are given
&lt;a href="http://matplotlib.org/users/colormaps.html" target="_blank" rel="noopener">here&lt;/a>&lt;/p>
&lt;h3 id="some_bugs_in_matplotlib">Some bugs in matplotlib&lt;/h3>
&lt;p>There are some bugs in matplotlib which can mean that sometimes the 2D
images don&amp;rsquo;t render properly. If you get incorrect rendering, please
try updating matplotlib to the latest version for your platform. If that
doesn&amp;rsquo;t work then pass the parameter &lt;code>compatibility=True&lt;/code> to the
&lt;code>plot_auto&lt;/code> routine. This may make the plot slightly less pretty, but
tends to work on more platforms.&lt;/p>
&lt;h1 id="core_python_library">Core Python library&lt;/h1>
&lt;p>The SDF python reader allows you to read any SDF file and access any
information within the file. It has very few user friendly features to
assist working with the files. Some of the methods listed in the section
on sdf_helper (notably list_variables) are not available when using
the core library. Loading an sdf file with the core library has the
following syntax&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf
data=sdf.read(filename)
&lt;/code>&lt;/pre>
&lt;p>where filename is a string containing the name of the file to be loaded.
This returns an sdf.BlockList object&lt;/p>
&lt;h3 id="the_sdf" class="blocklist_object">The sdf.BlockList object&lt;/h3>
&lt;p>The &lt;code>list_variables&lt;/code> routine is added by the sdf_helper wrapper, but
you can check what elements are in the file by simply typing&lt;/p>
&lt;pre>&lt;code class="language-python">data.__dict__
&lt;/code>&lt;/pre>
&lt;p>Which will produce an output like the following example from EPOCH2D&lt;/p>
&lt;p>&lt;code>{'Header': {'filename': '/Users/phsiav/dev/epoch/epoch2d/Data/0005.sdf', 'file_version': 1, 'file_revision': 4, 'code_name': 'Epoch2d', 'step': 53, 'time': 2.5293132385759517e-14, 'jobid1': 1552896563, 'jobid2': 376, 'code_io_version': 1, 'restart_flag': False, 'other_domains': False, 'station_file': False}, 'Wall_time': &amp;lt;sdf.BlockConstant object at 0x11a012318&amp;gt;, 'Electric_Field_Ex': &amp;lt;sdf.BlockPlainVariable object at 0x11a012220&amp;gt;, 'Electric_Field_Ey': &amp;lt;sdf.BlockPlainVariable object at 0x11a012128&amp;gt;, 'Electric_Field_Ez': &amp;lt;sdf.BlockPlainVariable object at 0x11a012030&amp;gt;, 'Magnetic_Field_Bx': &amp;lt;sdf.BlockPlainVariable object at 0x117b2ceb8&amp;gt;, 'Magnetic_Field_By': &amp;lt;sdf.BlockPlainVariable object at 0x117b2cdc0&amp;gt;, 'Magnetic_Field_Bz': &amp;lt;sdf.BlockPlainVariable object at 0x117b2ccc8&amp;gt;, 'Grid_Grid': &amp;lt;sdf.BlockPlainMesh object at 0x117b2cbd0&amp;gt;, 'Grid_Grid_mid': &amp;lt;sdf.BlockPlainMesh object at 0x117b2cad8&amp;gt;, 'Grid_CPUs_Original_rank': &amp;lt;sdf.BlockPlainMesh object at 0x117b2c9e0&amp;gt;, 'Grid_CPUs_Original_rank_mid': &amp;lt;sdf.BlockPlainMesh object at 0x117b2c8e8&amp;gt;, 'CPUs_Original_rank': &amp;lt;sdf.BlockPlainVariable object at 0x117b2c7f0&amp;gt;, 'CPUs_Current_rank': &amp;lt;sdf.BlockPlainVariable object at 0x11a015128&amp;gt;}&lt;/code>&lt;/p>
&lt;h3 id="the_sdf" class="blockplainvariable_object">The sdf.BlockPlainVariable object&lt;/h3>
&lt;p>These objects represent the variables in the SDF file. It does not fully
implement the &lt;strong>dict&lt;/strong> property, so to inspect it&amp;rsquo;s contents you
must use&lt;/p>
&lt;pre>&lt;code class="language-python">dir(data.Electric_Field_Ey)
&lt;/code>&lt;/pre>
&lt;p>which produces an output like&lt;/p>
&lt;p>&lt;code>['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'blocklist', 'data', 'data_length', 'datatype', 'dims', 'grid', 'grid_id', 'grid_mid', 'id', 'mult', 'name', 'stagger', 'units']&lt;/code>&lt;/p>
&lt;p>The key elements are &lt;code>data&lt;/code> which contains the raw data for the variable
stored as a numpy array, &lt;code>dims&lt;/code> which is an array containing the number
of elements in each dimension of the array and &lt;code>grid&lt;/code> and &lt;code>grid_mid&lt;/code>
which refer to &lt;code>sdf.BlockPlainMesh &lt;code>objects that represent the
grid axes that the variable is to be plotted against. Grid and grid_mid
do similar but different things. Grid is an array of points
corresponding to the edges of the computational cells, grid_mid to the
midpoints. This means that all of the arrays in &lt;code>grid&lt;/code> are one element
longer than the arrays in &lt;code>grid_mid&lt;/code>. To identify whether to use &lt;code>grid&lt;/code>
or &lt;code>grid_mid&lt;/code> you must compare the sizes of the variable &lt;code>dims&lt;/code> array to
the sizes of the &lt;code>grid&lt;/code> and &lt;code>grid_mid&lt;/code> sizes and &lt;em>for each axis&lt;/em> use
the element of &lt;code>grid&lt;/code> or &lt;code>grid_mid&lt;/code> that has the same number of
elements.&lt;/p>
&lt;p>Important note! - 2D SDF data is loaded into Python rotated by 90
degrees compared to the original Fortran code that generated it.&lt;/p>
&lt;h3 id="the_sdf" class="blockplainmesh_object">The sdf.BlockPlainMesh object&lt;/h3>
&lt;p>Once again you have to use the &lt;code>dir&lt;/code> command to output the information
about an sdf.BlockPlainMesh object, for example in EPOCH&lt;/p>
&lt;pre>&lt;code class="language-python">dir(data.Grid_Grid)
&lt;/code>&lt;/pre>
&lt;p>Which produces output like&lt;/p>
&lt;p>&lt;code>['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'blocklist', 'data', 'data_length', 'datatype', 'dims', 'extents', 'geometry', 'id', 'labels', 'mult', 'name', 'units']&lt;/code>&lt;/p>
&lt;p>The important element of this block is &lt;code>data&lt;/code> which is a tuple of 1D
numpy arrays corresponding to each coordinate axis of the grid.&lt;/p>
&lt;h3 id="plotting_a_variable_using_raw_sdf_and_raw_matplotlib">Plotting a variable using raw SDF and raw matplotlib&lt;/h3>
&lt;ul>
&lt;li>Warning - This is not our recommended suggestion for plotting. We
recommend using our helper routines in sdf_helper*&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-python">import matplotlib.pyplot as plt
import sdf
data=sdf.read('Data/0005.sdf')
ey = data.Electric_Field_Ey
plt.pcolormesh(ey.grid_mid.data[0], ey.grid_mid.data[1], ey.data.T)
plt.show()
&lt;/code>&lt;/pre></description></item><item><title>Workshop examples</title><link>/documentation/examples/workshop_examples.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/examples/workshop_examples.html</guid><description>&lt;h1 id="epoch_workshop_overview">EPOCH workshop overview&lt;/h1>
&lt;p>The aims of the Workshop are:&lt;/p>
&lt;ul>
&lt;li>After the workshop you should be able to setup and run EPOCH on a
problem of real importance to your research.&lt;/li>
&lt;li>You should also be in a position to use and understand the manual.&lt;/li>
&lt;li>You should learn about PIC codes in general.&lt;/li>
&lt;li>You should understand more about the pitfalls of trying to do LPI
studies with PIC.&lt;/li>
&lt;li>Advice on how to run EPOCH and setup software on your home
computers.&lt;/li>
&lt;li>Give advice to the EPOCH team on new features for the code.&lt;/li>
&lt;/ul>
&lt;p>Warwick EPOCH Personnel:&lt;/p>
&lt;ul>
&lt;li>Tony Arber &amp;ndash; PI on EPOCH project at Warwick.&lt;/li>
&lt;li>Keith Bennett &amp;ndash; PDRA and senior EPOCH developer.&lt;/li>
&lt;li>Chris Brady &amp;ndash; Original EPOCH developer and head of RSE at Warwick&lt;/li>
&lt;li>Heather Ratcliffe - EPOCH user and developer&lt;/li>
&lt;li>Tom Goffrey &amp;ndash; PDRA and developer on other non-EPOCH codes&lt;/li>
&lt;li>Alexander Seaton - Final year PhD student with extensive experience
of using EPOCH&lt;/li>
&lt;/ul>
&lt;p>Resources:&lt;/p>
&lt;ul>
&lt;li>All machines, and exercises, are linux based.&lt;/li>
&lt;li>EPOCH is a Fortran90 program which uses MPI for parallelization.&lt;/li>
&lt;li>You will always need both F90 and MPI to compile and run the code
even on one processor.&lt;/li>
&lt;li>MPI on a Windows computer is not easy. Use linux or a Mac.&lt;/li>
&lt;/ul>
&lt;h1 id="workstation_usage">Workstation usage&lt;/h1>
&lt;p>You can use the workstations for simple 1D tests and looking at the
code.&lt;/p>
&lt;h3 id="ultra_simple_getting_epoch_guide">Ultra-simple getting EPOCH guide!&lt;/h3>
&lt;p>These instructions should work in your host institute if you have git.&lt;/p>
&lt;ol>
&lt;li>Login to workstation using guest account.&lt;/li>
&lt;li>Open a terminal.&lt;/li>
&lt;li>Type the following command at the prompt:
&lt;code>git clone --recursive https://github.com/Warwick-Plasma/epoch.git&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>You will now have a directory called &amp;lsquo;epoch&amp;rsquo;. Inside this directory will
be three EPOCH sub-directories epoch1d, epoch2d and epoch3d, an SDF
directory and a few other files. Change directory into the epoch1d
directory and start working through the
&lt;a href="#getting_started_with_epoch">&amp;lsquo;Getting Started with
EPOCH&amp;rsquo;&lt;/a> guide.&lt;/p>
&lt;h3 id="running_the_codes">Running the codes&lt;/h3>
&lt;p>Single core job: &lt;code>&amp;gt; echo Data | mpiexec -n 1 bin/epoch1d&lt;/code> Four core
parallel job: &lt;code>&amp;gt; echo Data | mpiexec -n 4 bin/epoch2d&lt;/code>&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> If you don&amp;rsquo;t have git on your home computer you can always
download a tar file of epoch when you return to your lab. This you get
from the
&lt;a href="https://github.com/Warwick-Plasma/epoch/releases" target="_blank" rel="noopener">&amp;lsquo;Releases&amp;rsquo;&lt;/a>
section on the EPOCH GitHub webpage. However I recommend
you get, and learn, git and join the 21st century.&lt;/p>
&lt;h1 id="getting_started_with_epoch">Getting Started with EPOCH&lt;/h1>
&lt;h3 id="compiling_the_code">Compiling the code&lt;/h3>
&lt;p>The first thing you must do is to compile the code. This is done using
the UNIX &amp;ldquo;make&amp;rdquo; command. This command reads a file called &lt;em>Makefile&lt;/em> and
uses the instructions in this file to generate all the steps required
for compiling the code. Most of this is done automatically and the only
part which typically needs changing are the instructions for which
compiler to use and what compiler flags it accepts. The Makefiles
supplied as part of the EPOCH source code contain sections for most
commonly used compilers so it is usually unnecessary to actually edit
these files. Usually you can compile just by passing the name of the
compiler on the command line.&lt;/p>
&lt;p>To compile the 1D version of the code, first change to the correct
directory by typing &lt;code>cd epoch/epoch1d&lt;/code>. The compiler used on most
desktop machines is &lt;code>gfortran&lt;/code>, so you can compile the code by typing
&lt;code>make COMPILER=gfortran&lt;/code>. Alternatively, if you type
&lt;code>make COMPILER=gfortran -j4&lt;/code> then the code will be compiled in parallel
using 4 processors. If you wish, you can save yourself a bit of typing
by editing your ~/.bashrc file and adding the line
&lt;code>export COMPILER=gfortran&lt;/code> at the top of the file. Then the command
would just be &lt;code>make -j4&lt;/code>.&lt;/p>
&lt;p>The most commonly used compiler on clusters these days is the Intel
FORTRAN compiler. You can compile by typing &lt;code>make COMPILER=intel&lt;/code> or
edit your ~/.bashrc file to add the line &lt;code>export COMPILER=intel&lt;/code> at the
top.&lt;/p>
&lt;p>You should rarely need to edit the Makefile more than this.
Occasionally, you may need to change fundamental behavior of the code by
changing the list of flags in the &amp;ldquo;DEFINES&amp;rdquo; entry. This is documented in
the User manual.&lt;/p>
&lt;h3 id="running_the_code">Running the code&lt;/h3>
&lt;p>Once you have built the version of EPOCH that you want (1D, 2D or 3D)
you simply run it by typing &lt;code>./bin/epoch1d&lt;/code>, &lt;code>./bin/epoch2d&lt;/code>, or
&lt;code>./bin/epoch3d&lt;/code>. That will then show you the EPOCH splash page, which
prints the logo, lists any compile time options that you specified and
then asks you to specify the output directory. It will look in this
directory for a file with the name &amp;ldquo;input.deck&amp;rdquo; containing the problem
setup. Any output performed by the code will also be written into this
directory. To work through the examples, you must download an input deck
from the section below to the directory you want EPOCH to use and rename
the file &amp;ldquo;input.deck&amp;rdquo;. Throughout this guide we will assume that you use
the directory named &amp;ldquo;Data&amp;rdquo;.&lt;/p>
&lt;p>&lt;img src="EPOCH_Splash.png" alt="The EPOCH1D splash page">&lt;/p>
&lt;h3 id="getting_the_example_decks_for_this_workshop">Getting the example decks for this workshop&lt;/h3>
&lt;p>The example input decks used in this workshop can be downloaded using
the following links. Create a directory &amp;ldquo;~/EXAMPLES&amp;rdquo; to put them in:&lt;/p>
&lt;pre>&lt;code>cd .
mkdir EXAMPLES
&lt;/code>&lt;/pre>
&lt;p>then download the .zip to this folder (either click the link and then
copy the file, or right-click and select the save-as option).
&lt;a href="Workshop_EXAMPLES.zip">All decks as a .zip&lt;/a>&lt;/p>
&lt;p>
&lt;a href="01-1d_laser.deck">01-1d_laser.deck - A simple laser&lt;/a>&lt;/p>
&lt;p>
&lt;a href="02-2d_laser_amended.deck">02-2d_laser.deck - A simple 2d laser&lt;/a>&lt;/p>
&lt;p>
&lt;a href="03-1d_two_stream.deck">03-1d_two_stream.deck - A simple two-stream instability&lt;/a>&lt;/p>
&lt;p>
&lt;a href="04-1d_two_stream_io.deck">04-1d_two_stream_io.deck - The same two-stream instability with extended output&lt;/a>&lt;/p>
&lt;p>
&lt;a href="05-2d_moving_window.deck">05-2d_moving_window.deck - Simple moving-window problem with density jump and laser&lt;/a>&lt;/p>
&lt;p>
&lt;a href="06-2d_ramp.deck">06-2d_ramp.deck - Gaussian laser into a density ramp&lt;/a>&lt;/p>
&lt;p>
&lt;a href="07-1d_heating.deck">07-1d_heating.deck - Demonstration of numerical heating&lt;/a>&lt;/p>
&lt;h1 id="a_basic_em_field_simulation">A Basic EM-Field Simulation&lt;/h1>
&lt;p>Our first example problem will be a simple 1D domain with a laser. This
should give you a simple introduction to the input deck and
visualization of 1D datasets.&lt;/p>
&lt;p>Begin by copying the &amp;ldquo;01-1d_laser.deck&amp;rdquo; file from the EXAMPLES
directory into the &amp;ldquo;Data&amp;rdquo; directory using the command: cp
~/EXAMPLES/01-1d_laser.deck Data/input.deck&lt;/p>
&lt;details>
&lt;summary>Or click to expand and copy this text into a file "input.deck" in
your Data directory.&lt;/summary>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 200
# Size of domain
x_min = -4 * micron
x_max = -x_min
# Final time of simulation
t_end = 50 * femto
#stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = open
#bc_x_min = simple_laser
bc_x_max = open
end:boundaries
#begin:laser
# boundary = x_min
# intensity_w_cm2 = 1.0e15
# lambda = 1 * micron
# phase = pi / 2
# t_profile = gauss(time, 2*micron/c, 1*micron/c)
# t_end = 4 * micron / c
#end:laser
#
#
#begin:output
# dt_snapshot = 1 * micron / c
#
# # Properties on grid
# grid = always
# ey = always
#end:output
&lt;/code>&lt;/pre>
&lt;/details>
&lt;p>Open the input deck with an editor to view its contents. Eg. &amp;ldquo;gedit
Data/input.deck&amp;rdquo;&lt;/p>
&lt;p>This is the simplest possible input deck. The file is divided into
blocks which are surrounded by &amp;ldquo;begin:blocktype&amp;rdquo; and &amp;ldquo;end:blocktype&amp;rdquo;
lines. There are currently ten different blocktypes. The most basic
input deck requires only two.&lt;/p>
&lt;p>The first block is the &amp;ldquo;control&amp;rdquo; block. This is used for specifying the
domain size and resolution and the length of time to run the simulation.
There are also some global simulation parameters that can be specified
in this block which will be introduced later. Within the block, each
parameter is specified as a &amp;ldquo;name = value&amp;rdquo; pair.&lt;/p>
&lt;p>The parameters are as follows. &amp;ldquo;nx&amp;rdquo; specifies the number of grid points
in the x-direction (since this is a 1D code, the grid is only defined in
the x-direction). &amp;ldquo;x_min&amp;rdquo; and &amp;ldquo;x_max&amp;rdquo; give the minimum and maximum
grid locations measured in meters. Since most plasma simulations are
measured in microns, there is a &amp;ldquo;micron&amp;rdquo; multiplication factor for
convenience. There are also multiplication factors for &amp;ldquo;milli&amp;rdquo; through
to &amp;ldquo;atto&amp;rdquo;. Finally, the simulation time is specified using &amp;ldquo;t_end&amp;rdquo;
measured in seconds.&lt;/p>
&lt;p>There are also commented lines in the deck. Any text following the &amp;ldquo;#&amp;rdquo;
character is ignored. The character may appear anywhere on a line, so in
the following example: t_end = 50 #* femto The value of &amp;ldquo;t_end&amp;rdquo; will
be set to 50 seconds, since &amp;ldquo;#* femto&amp;rdquo; is ignored.&lt;/p>
&lt;p>The other required block is the &amp;ldquo;boundaries&amp;rdquo; block. This contains one
entry for each boundary, specifying what boundary condition to apply.
For the 1D code there are two boundaries: &amp;ldquo;bc_x_min&amp;rdquo; and &amp;ldquo;bc_x_max&amp;rdquo;.
The deck currently has both of these set to use open boundary
conditions.&lt;/p>
&lt;p>To run the code type: &lt;code>echo Data | mpiexec -n 4 ./bin/epoch1d&lt;/code>&lt;/p>
&lt;p>This will run epoch1d in parallel using 4 processors. It will use the
directory named &amp;ldquo;Data&amp;rdquo; for all its output and will read the file
&amp;ldquo;Data/input.deck&amp;rdquo; to obtain the simulation setup.&lt;/p>
&lt;p>This simulation is rather dull. It is just a grid with zero
electromagnetic field and it generates no data files. After running the
program, two files are generated in the &amp;ldquo;Data&amp;rdquo; directory. The
&amp;ldquo;deck.status&amp;rdquo; file contains the results from the deck parsing routines
and is only useful for debugging. The &amp;ldquo;epoch1d.dat&amp;rdquo; file contains a
terse one line header with the code name, version information and time
the job started followed by a list of output dumps generated during the
run.&lt;/p>
&lt;p>Status information about the running job can be requested by
uncommenting the &amp;ldquo;stdout_frequency&amp;rdquo; line in the &amp;ldquo;control&amp;rdquo; block. This
is achieved by using a text editor to remove the &amp;ldquo;#&amp;rdquo; character and
saving the file.&lt;/p>
&lt;h1 id="adding_a_laser">Adding a laser&lt;/h1>
&lt;p>We will now edit this input deck to add a laser source to the left hand
boundary and dump some output files.&lt;/p>
&lt;ol>
&lt;li>Open the &amp;ldquo;Data/input.deck&amp;rdquo; file with an editor.&lt;/li>
&lt;li>Add a &amp;ldquo;#&amp;rdquo; comment character to the beginning of the first
&amp;ldquo;bc_x_min&amp;rdquo; line in the &amp;ldquo;boundaries&amp;rdquo; block.&lt;/li>
&lt;li>Uncomment the line &amp;ldquo;bc_x_min = simple_laser&amp;rdquo;&lt;/li>
&lt;li>Uncomment the remaining lines in the file.&lt;/li>
&lt;/ol>
&lt;p>The change to the &amp;ldquo;boundaries&amp;rdquo; block instructs the code to add a laser
source to the left-hand boundary.&lt;/p>
&lt;h3 id="the_laser_block">The Laser Block&lt;/h3>
&lt;p>We then require a new block, named &amp;ldquo;laser&amp;rdquo;, to set up the laser source.
The parameters in this block do the following:&lt;/p>
&lt;ul>
&lt;li>boundary &amp;ndash; Specifies the boundary on which to attach this laser
source&lt;/li>
&lt;li>intensity_w_cm2 &amp;ndash; Specifies the intensity of the laser in Watts /
cm^2&lt;/li>
&lt;li>lambda &amp;ndash; Gives the wavelength of the laser in meters. We have used
the multiplication factor &amp;ldquo;micron&amp;rdquo; for readability&lt;/li>
&lt;li>phase &amp;ndash; Specifies the phase shift of the laser.&lt;/li>
&lt;li>t_profile &amp;ndash; This parameter is used to modify the amplitude of the
laser over time. It is usually used to ramp a laser up or down
gradually. The left-hand side will be a function of time, usually
ranging between zero and one.&lt;/li>
&lt;li>t_end &amp;ndash; The time at which to switch off the laser.&lt;/li>
&lt;/ul>
&lt;p>These parameters are mostly self-explanatory. The &amp;ldquo;t_profile&amp;rdquo; parameter
is best explained using an example. The figure above shows the result of
using a gaussian time profile. The red line shows the value of
&amp;ldquo;t_profile&amp;rdquo; over time. This starts at a value close to zero, ramps up
to one and then ramps back down to zero. The green line shows the
amplitude of the laser when &amp;ldquo;t_profile&amp;rdquo; has not been specified. Note
that the function would normally be a sine wave, but this has been
shifted by pi/2 because the &amp;ldquo;phase&amp;rdquo; parameter was used. The blue line
shows the laser amplitude generated when the &amp;ldquo;t_profile&amp;rdquo; gaussian
profile is applied.&lt;/p>
&lt;p>&lt;img src="WorkshopLaser.png" alt="The laser profile">&lt;/p>
&lt;h3 id="the_output_block">The Output Block&lt;/h3>
&lt;p>The final addition is the &amp;ldquo;output&amp;rdquo; block. We will cover this in more
detail later. For now, it is sufficient to know that this is the block
which controls the generation of data output. The parameters used in
this case are:&lt;/p>
&lt;ul>
&lt;li>dt_snapshot &amp;ndash; This specifies the simulation time between each
output dump&lt;/li>
&lt;li>grid &amp;ndash; This controls when to dump the simulation grid. The value of
&amp;ldquo;always&amp;rdquo; means that the grid will be output whenever there is a new
output dump generated.&lt;/li>
&lt;li>ey &amp;ndash; The controls when to dump the y-component of the electric
field.&lt;/li>
&lt;/ul>
&lt;h1 id="visualising_the_data">Visualising the data&lt;/h1>
&lt;p>Now that we have generated some data we need to plot it. The data is
written to a self-describing file format called SDF. This has been
developed for use by several codes maintained at the University of
Warwick. There are routines for reading the data from within IDL, VisIt,
MatLab and Python.&lt;/p>
&lt;p>More complete documentation on visualisation routines is available
&lt;a href="/documentation/visualising_output">here&lt;/a>&lt;/p>
&lt;h3 id="loading_the_data_into_idlgdl">Loading the data into IDL/GDL&lt;/h3>
&lt;p>First, we will load the data into IDL/GDL. The desktop machines have GDL
installed &amp;ndash; the GNU Data Language, which is a free implementation of
IDL. It doesn&amp;rsquo;t have all the feature of IDL but the core routines and
syntax are identical. Type &lt;code>gdl Start.pro&lt;/code> and GDL will start up and
load the SDF reading library. To view the data contained in a file, type
&lt;code>list_variables,7,'Data'&lt;/code> Here, &amp;ldquo;7&amp;rdquo; is the snapshot number. It can be
any number between 0 and 9999. The second parameter specifies the
directory which holds the data files. If it is omitted then the
directory named &amp;ldquo;Data&amp;rdquo; is used by default.&lt;/p>
&lt;p>To load the data and assign the result to a structure named &amp;ldquo;data&amp;rdquo;, just
issue the following command: &lt;code>data = getstruct(7,/varname)&lt;/code> Here,
&amp;ldquo;/varname&amp;rdquo; is any of the variables listed by the previous command. This
will just read the &amp;ldquo;varname&amp;rdquo; variable into the data structure. However,
it is usually easiest just to omit the &amp;ldquo;/varname&amp;rdquo; flag. If it is omitted
then the entire contents of the file is read.&lt;/p>
&lt;p>The &amp;ldquo;getstruct&amp;rdquo; command returns a hierarchical data structure. The
contents of this structure can be viewed with the following command:
&lt;code>help,data,/struct&lt;/code>   For the current example the result of this command
is the following:&lt;/p>
&lt;pre>&lt;code> GDL&amp;gt; help,data,/struct
** Structure &amp;lt;Anonymous&amp;gt;, 8 tags, data length=5552:
FILENAME STRING 'Data/0007.sdf'
TIMESTEP LONG 185
TIME DOUBLE 2.3449556e-14
HEADER STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
ELAPSED_TIME STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
EY STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
GRID STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
X DOUBLE Array[200]
&lt;/code>&lt;/pre>
&lt;p>The first few entries are fairly self-explanatory. The seventh item is a
1D array containing the cell-centred grid positions. The fiftth item is
a structure containing a 1D array of Ey at these positions. This
structure can be queried in the same way as &amp;ldquo;data&amp;rdquo; :&lt;/p>
&lt;pre>&lt;code> GDL&amp;gt; help,data.ey,/struct
** Structure &amp;lt;Anonymous&amp;gt;, 2 tags, data length=1728:
METADATA STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
DATA DOUBLE Array[200]
&lt;/code>&lt;/pre>
&lt;p>The raw data is contained in the &amp;ldquo;data&amp;rdquo; entry. The sixth entry, &amp;ldquo;GRID&amp;rdquo;
is a structure which contains :&lt;/p>
&lt;pre>&lt;code>GDL&amp;gt; help,data.grid,/struct
** Structure &amp;lt;Anonymous&amp;gt;, 5 tags, data length=1824:
METADATA STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
X DOUBLE Array[201]
LABELS STRING Array[1]
UNITS STRING Array[1]
NPTS LONG Array[1]
&lt;/code>&lt;/pre>
&lt;p>This is the node-centred grid along with its metadata. The cell-centred
array shown previously is derived from this. Finally, the HEADER entry
contains metadata about the code and runtime information.&lt;/p>
&lt;p>&lt;img src="WorkshopLaserGDL.png" alt="An example GDLplot">&lt;/p>
&lt;p>The above plot can be generated by issuing the following command:
&lt;code>plot,data.x,data.ey.data&lt;/code> There are more examples on using idl/gdl in
the
&lt;a href="/documentation">manual&lt;/a>.&lt;/p>
&lt;h3 id="loading_the_data_into_python">Loading the data into Python&lt;/h3>
&lt;p>EPOCH also ships with a module for reading SDF data into python. To
build this module, change directory to epoch/epoch1d (or 2d,3d) and type
&amp;ldquo;make sdfutils&amp;rdquo;. This will build the python reader and install it
locally. It also installs a helper module which adds a few user-friendly
routines. To simplify discussion, we will just focus on using this
helper routine.&lt;/p>
&lt;p>Open a python interpreter by typing &amp;ldquo;python&amp;rdquo;, or preferably &amp;ldquo;ipython&amp;rdquo; if
you have it installed.&lt;/p>
&lt;p>On the desktops, the sdf and sdf_helper modules will be imported for
you, as sdf and sdf_helper respectively. On other machines, to load the
SDF module, type the command:&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
&lt;/code>&lt;/pre>
&lt;p>You can now load a data file by typing:&lt;/p>
&lt;pre>&lt;code class="language-python">data = sh.getdata(7)
&lt;/code>&lt;/pre>
&lt;p>or&lt;/p>
&lt;pre>&lt;code class="language-python">data = sdf_helper.getdata(7)
&lt;/code>&lt;/pre>
&lt;p>This returns a data structure which can be inspected using&lt;/p>
&lt;pre>&lt;code class="language-python"> data.__dict__
&lt;/code>&lt;/pre>
&lt;p>It also imports the contents of data arrays and prints a summary of
what has been imported.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;pre>&lt;code class="language-python">from sdf_helper import *
data = getdata(7)
#&amp;gt;&amp;gt;Reading file Data/0007.sdf
t() = time
ey(200,) = ey
x(201,) = grid
xc(200,) = grid_mid
&lt;/code>&lt;/pre>
&lt;p>If you have matplotlib installed then you can load the module using&lt;/p>
&lt;pre>&lt;code class="language-python"> from matplotlib.pyplot import *
&lt;/code>&lt;/pre>
&lt;p>Turn on interactive plotting with&lt;/p>
&lt;pre>&lt;code class="language-python">ion()
&lt;/code>&lt;/pre>
&lt;p>You can now plot the data with the command:&lt;/p>
&lt;pre>&lt;code class="language-python">plot(xc,ey)
&lt;/code>&lt;/pre>
&lt;p>The helper module has a &amp;ldquo;plot_auto&amp;rdquo; command which automatically adds
axis labels. To use this type:&lt;/p>
&lt;pre>&lt;code class="language-python">plot_auto(data.Electric_Field_Ey)
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="WorkshopLaserPython.png" alt="An example Pythonplot">&lt;/p>
&lt;h3 id="loading_the_data_into_visit">Loading the data into VisIt&lt;/h3>
&lt;p>EPOCH comes with an SDF reader plugin for the VisIt parallel
visualization tool. In order to use it, you must first compile the
reader to match the version of VisIt installed on your system. To do
this, first ensure that the &amp;ldquo;visit&amp;rdquo; command is in your path. This is the
case if typing &amp;ldquo;visit&amp;rdquo; on the command line launches the VisIt
application. Once you have this setup, you should be able to type &amp;ldquo;make
visit&amp;rdquo; from one of the epoch{1,2,3}d directories. You will need to re-do
this each time a new version of VisIt is installed on your system.&lt;/p>
&lt;p>Launch the VisIt application by typing &amp;ldquo;visit&amp;rdquo; on the command line. A
useful shortcut is to type &lt;code>visit -o Data/0000.sdf&lt;/code>. This will launch
VisIt and open the specified data file on startup. Alternatively, you
can browse for the file to open using the &amp;ldquo;Open&amp;rdquo; button. All the SDF
files in a directory will be grouped together with a green &amp;ldquo;DB&amp;rdquo; icon and
the name &amp;ldquo;*.sdf database&amp;rdquo;.&lt;/p>
&lt;p>&lt;img src="WorkshopLaserVisit.png" alt="An example VisItplot">&lt;/p>
&lt;p>You can then plot a quantity by pressing the &amp;ldquo;Add&amp;rdquo; button, selecting the
type of plot and the variable to use for the plot. When the plot has
been selected, press the &amp;ldquo;Draw&amp;rdquo; button to render it to screen. The plot
above was generated by selecting &amp;ldquo;Add-&amp;gt;Curve-&amp;gt;Electric Field-&amp;gt;Ey&amp;rdquo;.
Some of the plot properties were adjusted to make it look nicer.&lt;/p>
&lt;p>More details on using VisIt are
&lt;a href="/documentation/visualising_output/visualising_sdf_files_with_llnl_visit">
here&lt;/a>. We
recommend that you learn VisIt &amp;ndash; it&amp;rsquo;s free and powerful.&lt;/p>
&lt;h3 id="loading_data_into_matlab">Loading data into MatLab&lt;/h3>
&lt;p>The EPOCH distribution also comes with a set of reader routines for the
MatLab plotting utility. The routines themselves are contained in the
&amp;ldquo;Epoch/Matlab&amp;rdquo; directory. It is first necessary to add this directory to
your search path. One simple way of doing this is to use the menu item
&amp;ldquo;File-&amp;gt;Set Path&amp;rdquo; and then &amp;ldquo;Add Folder&amp;rdquo; to select the location of the
&amp;ldquo;Matlab&amp;rdquo; folder. To make this change permanent you have to use the
&amp;ldquo;Save&amp;rdquo; button. Unfortunately, on many systems this will not work as it
tries to change global settings which will not be permitted on a
multi-user setup. On Unix systems (including OS X), the change can be
made permanent by using the &amp;ldquo;$MATLABPATH&amp;rdquo; environment variable. For
example in bash this would be &amp;lsquo;export MATLABPATH=&amp;ldquo;Epoch/Matlab&amp;rdquo; ' which
you can add to your .bashrc file.&lt;/p>
&lt;p>To load the data from an SDF file, type the following at the MatLab
prompt:&lt;/p>
&lt;pre>&lt;code class="language-matlab">data=GetDataSDF('Data/0007.sdf');
&lt;/code>&lt;/pre>
&lt;p>The &amp;ldquo;data&amp;rdquo; variable will now contain a data structure similar to that
obtained with the IDL reader. You can explore the contents of the
structure using MatLab&amp;rsquo;s built-in variable editor. To plot Ey, you can
browse to &amp;ldquo;data.Electric_Field.Ey&amp;rdquo;. The structure member
&amp;ldquo;data.Electric_Field.Ey.data&amp;rdquo; contains the 1D array with Ey values.
Right-clicking on it gives a range of options, including &amp;ldquo;plot&amp;rdquo;.  
Alternatively, from the command prompt you can type&lt;/p>
&lt;pre>&lt;code class="language-matlab"> x=data.Electric_Field.Ey.grid.x;
xc=(x(1:end-1) + x(2:end))/2;
plot(xc,data.Electric_Field.Ey.data);
&lt;/code>&lt;/pre>
&lt;p>The first two lines set up a cell-centred grid using the node-centred
grid data. In the future, this work will be automatically done by the
reader.&lt;/p>
&lt;h1 id="a_2d_laser">A 2D laser&lt;/h1>
&lt;p>Next, we will take a look at the 2-dimensional version of the code.&lt;/p>
&lt;ul>
&lt;li>Change to the epoch2d directory: &lt;code>cd ~/Epoch/epoch2d&lt;/code>&lt;/li>
&lt;li>Type &lt;code>make -j4&lt;/code> to compile the code.&lt;/li>
&lt;li>Copy the next example input deck into the Data directory:
&lt;code>cp ~/EXAMPLES/02-2d_laser.deck Data/input.deck&lt;/code> or save the text
below into Data/input.deck&lt;/li>
&lt;li>Run with &lt;code>echo Data | mpirun -np 4 ./bin/epoch2d&lt;/code>&lt;/li>
&lt;/ul>
&lt;details>
&lt;summary>Click to expand&lt;/summary>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 500
ny = nx
# Size of domain
x_min = -10 * micron
x_max = -x_min
y_min = x_min
y_max = x_max
# Final time of simulation
t_end = 50 * femto
stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:constant
lambda0 = 1 * micron
theta = pi / 8.0
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
lambda = lambda0 * cos(theta)
profile = gauss(y, 0, 4*micron)
#phase = -2.0 * pi * y * tan(theta) / lambda0
#t_profile = gauss(time, 2*micron/c, 1*micron/c)
end:laser
begin:output
dt_snapshot = 1 * micron / c
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
end:output
&lt;/code>&lt;/pre>
&lt;/details>
&lt;p>This deck is very similar to the 1D version that we have just looked at.
It contains the necessary modifications for adding a new dimension and
some additions to the laser block for driving a laser at an angle.&lt;/p>
&lt;p>The &amp;ldquo;control&amp;rdquo; block now contains &amp;ldquo;ny&amp;rdquo; which specifies the number of grid
points in the y-direction. Notice that we are using the value &amp;ldquo;nx&amp;rdquo; to
set &amp;ldquo;ny&amp;rdquo;. As soon as &amp;ldquo;nx&amp;rdquo; has been assigned it becomes available as a
constant for use as part of a value. We must also provide the minimum
and maximum grid positions in the y-direction using &amp;ldquo;y_min&amp;rdquo;, &amp;ldquo;y_max&amp;rdquo;.
Like &amp;ldquo;nx&amp;rdquo;, the values &amp;ldquo;x_min&amp;rdquo; and &amp;ldquo;x_max&amp;rdquo; are available for use once
they have been assigned.&lt;/p>
&lt;p>In the &amp;ldquo;boundaries&amp;rdquo; block we must include boundary conditions for the
lower and upper boundaries in the y-direction, &amp;ldquo;bc_y_min&amp;rdquo;,
&amp;ldquo;bc_y_max&amp;rdquo;. These have both been set to &amp;ldquo;periodic&amp;rdquo; so that the field
at the top of the domain wraps around to the bottom of the domain.&lt;/p>
&lt;p>&lt;img src="Workshop2DLaserVisIt.png" alt="2D laser plot withVisIt">&lt;/p>
&lt;p>Next, we introduce a new block type, &amp;ldquo;constant&amp;rdquo;. This block defines
named variables which can be arbitrary mathematical expressions. Once
defined, these can be used on the left-hand side of name-value pairs in
the same way we used &amp;ldquo;nx&amp;rdquo;, &amp;ldquo;x_min&amp;rdquo;, etc. in the &amp;ldquo;control&amp;rdquo; block. This
facility can greatly aid the construction and maintenance of complex
input decks.&lt;/p>
&lt;p>The &amp;ldquo;laser&amp;rdquo; block is similar to that given in the 1D version except that
there is now a &amp;ldquo;profile&amp;rdquo; parameter. In a similar manner to &amp;ldquo;t_profile&amp;rdquo;
this is a function ranging between 0 and 1 which is multiplied by the
wave amplitude to give a modified laser profile. The only difference is
that this is a function of space rather than time. When applied to a
laser attached to &amp;ldquo;x_min&amp;rdquo; or &amp;ldquo;x_max&amp;rdquo; it is a function of Y, defined at
all points along the boundary. When the laser is attached to &amp;ldquo;y_min&amp;rdquo; or
&amp;ldquo;y_max&amp;rdquo;, it is a function of X.&lt;/p>
&lt;p>Finally, the output block has been modified so that it outputs all
electromagnetic field components.&lt;/p>
&lt;p>The result of plotting &amp;ldquo;Add-&amp;gt;Pseudocolor-&amp;gt;Electric Field-&amp;gt;Ey&amp;rdquo; in
VisIt is shown above. &lt;img src="Workshop2DLaserMatplot.png" alt="2D laser plot withMatplotlib">&lt;/p>
&lt;p>The laser block also contains a commented-out &amp;ldquo;phase&amp;rdquo; entry. Unlike in
the 1D version seen previously, this is a function of Y, like the
&amp;ldquo;profile&amp;rdquo; parameter. Uncommenting this line and re-running the deck will
generate a laser driven at an angle to the boundary. The mathematical
details explaining why this works are explained in more detail in the
User Manual. By making the value of &amp;ldquo;theta&amp;rdquo; a function of Y, it is also
possible to produce a focused laser. This is left as an exercise for the
reader!&lt;/p>
&lt;p>The above plot can also be generated using matplotlib using the command
&lt;code>plot2d(data.Electric_Field_Ey)&lt;/code>&lt;/p>
&lt;h1 id="specifying_particle_species">Specifying particle species&lt;/h1>
&lt;p>In this example we will finally introduce some particles into the PIC
code! The deck is for the 1D version of the code, so change back to the
epoch1d directory and copy ~/EXAMPLES/03-1d_two_stream.deck to
Data/input.deck (or copy the deck below) and run the code.&lt;/p>
&lt;details>
&lt;summary>Click to expand&lt;/summary>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 400
# Size of domain
x_min = 0
x_max = 5.0e5
# Final time of simulation
t_end = 1.5e-1
stdout_frequency = 400
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
end:boundaries
begin:constant
drift_p = 2.5e-24
temp = 273
dens = 10
end:constant
begin:species
# Rightwards travelling electrons
name = Right
charge = -1
mass = 1.0
temp = temp
drift_x = drift_p
number_density = dens
npart = 4 * nx
end:species
begin:species
# Leftwards travelling electrons
name = Left
charge = -1
mass = 1.0
temp = temp
drift_x = -drift_p
number_density = dens
npart = 4 * nx
end:species
begin:output
# Number of timesteps between output dumps
dt_snapshot = 1.5e-3
# Properties at particle positions
particles = always
px = always
# Properties on grid
grid = always
ey = always
end:output
&lt;/code>&lt;/pre>
&lt;/details>
&lt;p>The control block has one new parameter. &amp;ldquo;npart&amp;rdquo; gives the total number
of PIC particles to use in the simulation.&lt;/p>
&lt;p>The input deck contains a new block type, &amp;ldquo;species&amp;rdquo;, which is used for
populating the domain with particles. Every species block must contain a
&amp;ldquo;name&amp;rdquo; parameter. This is used to identify the particle species in other
sections of the input deck and is also used for naming variables in the
output dumps. The next parameter is &amp;ldquo;charge&amp;rdquo; which gives the charge on
each particle in terms of elementary charge units. &amp;ldquo;mass&amp;rdquo; is specified
in units of electron mass. &amp;ldquo;frac&amp;rdquo; is the fraction of the total number of
PIC particles (npart) to assign to this species. Both of the blocks in
this deck use &amp;ldquo;frac = 0.5&amp;rdquo;, so there will be 1600 particles of each
species. The next parameter, &amp;ldquo;temp&amp;rdquo;, sets the average temperature of the
particle species in Kelvin. Alternatively, you can use &amp;ldquo;temp_ev&amp;rdquo; to
specify the temperature in electronvolts. Particles are assigned an
initial momentum corresponding to a Maxwell-Boltzmann distribution for
this temperature. It is defined across the entire problem domain, so in
1D it is a function of X, in 2D a function of X and Y, and in 3D a
function of X, Y and Z. &amp;ldquo;number_density&amp;rdquo; sets the number density across
the problem domain. The code is set to use per-particle weights in the
default Makefile. With this option, the pseudoparticles are distributed
evenly across the domain. Then the weight of each pseudoparticle is
adjusted so that it matches the number density specified in the
&amp;ldquo;number_density&amp;rdquo; parameter. The alternative option is to disable
per-particle weighting. In this case, the weight of each pseudoparticle
is the same and the particles are placed on the grid so that they match
the number density at the start of the simulation. Finally, we have a
&amp;ldquo;drift_x&amp;rdquo; parameter. This is also defined across the entire problem
domain and is used to give the particles an average momentum drift in
the x-direction. There are similar &amp;ldquo;drift_y&amp;rdquo; and &amp;ldquo;drift_z&amp;rdquo; parameters.&lt;/p>
&lt;p>This deck has been designed to simulate a two-stream instability, so it
has two groups of particles which are identical in every respect except
that one set is drifting in the opposite direction to the other. &lt;img src="WorkshopTwoStreamPython.png" alt="Thetwo-stream instability inMatplotlib">
&lt;img src="WorkshopTwoStreamGDL.png" alt="The two-stream instability in GDL">&lt;/p>
&lt;p>In the output block we have added a couple of parameters for outputting
particle data. The first parameter, &amp;ldquo;particles&amp;rdquo;, outputs the grid on
which the particles are defined. There are two different types of
variable in EPOCH: particle variables and grid-based variables. The
grid-based variables are like the electromagnetic field components we
have seen previously. The domain is divided into a regular Cartesian
mesh and the grid-based variables are defined at either a node or
cell-centre of each point in this mesh. Particle variables, on the other
hand, are associated with each of the pseudoparticles. These PIC
particles move independently of the Cartesian mesh and can be located
anywhere in the problem domain. The &amp;ldquo;particles&amp;rdquo; parameter requests that
the coordinates of each particle are written to file. This information
is required in order to plot any of the particle variables. The next
parameter is &amp;ldquo;px&amp;rdquo; which writes the momentum of each particle.&lt;/p>
&lt;p>To plot this using python and matplotlib, type the following:&lt;/p>
&lt;pre>&lt;code class="language-python">data = getdata(30)
plot1d(data.Particles_Px_Left,'r.',ms=2,yscale=1)
oplot1d(data.Particles_Px_Right,'b.',ms=2,yscale=1)
ylim([-6e-24,6e-24])
&lt;/code>&lt;/pre>
&lt;p>To plot with GDL, type the following:&lt;/p>
&lt;pre>&lt;code>gdl Start.pro
data=getstruct(30)
plot,data.grid_right.x,data.px_right.data,psym=3,$
yrange=[-6e-24,6e-24],ystyle=1
oplot,data.grid_left.x,data.px_left.data,psym=3,color=150
&lt;/code>&lt;/pre>
&lt;p>Above we have plotted the x-component of particle momentum as a function
of x-position at a time when the instability is just starting to form.
The &amp;ldquo;psym=3&amp;rdquo; option to the plot routine tells GDL to plot each data
point as a dot and not to join the dots up.&lt;/p>
&lt;h1 id="the_output_block_1">The Output Block&lt;/h1>
&lt;p>The contents of the output block can be much more complicated than the
examples shown so far. Here, we will cover the options in a little more
depth.&lt;/p>
&lt;p>EPOCH currently has three different types of output dump. So far, we
have only been using the &amp;ldquo;normal&amp;rdquo; dump type. The next type of dump is
the &amp;ldquo;full&amp;rdquo; dump. To request this type of dump, you add the parameter
&amp;ldquo;full_dump_every&amp;rdquo; which is set to an integer. If this was set equal to
&amp;ldquo;10&amp;rdquo; then after every 9 dump files written, the 10th dump would be a
&amp;ldquo;full&amp;rdquo; dump. This hierarchy exists so that some variables can be written
at frequent intervals whilst large variables such as particle data are
written only occasionally. The third dump type is the &amp;ldquo;restart&amp;rdquo; dump.
This contains all the variables required in order to restart a
simulation, which includes all the field variables along with particle
positions, weights and momentum components. In a similar manner to full
dumps, the output frequency is specified using the
&amp;ldquo;restart_dump_every&amp;rdquo; parameter.&lt;/p>
&lt;p>So far, we have given all the variable parameters a value of &amp;ldquo;always&amp;rdquo; so
that they will always be dumped to file. There are three other values
which can be used to specify when a dump will occur. &amp;ldquo;never&amp;rdquo; indicates
that a variable should never be dumped to file. This is the default used
for all output variables which are not specified in the output block.
The value of &amp;ldquo;full&amp;rdquo; indicates that a variable should be written at full
dumps. &amp;ldquo;restart&amp;rdquo; means it is written into restart dumps.&lt;/p>
&lt;p>There are a few output variables which are grid-based quantities derived
by summing over properties for all the particles contained within each
cell on the mesh. These are &amp;ldquo;ekbar&amp;rdquo;, &amp;ldquo;mass_density&amp;rdquo;, &amp;ldquo;charge_density&amp;rdquo;,
&amp;ldquo;number_density&amp;rdquo; and &amp;ldquo;temperature&amp;rdquo;. To find more details about these
variables, consult the
&lt;a href="/documentation/input_deck/input_deck_output_block">output
block&lt;/a> section of the
&lt;a href="/documentation">user
manual&lt;/a>.&lt;/p>
&lt;h1 id="other_laser_plasma_example_decks">Other Laser-Plasma example decks&lt;/h1>
&lt;p>
&lt;a href="/documentation/examples/workshop_examples_continued">Continue the examples&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Workshop examples continued</title><link>/documentation/examples/workshop_examples_continued.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/examples/workshop_examples_continued.html</guid><description>&lt;h1 id="other_laser_plasma_example_decks">Other Laser-Plasma example decks&lt;/h1>
&lt;p>Now that you have a basic understanding of how the input decks work, you
should be able to work through the remaining example decks by referring
to the
&lt;a href="/documentation">User manual&lt;/a> for a description of
any new parameters used. Several experienced users of the code will be
available throughout the duration of the workshop, so if you want help
with anything please don&amp;rsquo;t hesitate to ask. The decks are:&lt;/p>
&lt;ul>
&lt;li>01-1d_laser.deck Described in notes above
&lt;a href="/documentation/examples/workshop_examples#a_basic_em_field_simulation">(here)&lt;/a>&lt;/li>
&lt;li>02-2d_laser.deck Described in notes above
&lt;a href="/documentation/examples/workshop_examples#a_2d_laser">(here)&lt;/a>&lt;/li>
&lt;li>03-1d_two_stream.deck Described in notes above
&lt;a href="/documentation/examples/workshop_examples#specifying_particle_species">(here)&lt;/a>&lt;/li>
&lt;li>04-1d_two_stream_io.deck This is the same as the previous deck
but with the addition of more sophisticated output diagnostics&lt;/li>
&lt;li>05-2d_moving_window.deck This deck contains an example of firing a
laser into a plasma and then using the moving window facility to
track the wave front as it moves beyond the edge of the original
domain.&lt;/li>
&lt;li>06-2d_ramp.deck This deck contains an example of firing a laser at
a plasma with a ramped density profile.&lt;/li>
&lt;li>07-1d_heating.deck This deck contains a setup for investigating the
anomalous heating of a plasma that occurs for purely resolved
systems.&lt;/li>
&lt;/ul>
&lt;h3 id="other_things_to_try">Other things to try&lt;/h3>
&lt;ol>
&lt;li>Landau damping predicts collisionless damping of electrostatic
waves. Setup a 1D problem with an electrostatic wave and check for a
range of wavelengths. Points to note:
&lt;ol>
&lt;li>Does the answer depend on whether the initial condition is a
travelling wave or standing wave? How are these setup?&lt;/li>
&lt;li>Look for trapping in the Langmuir wave&lt;/li>
&lt;li>Check the damping rate against published formulae. Try for a
range of $k\lambda_D$ as the most commonly reported formulae
assume $kλ_D≪1$&lt;/li>
&lt;li>The answer is more accurate, assuming you have enough
grid-points and particles to get a good answer, if you ignore
the first maxima or two &amp;ndash; why?&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>A more realistic instability than the two cold beams tested above is
the bump-on-tail instability. Setup a 1D bump-on-tail distribution
and check that the simple formula for the growth-rates is correctly
reproduced. The main problem with the initial conditions is how to
setup a suitable initial distribution.&lt;/li>
&lt;li>Try setting up the initial conditions for a problem of direct
relevance to your research. This may be too computationally
demanding to run on the workshop computers but it is a good exercise
as you can get some help on trickier input decks and diagnostic
planning than the simple exercises so far.&lt;/li>
&lt;li>Check that EPOCH works as expected on your host institution
computer. If not we may be able to help before you leave.&lt;/li>
&lt;/ol>
&lt;h1 id="copies_of_the_decks">Copies of the decks&lt;/h1>
&lt;p>The decks can be downloaded
&lt;a href="/documentation/examples/workshop_examples#getting_the_example_decks_for_this_workshop">
here&lt;/a>
and viewed or copied from here:&lt;/p>
&lt;details>
&lt;summary>04-1d_two_stream_io.deck (click to expand)&lt;/summary>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 400
# Size of domain
x_min = 0
x_max = 5.0e5
# Final time of simulation
t_end = 1.5e-1
stdout_frequency = 400
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
end:boundaries
begin:constant
drift_p = 2.5e-24
temp = 273
dens = 10
end:constant
begin:species
# Rightwards travelling electrons
name = Right
charge = -1
mass = 1.0
temp = temp
drift_x = drift_p
number_density = dens
npart = 4 * nx
end:species
begin:species
# Leftwards travelling electrons
name = Left
charge = -1
mass = 1.0
temp = temp
drift_x = -drift_p
number_density = dens
npart = 4 * nx
end:species
begin:output
name = normal
# Number of timesteps between output dumps
dt_snapshot = 1.5e-3
# Properties at particle positions
particles = always
px = always
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
ekbar = always
mass_density = never + species
charge_density = always
number_density = always + species
temperature = always + species
distribution_functions = always
end:output
begin:output
name = restart
# Number of timesteps between output dumps
dt_snapshot = 0.15
restartable = T
end:output
begin:dist_fn
name = x_px
ndims = 2
direction1 = dir_x
direction2 = dir_px
# Range is ignored for spatial coordinates
range1 = (1, 1)
range2 = (-5e-24, 5e-24)
# Resolution is ignored for spatial coordinates
resolution1 = 1
resolution2 = 200
include_species:Left
include_species:Right
end:dist_fn
&lt;/code>&lt;/pre>
&lt;/details>
&lt;details>
&lt;summary>05-2d_moving_window.deck (click to expand)&lt;/summary>
&lt;pre>&lt;code class="language-perl">begin:constant
x0 = 20 * micron
lambda = 10 * micron
t_laser = 120 * femto
sigma_t = t_laser / 2 / sqrt(loge(2))
w0_laser = 30 * micron
sigma_w0 = w0_laser / 2 / sqrt(loge(2))
den_peak = 5.0e19 * 1.0e6
win_start = 340 * femto
end:constant
begin:control
nx = 1550 / 8
ny = 600 / 8
npart = (60e6) / 8
# Size of domain
x_min = 0
x_max = 155 * micron
y_min = -30 * micron
y_max = -y_min
# Final time of simulation
t_end = 1600 * femto
stdout_frequency = 1
print_eta_string = T
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = simple_outflow
bc_y_min = simple_outflow
bc_y_max = simple_outflow
end:boundaries
begin:species
name = electron
charge = -1.0
mass = 1.0
number_density = if((x lt x0), 0.0, den_peak)
frac = 0.5
end:species
begin:species
name = proton
charge = 1.0
mass = 1836.2
number_density = number_density(electron)
frac = 0.5
end:species
begin:output
name = normal
dt_snapshot = 50 * femto
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
jy = always
ekbar = always
mass_density = never + species
charge_density = always
number_density = always + species
temperature = always + species
end:output
begin:output
name = large
dt_snapshot = 500 * femto
particles = always
particle_weight = always
end:output
begin:laser
boundary = x_min
intensity_w_cm2 = 1.9e18
lambda = lambda
t_profile = gauss(time, 2*sigma_t, sigma_t)
profile = gauss(y, 0, sigma_w0)
end:laser
begin:window
move_window = T
window_v_x = c * 0.87
window_start_time = win_start
bc_x_min_after_move = simple_outflow
bc_x_max_after_move = simple_outflow
end:window
&lt;/code>&lt;/pre>
&lt;/details>
&lt;details>
&lt;summary>06-2d_ramp.deck (click to expand)&lt;/summary>
&lt;pre>&lt;code class="language-perl">begin:constant
# Particles per cell
part = 32
las_lambda = 1 * micron
las_omega = 2.0 * pi * c / las_lambda
las_time = 2.0 * pi / las_omega
n_crit = critical(las_omega)
max_dens = 0.8 * n_crit
scale_x = 20 * micron
las_scale_y = 8 * micron
xmin = -4 * micron
# Gaussian Beam stuff
w0 = las_scale_y
rayleigh_range = pi * w0^2 / las_lambda
wz = w0 * sqrt(1 + (x_start / rayleigh_range)^2)
radius_of_curvature = x_start * (1.0 + (rayleigh_range / x_start)^2)
end:constant
begin:control
nx = 1024 / 4
ny = 512 / 4
# Final time of simulation
t_end = 0.4 * pico
# Size of domain
x_min = xmin
x_end = scale_x + 20 * micron
y_min = -20 * micron
y_max = -y_min
stdout_frequency = 10
end:control
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e16
omega = las_omega
t_profile = if (time lt 2*las_time, gauss(time, 2*las_time, 2*las_time), 1)
profile = (1.0 + 0.05 * sin(32.0*pi*y/lengthy)) * gauss(y, 0, las_scale_y)
end:laser
begin:boundaries
bc_x_min = simple_laser
bc_x_max = simple_outflow
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:species
# Electron
name = electron
charge = -1.0
mass = 1.0
npart = nx * ny * part
number_density = max_dens * (exp(x/scale_x) - 1) / (exp(1) - 1)
number_density = if(x lt 0, 0.0, number_density(electron))
number_density = if(number_density(electron) gt max_dens, max_dens, \
number_density(electron))
number_density = if(x gt 75*micron, 0.0, number_density(electron))
#number_density = number_density(electron) \
* (0.8 + 0.2 * gauss(y, 0, 0.5*las_scale_y))
number_density_min = 0.0001 * n_crit
number_density_max = n_crit
temp_ev = 10^3
end:species
begin:species
# Protons
name = proton
charge = 1.0
mass = 1836.2
npart = nx * ny * part
number_density = number_density(electron)
number_density_min = 0.0001 * n_crit
number_density_max = 1.2 * n_crit
temp_ev = 40
end:species
begin:output
name = normal
# Number of timesteps between output dumps
dt_snapshot = 5 * femto
# Properties at particle positions
particles = always
px = always
particle_weight = always
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
jy = always
jz = always
ekbar = always + species
mass_density = never + species
charge_density = always # + average + snapshot
number_density = always + species
temperature = never + species
# Extended io
distribution_functions = always
end:output
begin:dist_fn
name = en
ndims = 1
direction1 = dir_en
range1 = (0, 15*kev)
resolution1 = 5000
include_species:electron
end:dist_fn
begin:dist_fn
name = x_en
ndims = 2
direction1 = dir_x
direction2 = dir_en
# Range is ignored for spatial coordinates
#range1 = (1, 1)
range2 = (0, 15*kev)
# Resolution is ignored for spatial coordinates
#resolution1 = 1
resolution2 = 1500
include_species:electron
end:dist_fn
begin:dist_fn
name = x_px
ndims = 2
direction1 = dir_x
direction2 = dir_px
# Range is ignored for spatial coordinates
#range1 = (1, 1)
range2 = (-5e-23, 5e-23)
# Resolution is ignored for spatial coordinates
#resolution1 = 1
resolution2 = 1500
include_species:electron
end:dist_fn
begin:probe
name = electron_probe
point = (0.5 * (x_max + x_min), y_min)
normal = (1, 0)
include_species:electron
include_species:proton
end:probe
&lt;/code>&lt;/pre>
&lt;/details>
&lt;details>
&lt;summary>07-1d_heating.deck (click to expand)&lt;/summary>
&lt;pre>&lt;code class="language-perl">begin:constant
dl = 74.33942 * micron
end:constant
begin:control
nx = 10
# Size of domain
x_min = 0
x_max = 14000 * dl
# Final time of simulation
t_end = 1.5e-2
stdout_frequency = 10000
print_eta_string = T
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
end:boundaries
begin:species
name = electron
charge = -1
mass = 1.0
temp_x_ev = 1
number_density = 1e16
npart = nx * 5
end:species
begin:output
name = normal
# Number of timesteps between output dumps
dt_snapshot = 1.5e-3
# Properties on grid
grid = always
ekbar = always
temperature = always
end:output
begin:output
name = large
# Number of timesteps between output dumps
dt_snapshot = 75e-3
# Properties at particle positions
particles = always
px = always
py = always
pz = always
end:output
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h1 id="remote_visualisation_with_visit">Remote Visualisation with VisIt&lt;/h1>
&lt;p>If the local workstation you are using isn&amp;rsquo;t big enough for your test
problems you may also use a your host institutes HPC cluster.&lt;/p>
&lt;h3 id="remote_visualisation_with_visit_1">Remote Visualisation with VisIt&lt;/h3>
&lt;p>Most large simulations are carried out on a remotely located machine.
Often this machine is located many miles away, perhaps even in a
different country. Viewing data on remote systems can be awkward and
poor network speeds can often make it nearly impossible. The VisIt
visualisation tool solves this problem by using a client-server model.
The program which reads, processes and renders the data is completely
separated from the program which displays the results on the screen. It
is therefore possible to run VisIt on your local machine and look at
data located on a different machine. The method of setting this up
varies depending on the configuration of the remote machine so we will
not go into details here. However, the desktop machines have been setup
to be able to view data located on remote clusters so you can try it
out.&lt;/p>
&lt;p>In the VisIt control window, click the &amp;ldquo;Open&amp;rdquo; button which launches a
file browser window. The first entry is called &amp;ldquo;Host&amp;rdquo; and contains a
drop-down list of all configure remote machines.&lt;/p>
&lt;p>If you want to know more about how to set up remote visualisation in
VisIt, you can ask one of the Warwick staff members.&lt;/p>
&lt;p>When viewing data across a slow network connection, there is one more
useful thing to know. VisIt has two methods of drawing plots generated
on a remote machine. The first method is to construct the polygons used
in drawing the plot on the remote machine and send them across the
network. The local machine then turns these into a plot image. This
makes manipulating the figure very fast (zooming, rotating, etc), since
all the polygons that generate the image are on the local machine.
However, if there are a lot of polygons then they can be slow to
transfer across the network. They can also use up a lot of memory. For
these cases, the alternative is to render the image on the remote
machine and just transfer the image across the network. The downside of
this approach is that whenever you manipulate the plot, it must be
re-drawn on the remote machine and then transferred across the network
again. The options controlling this behaviour are to be found under
&amp;ldquo;Options-&amp;gt;Rendering&amp;rdquo; in the &amp;ldquo;Advanced&amp;rdquo; tab. The feature is called
&amp;ldquo;scalable rendering&amp;rdquo;.&lt;/p>
&lt;h1 id="collisions_in_epoch">Collisions in EPOCH&lt;/h1>
&lt;p>EPOCH now contains a collision routine based on the technique outlined
in Sentoku &amp;amp; Kemp&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Collisions are enabled using the output block named
&lt;a href="/documentation/input_deck/input_deck_collisions">collisions&lt;/a> which accepts the
following three parameters.&lt;/p>
&lt;ul>
&lt;li>use_collisions &amp;ndash; This is a logical flag which determines whether
or not to call the collision routine. If omitted, the default is
&amp;ldquo;true&amp;rdquo; if any of the frequency factors are non-zero (see below)
and &amp;ldquo;false&amp;rdquo; otherwise.&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>coulomb_log &amp;ndash; This may either be set to a real value, specifying
the Coulomb logarithm to use when scattering the particles or to the
special value &amp;ldquo;auto&amp;rdquo;. If &amp;ldquo;auto&amp;rdquo; is used then the routine will
calculate a value based on the properties of the two species being
scattered. If omitted, the default value is &amp;ldquo;auto&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>collide &amp;ndash; This sets up a symmetric square matrix of size
nspecies*nspecies containing the collision frequency factors to use
between particle species. The element (s1,s2) gives the frequency
factor used when colliding species s1 with species s2. If the factor
is less than zero, no collisions are performed. If it is equal to
one, collisions are performed normally. For any value between zero
and one, the collisions are performed using a frequency multiplied
by the given factor. If &amp;ldquo;collide&amp;rdquo; has a value of &amp;ldquo;all&amp;rdquo; then all
elements of the matrix are set to one. If it has a value of &amp;ldquo;none&amp;rdquo;
then all elements are set to minus one. If the syntax &amp;ldquo;species1
species2 &lt;value>&amp;rdquo; is used, then the (species1,species2) element of
the matrix is set to the factor &amp;ldquo;&lt;value>&amp;rdquo;. This may either be a
real number, or the special value &amp;ldquo;on&amp;rdquo; or &amp;ldquo;off&amp;rdquo;. The &amp;ldquo;collide&amp;rdquo;
parameter may be used multiple times. The default value is &amp;ldquo;all&amp;rdquo;
(ie. all elements of the matrix are set to one).&lt;/li>
&lt;/ul>
&lt;p>For example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:collisions
use_collisions = T
coulomb_log = auto
collide = all
collide = spec1 spec2 off
collide = spec2 spec3 0.1
end:collisions
&lt;/code>&lt;/pre>
&lt;p>With this block, collisions are turned on and the Coulomb logarithm is
automatically calculated. All values of the frequency array are set to
one except (spec1,spec2) is set to minus one (and also (spec2,spec1))
and (spec2,spec3) is set to 0.1&lt;/p>
&lt;h1 id="ionisation_in_epoch">Ionisation in EPOCH&lt;/h1>
&lt;p>EPOCH includes field ionization which can be activated by defining
&amp;ldquo;field_ionisation = T&amp;rdquo; in the
&lt;a href="/documentation/input_deck/input_deck_control">control&lt;/a> block along with
ionisation energies and an electron for the ionising species in one of
the
&lt;a href="/documentation/input_deck/input_deck_species">species&lt;/a> blocks. This is done
via the species block in the &amp;ldquo;ionisation_energies&amp;rdquo; and
&amp;ldquo;electron_species&amp;rdquo; parameter respectively. &amp;ldquo;ionisation_energies&amp;rdquo;
should be given as a list in joules, and &amp;ldquo;electron_species&amp;rdquo; should be
the name of the species to be used as the electron species. For example,
ionising carbon species might appear in the input deck as:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
charge = 0.0
mass = 1837.2
name = carbon
ionisation_energies = \
(11.26*ev, 24.38*ev, 47.89*ev, 64.49*ev, 392.1*ev, 490.0*ev)
electron_species = electron
number_density = den_gas
end:species
begin:species
charge = -1.0
mass = 1.0
name = electron
number_density = 0.0
end:species
&lt;/code>&lt;/pre>
&lt;p>It is possible to define different electron species for each ionisation
level, which is particularly useful in monitoring specific ionisation
levels. If we wished to monitor the fourth ionisation level of carbon in
the above example, the above example might appear:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
charge = 0.0
mass = 1837.2
name = carbon
ionisation_energies = \
(11.26*ev, 24.38*ev, 47.89*ev, 64.49*ev, 392.1*ev, 490.0*ev)
electron_species = (electron, electron, electron, fourth, electron, electron)
number_density = den_gas
end:species
begin:species
charge = -1.0
mass = 1.0
name = electron
number_density = 0.0
end:species
begin:species
charge = -1.0
mass = 1.0
name = fourth
number_density = 0.0
end:species
&lt;/code>&lt;/pre>
&lt;p>Field ionisation consists of three distinct regimes; multiphoton in
which ionisation is best described as absorption of multiple photons,
tunneling in which deformation of the atomic coulomb potential is the
dominant factor, and barrier suppression ionisation in which the
electric field is strong enough for an electron to escape classically.
It is possible to turn off multiphoton or barrier suppression ionisation
through the input deck by adding &amp;ldquo;use_multiphoton=F&amp;rdquo; and/or
&amp;ldquo;use_bsi=F&amp;rdquo; to the control block.&lt;/p>
&lt;h1 id="qed_effects_in_epoch">QED Effects in EPOCH&lt;/h1>
&lt;p>EPOCH has recently been extended to include some quantum electrodynamic
effects that are important for high intensity (&amp;gt;) lasers. The two
processes that are included are&lt;/p>
&lt;ul>
&lt;li>Gamma ray production by QED corrected synchrotron emission (Also
called magnetic bremsstrahlung or nonlinear Compton scattering).&lt;/li>
&lt;li>Electron positron pair production by the Breit-Wheeler process from
these gamma ray photons.&lt;/li>
&lt;/ul>
&lt;p>For more information on the theory see Duclous et al. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Simulating the QED effects increases EPOCH&amp;rsquo;s memory requirements and so
the code has to be compiled with the correct compilation options to turn
the module on. To turn the module on, open &amp;ldquo;Makefile&amp;rdquo; in an editor and
find the commented out line &lt;code>#DEFINES += $(D)PHOTONS&lt;/code>. Uncomment this
line, then type &amp;ldquo;make clean&amp;rdquo; and then &amp;ldquo;make&amp;rdquo; (remember to include the
&lt;code>COMPILER=&lt;/code> if you haven&amp;rsquo;t specified the environment variable) to
rebuild the code with QED support.&lt;/p>
&lt;p>Once the code is built with QED support, actually turning on QED for a
specific simulation requires the addition of a new block into the input
deck. This block is simply called
&lt;a href="/documentation/input_deck/input_deck_qed">qed&lt;/a>
and starts with the usual &amp;ldquo;begin:qed&amp;rdquo; and &amp;ldquo;end:qed&amp;rdquo; markers of the other
blocks. The parameters which can go into the block are:&lt;/p>
&lt;ul>
&lt;li>use_qed - Turns QED on or off. If you don&amp;rsquo;t want QED effects at all
then compile the code without the &amp;ldquo;-DPHOTONS&amp;rdquo; lines in the makefile.&lt;/li>
&lt;li>qed_start_time - Specifies the time after which QED effects should
be turned on. For example you can turn off the routines until a
laser has crossed the vacuum region in front of the target.&lt;/li>
&lt;li>produce_photons - Specifies whether you&amp;rsquo;re interested in the
photons generated by synchrotron emission. If this is F then the
radiation reaction force is calculated but the properties of the
emitted photons are not tracked.&lt;/li>
&lt;li>photon_energy_min - Minimum energy of produced photons. Radiation
reaction is calculated for photons of all energies, but photons with
energy below this cutoff are not tracked.&lt;/li>
&lt;li>photon_dynamics - If F then photons are generated, but their motion
through the domain is not simulated and they stay where they were
generated. Photon motion is often less interesting than photon
generation unless you want to simulate pair production. In these
cases set this to F.&lt;/li>
&lt;li>produce_pairs - Whether or not to simulate the process of pair
generation from gamma ray photons. Both produce_photons and
photon_dynamics must be T for this to work.&lt;/li>
&lt;li>qed_table_location - EPOCH&amp;rsquo;s QED routines use lookup tables to
calculate gamma ray emission and pair production. If you want to use
tables in a different location from the default put the location in
this parameter.&lt;/li>
&lt;/ul>
&lt;p>QED also requires that the code now know which species are electrons,
positrons and photons. Rather than try to do this automatically the user
has to specify the type of a species. This is done by using a single
&amp;ldquo;identify&amp;rdquo; tag in a species block. To specify an electron the block in
the deck would look like&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = electron
frac = 0.5
number_density = 7.7e29
identify:electron
end:species
&lt;/code>&lt;/pre>
&lt;p>Once the identity of a species is set then the code automatically
assigns mass and charge states for the species. At present, the user
cannot override these. Possible identities are&lt;/p>
&lt;ul>
&lt;li>electron : A normal electron species. All species of electrons in
the simulation must be identified in this way or they will not
generate photons.&lt;/li>
&lt;li>positron : A normal positron species. All species of positron in the
simulation must be identified in this way or they will not generate
photons.&lt;/li>
&lt;li>photon : A normal photon species. One species of this type is needed
for photon production to work. If multiple species are present then
generated photons will appear in the first species of this type.&lt;/li>
&lt;li>bw_electron : The electron species for pair production. If a
species of this type exists then electrons from the pair production
module will be created in this species. If no species of this type
is specified then pair electrons will be generated in the first
electron species.&lt;/li>
&lt;li>bw_positron : The positron species for pair production. If a
species of this type exists then positrons from the pair production
module will be created in this species. If no species of this type
is specified then pair positrons will be generated in the first
positron species.&lt;/li>
&lt;/ul>
&lt;p>A species should be identified only once, so a &amp;ldquo;bw_electron&amp;rdquo; species
does not need to also be identified as an &amp;ldquo;electron&amp;rdquo; species. If the
code is running with &amp;ldquo;produce_photons=T&amp;rdquo; then a photon species must be
created by user and identified. If the code is running with
&amp;ldquo;produce_pairs=T&amp;rdquo; then the code must specify at least one electron (or
bw_electron) species and one positron (or bw_positron) species. The
code will fail to run if the needed species are not specified.&lt;/p>
&lt;h1 id="other_useful_info">Other Useful Info&lt;/h1>
&lt;h3 id="bug_reports_feature_requests_and_questions">Bug reports, feature requests and questions&lt;/h3>
&lt;p>All questions and requests after the workshop should be posted on the
GitHub EPOCH project
&lt;a href="https://github.com/Warwick-Plasma/epoch" target="_blank" rel="noopener">web page&lt;/a>&lt;/p>
&lt;h3 id="the_visit_programme">The VisIt programme&lt;/h3>
&lt;p>The VisIt programme is free. It can be downloaded from
&lt;a href="https://wci.llnl.gov/simulation/computer-codes/visit/">https://wci.llnl.gov/simulation/computer-codes/visit/&lt;/a> There are many
pre-compiled binaries so this ought to be easy. If you have any problems
post a question on the GitHub EPOCH project.&lt;/p>
&lt;h3 id="gdl_not_idl">GDL not IDL&lt;/h3>
&lt;p>If you don&amp;rsquo;t have IDL, or don&amp;rsquo;t want to pay for it!, then the free GDL
is available from &lt;a href="http://gnudatalanguage.sourceforge.net/">http://gnudatalanguage.sourceforge.net/&lt;/a>&lt;/p>
&lt;h3 id="updating_epoch">Updating EPOCH&lt;/h3>
&lt;p>To update to the latest version of EPOCH simple cd into your Epoch
directory and enter &amp;lsquo;git pull&amp;rsquo;. This will work fine provided you haven&amp;rsquo;t
edited any of the Fortran source code. If you have edited the source
code then you need to learn git.&lt;/p>
&lt;h3 id="getting_old_copies_of_epoch">Getting Old Copies of EPOCH&lt;/h3>
&lt;p>You can also checkout an old version of EPOCH, you may want to get the
version used 18 months ago to reproduce some previous simulations
exactly for example. In this case it is best to checkout a new branch in
the EPOCH repository. If you wanted the version from 10 February 2010
for example you would first enter
&lt;code>git log --before=2010-02-11&lt;/code>
This will give you the log of commits in reverse order, starting on the
11th of February. Identify the commit you want and copy the commit hash
(the long string of numbers and letters following the word &amp;ldquo;commit&amp;rdquo;). To
checkout a copy of this version of the code, type
&lt;code>git checkout -b old-code &lt;/code>&lt;hash>
After this your repository will reflect the state of the code at that
point in time. To get back to the current version, just type
&lt;code>git checkout master&lt;/code>&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Y. Sentoku and A. J. Kemp, &amp;ldquo;Numerical methods for particle
simulations at extreme densities and temperatures: Weighted
particles, relativistic collisions and reduced currents,&amp;rdquo; J. Comput.
Phys., 2008.
&lt;a href="http://www.sciencedirect.com/science/article/pii/S0021999108001988" target="_blank" rel="noopener">link&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>R. Duclous, J. G. Kirk, and A. R. Bell, &amp;ldquo;Monte carlo calculations
of pair production in high-intensity laser plasma interactions,&amp;rdquo;
Plasma Phys. Contr. F., vol. 53, no. 1, p. 015009,
2011
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/53/1/015009" target="_blank" rel="noopener">1&lt;/a>.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Adding Outputs</title><link>/developer/input_output/adding_outputs.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/adding_outputs.html</guid><description>&lt;h2 id="adding-a-derived-variable">Adding a derived variable&lt;/h2>
&lt;p>Derived variables are variables which are defined on the
Cartesian spatial grid but are not directly updated by the solver. They are
calculated when needed for output or for use in other physics packages. The
final form of a derived variable is an array on each processor with the same
size as the field arrays. Examples include &lt;code>number_density&lt;/code>, &lt;code>ekbar&lt;/code> and
&lt;code>poynting_flux&lt;/code>.&lt;/p>
&lt;p>A derived variable is defined on the same grid as the main simulation variables
and must be written to disk in such a way as to stitch the parts of the grid
from each processor together. This is achieved using the routine:&lt;/p>
&lt;pre>&lt;code class="language-perl">CALL sdf_write_plain_variable(sdf_handle, id, name, units, dims, stagger, &amp;amp;
grid_id, variable, subtype_field, subarray_field)
&lt;/code>&lt;/pre>
&lt;p>The parameters have the following types and meanings:&lt;/p>
&lt;ul>
&lt;li>block_id - The id name of the variable. This character string is a
unique identifier for
the variable in the file enabling a program to retrieve it later. Once
defined it should not change so that newer versions of EPOCH can still
identify variables generated by older versions.&lt;/li>
&lt;li>name - The display name of the variable. This character string is
the name that is used
by external programs to display an identifying name for the variable. If it
contains &amp;lsquo;/&amp;rsquo; characters then these are used by VisIt to group the variables.&lt;/li>
&lt;li>units - The units of the variable. This character string is used when
displaying the data units. For most variables in EPOCH these
are SI units.&lt;/li>
&lt;li>dims - An nD integer array containing the GLOBAL length of the variable
across all processors. In EPOCH a variable actually called &amp;ldquo;dims&amp;rdquo; exists
for variables which are the same size as the default field variables.&lt;/li>
&lt;li>stagger - An integer constant containing the stagger of a variable from
the cell centre of a cell. This property lets external programs know the
position of a variable on the grid.&lt;/li>
&lt;li>grid_id - The id name of the grid to which the variable is attached. In
EPOCH, the main grid is just called &amp;ldquo;grid&amp;rdquo;. Note that this property is
case sensitive.&lt;/li>
&lt;li>variable - The actual variable to be written to disk.&lt;/li>
&lt;li>subtype_field - This is an MPI type representing the layout of the data
across the processors. For a standard field variable, there is an
automatically created type called &amp;ldquo;subtype_field&amp;rdquo; which should be used
here.&lt;/li>
&lt;li>subarray_field - This is an MPI type representing the section of
the &amp;ldquo;variable&amp;rdquo; parameter to be written. For a standard field variable,
there is an automatically created type called &amp;ldquo;subarray_field&amp;rdquo; which
should be used here.&lt;/li>
&lt;/ul>
&lt;p>It&amp;rsquo;s probably easiest to read the diagnostics.F90 file and see how the code
implements the output of simple variables like ex or ey for an example of how
this works. Once the appropriate sdf_write call has
been added to the code, there is no further work
to be done. The IDL, MatLab and VisIt routines will all read the existence of
the variable from the metadata in the SDF file, and it will now be available to
view in all SDF reading packages.&lt;/p>
&lt;p>There is a working variable called &lt;code>array&lt;/code> which is large enough to
store a derived variable. It is
therefore recommended that to calculate derived variables a new subroutine
should be created which populates &lt;code>array&lt;/code> with the required variable
and then writes it to disk. An example would look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">IF (IAND(dumpmask(c_dump_myvar), code)) THEN
CALL calc_my_variable(array)
CALL sdf_write_plain_variable(sdf_handle, 'my_var', 'Mine/variable', 'unit',
dims, c_stagger_cell_centre, 'grid', array, subtype_field, subarray_field)
ENDIF
&lt;/code>&lt;/pre>
&lt;p>where &lt;code>calc_my_variable&lt;/code> is a function which calculates the
variable which you wish to write. The form of this function depends on the type
of variable to be calculated and is given in the next section.&lt;/p>
&lt;h2 id="adding-a-particle-variable">Adding a particle variable&lt;/h2>
&lt;p>The next simplest type of output to add is a new property for all particles. To
add new particle variables to the output dump, two things are needed: a call
to the SDF command to write the data and an iterator function to iterate
through all the particles. &lt;strong>NOTE&lt;/strong>: This section only deals with new outputs
for &lt;em>existing&lt;/em> particle variables. Creation of a new particle variable is more
involved, and
requires modifying MPI routines.&lt;/p>
&lt;p>The iterators are stored in the file
&lt;code>iterators.F90&lt;/code>. An example iterator is:&lt;/p>
&lt;pre>&lt;code class="language-perl"> ! iterator for particle momenta
FUNCTION iterate_px(array, n_points, start)
REAL(num) :: iterate_px
REAL(num), DIMENSION(:), INTENT(OUT) :: array
INTEGER, INTENT(INOUT) :: n_points
LOGICAL, INTENT(IN) :: start
TYPE(particle), POINTER, SAVE :: cur
TYPE(particle_list), POINTER, SAVE :: current_list
INTEGER :: part_count
IF (start) THEN
CALL start_particle_list(current_species, current_list, cur)
ENDIF
part_count = 0
DO WHILE (ASSOCIATED(current_list) .AND. (part_count .LT. n_points))
DO WHILE (ASSOCIATED(cur) .AND. (part_count .LT. n_points))
part_count = part_count + 1
array(part_count) = cur%part_p(1)
cur=&amp;gt;cur%next
ENDDO
! If the current partlist is exhausted, switch to the next one
IF (.NOT. ASSOCIATED(cur)) CALL advance_particle_list(current_list, cur)
ENDDO
n_points = part_count
iterate_px = 0
END FUNCTION iterate_px
&lt;/code>&lt;/pre>
&lt;p>This is a fairly complicated routine which includes code for dealing with the
possibility of particle species not being dumped, and other complicated
book keeping. Luckily, there is only one line in the routine which needs to
change to output a new variable. This being:&lt;/p>
&lt;pre>&lt;code class="language-perl"> array(part_count) = cur%part_p(1)
&lt;/code>&lt;/pre>
&lt;p>To write a new iterator, you just have to copy the skeleton of an existing
iterator and change this line to copy your particle property into the &amp;ldquo;array&amp;rdquo;
array. The details of the particle structure&amp;rsquo;s contents is explained
&lt;a href="/developer/core_structure/macro_particles.html">here&lt;/a>.
Once your new iterator has been written and added into
the &lt;code>iterators.F90&lt;/code> file, it&amp;rsquo;s time to add the SDF routine to actually
write the data. The routine is:&lt;/p>
&lt;pre>&lt;code class="language-perl"> CALL write_particle_variable(c_dump_id, code, name, iterator)
&lt;/code>&lt;/pre>
&lt;p>The parameters this time are&lt;/p>
&lt;ul>
&lt;li>c_dump_id - The index into the dumpmask for this variable.&lt;/li>
&lt;li>code - The dump code for the current output dump.&lt;/li>
&lt;li>name - The display name to use for this variable.&lt;/li>
&lt;li>iterator - The name of the iterator function that you created in
the previous step. Note that this is not a string but simply the name of the
function.&lt;/li>
&lt;/ul>
&lt;p>Once again, looking at how this is implemented for one of the existing
variables (e.g. px) is probably the most enlightening way to see how it
works. As for the fluid variables, the new variable will appear in IDL, MatLab
and VisIt.&lt;/p>
&lt;p>At this point it is possible to write any property which is similar to the
default field variables or the default particle properties. It becomes slightly
more challenging if you want to write other types of variable into an output
file.&lt;/p></description></item><item><title>Basic Output</title><link>/developer/input_output/basic_output.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/basic_output.html</guid><description>&lt;p>EPOCH uses a file format called &lt;em>SDF&lt;/em> which was custom developed for use
with codes developed by CFSA at the University of Warwick. However, it isn&amp;rsquo;t necessary
to have a full understanding of the file format
to add the output of new variables to EPOCH. To add a new variable to
EPOCH&amp;rsquo;s output, you simply have to use the supplied subroutines of the SDF
library which is part of EPOCH. The file output from EPOCH takes place in
&lt;em>diagnostics.F90&lt;/em>, so to add new variables to the output you must
add additional code there. Looking through the listings, you will see two lines:&lt;/p>
&lt;pre>&lt;code class="language-perl"> CALL sdf_open(sdf_handle, filename, rank, comm, c_sdf_write)
CALL sdf_close(sdf_handle)
&lt;/code>&lt;/pre>
&lt;p>These, as may be expected, are the commands which open and close the SDF file.
It is perfectly possible to create new SDF files containing only your own data.
There are various commands in-between which actually write the data into the
file. These commands start with &lt;code>sdf_&lt;/code> to ensure that the don&amp;rsquo;t
conflict with any other subroutine names in the code.
Some more complex areas of I/O, such as the particle probes
and the distribution function routines call other subroutines in their
respective source files, but these too make use of the SDF routines to actually
write data. A user should never try to write data directly to the output file,
since this will cause problems with internal parts of the SDF format and
generate a nonsensical file.&lt;/p>
&lt;h2 id="the-dumpmask">The dumpmask&lt;/h2>
&lt;p>Looking through &lt;code>diagnostics.F90&lt;/code> there are many lines with commands which
begin &lt;code>sdf_&lt;/code>, but are all prepended with a command which looks
like:&lt;/p>
&lt;pre>&lt;code class="language-perl"> IF (IAND(dumpmask(c_dump_id), code) .NE. 0) THEN
&lt;/code>&lt;/pre>
&lt;p>This is the method by which EPOCH allows the end user to specify whether a
variable should be dumped, and whether it should only be dumped at
full/partial/restart dumps. &lt;strong>dumpmask&lt;/strong> is an integer array, the length of
which is defined by the variable &lt;code>num_vars_to_dump&lt;/code> in
&lt;code>shared_data.F90&lt;/code> and contains the bitmask representing all the
types of output which should be written for the associated variable. The
possible values in the bitmask are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>c_io_never&lt;/code> - Never dump this variable.&lt;/li>
&lt;li>&lt;code>c_io_always&lt;/code> - Dump this variable at every output dump.&lt;/li>
&lt;li>&lt;code>c_io_full&lt;/code> - Dump this variable at full dumps.&lt;/li>
&lt;li>&lt;code>c_io_restartable&lt;/code> - Dump this variable for restart dumps.&lt;/li>
&lt;li>&lt;code>c_io_species&lt;/code> - If meaningful for this variable, write
information for each species rather than integrated over all species.&lt;/li>
&lt;li>&lt;code>c_io_no_sum&lt;/code> - If meaningful for this variable, do not
write information integrated over all species.&lt;/li>
&lt;li>&lt;code>c_io_averaged&lt;/code> - If meaningful for this variable, write
this variable averaged over time.&lt;/li>
&lt;li>&lt;code>c_io_snapshot&lt;/code> - If meaningful for this variable, write
the non-averaged value of the variable.&lt;/li>
&lt;/ul>
&lt;p>The &lt;code>c_dump_id&lt;/code> entry is a constant defined in
&lt;code>shared_data.F90&lt;/code> which identifies the variable&amp;rsquo;s index within
this dumpmask.&lt;/p>
&lt;p>When adding a new variable to be written to disk, the value of
&lt;code>num_vars_to_dump&lt;/code> should be increased to match the number of new
written variables. Next, open the file &lt;code>src/deck/deck_io_block.F90&lt;/code>
and find the line:&lt;/p>
&lt;pre>&lt;code class="language-perl"> CHARACTER(LEN=entry_length), DIMENSION(io_block_elements) :: &amp;amp;
io_block_name = ...
&lt;/code>&lt;/pre>
&lt;p>Simply add new strings for your new variables to the end of the
definitions along with its &lt;code>c_dump_id&lt;/code> value. These new variable
names should then be placed in your input decks
in the same place as the existing I/O information and take the same parameters.&lt;/p>
&lt;h2 id="precompiler-directives-and-the-input-deck">Precompiler directives and the input deck&lt;/h2>
&lt;p>In theory, it is possible for someone to request a feature of the code in the
input deck which this version hasn&amp;rsquo;t been compiled with. In this
case, there is a special error code &lt;code>c_err_pp_options_wrong&lt;/code>
which causes the input deck parser to give a meaningful error. You should also
set the string &lt;code>extended_error_string&lt;/code> to be the define
command for the missing preprocessor directive i.e
&lt;code>extended_error_string = &amp;quot;-DMY_PRECOMPILER_DIRECTIVE&amp;quot;&lt;/code>&lt;/p></description></item><item><title>Basic Structures</title><link>/developer/core_structure/basic_structures.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/basic_structures.html</guid><description>&lt;p>This page details a few basic background components of EPOCH. Here we introduce
the global shared data modules and its physical constants, variables used to
define the cell grid, and the functions used to load macro-particles onto the
grid.&lt;/p>
&lt;h2 id="physical-constants">Physical constants&lt;/h2>
&lt;p>In order to ensure that different parts of the code run at the same precision
common physical constants are defined in &lt;code>constants.F90&lt;/code> and any
new physical constants required by extensions to the code should be placed in
the same location. The constants available in the code are&lt;/p>
&lt;ul>
&lt;li>pi - Ratio of a circle&amp;rsquo;s circumference to its diameter.&lt;/li>
&lt;li>q0 - Charge on electron.&lt;/li>
&lt;li>m0 - Rest mass of electron.&lt;/li>
&lt;li>c - Speed of light in vacuum.&lt;/li>
&lt;li>kb - Boltzmann&amp;rsquo;s constant.&lt;/li>
&lt;li>mu0 - Permeability of free space.&lt;/li>
&lt;li>epsilon0 - Permittivity of free space.&lt;/li>
&lt;li>h_planck - Planck&amp;rsquo;s constant.&lt;/li>
&lt;li>ev - The value of an electron volt.&lt;/li>
&lt;li>h_bar - Planck&amp;rsquo;s constant divided by $2\pi$ .&lt;/li>
&lt;li>a0 - The Bohr radius.&lt;/li>
&lt;li>hartree - Double the Rydberg energy.&lt;/li>
&lt;li>alpha - Fine structure constant.&lt;/li>
&lt;li>atomic_time - Time in atomic units (h_bar / hartree).&lt;/li>
&lt;li>atomic_electric_field - Electric field in atomic units (hatree / q0 / a0).&lt;/li>
&lt;li>mc0 - Electron mass * speed of light.&lt;/li>
&lt;li>m0c2 - Electron rest mass energy.&lt;/li>
&lt;/ul>
&lt;p>Further constants are used in the QED (photons) physics package and the
bremsstrahlnug package.&lt;/p>
&lt;p>Any new constants required should be specified in the same place in
&lt;code>constants.F90&lt;/code>.&lt;/p>
&lt;h2 id="shape-and-size-variables">Shape and size variables&lt;/h2>
&lt;p>As well as the physical constants, there are some important variables which
you will have to use to do any development with EPOCH. As a general note,
since EPOCH is written with separate 1D, 2D and 3D versions, definitions will
be given for the 3D version of the code and irrelevant dimensions should just
be left out.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>INTEGER :: nx, ny, nz&lt;/code> - The number of gridpoints on the current
processor in each direction. This may change when the load balancer
activates, so always use these variables rather than local copies.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: nx_global, ny_global, nz_global&lt;/code> - The number of gridpoints
in each direction of the whole domain. These numbers will never change and
will be the numbers read in from the input deck.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER(KIND=8) :: npart_global&lt;/code> - The global number of particles
specified in the input deck. This is not updated as particles leave the
domain through boundaries etc. so it is not guaranteed to be accurate.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: n_species&lt;/code> - The number of species of particles specified.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: nsteps&lt;/code> - The maximum number of steps that the core solver
should take.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER, DIMENSION(1:nproc{x,y,z}), ALLOCATABLE :: cell_{x,y,z}_min,&lt;/code>
&lt;code>cell_{x,y,z}_max&lt;/code> - The variables &lt;code>cell_{x,y,z}_min&lt;/code> and
&lt;code>cell_{x,y,z}_max&lt;/code> represent the part of a global array which is held by the
current processor. Since EPOCH is an MPI code, there doesn&amp;rsquo;t exist a
single copy of any of the global arrays anywhere, but if there did then each
processor would be responsible for the slice which runs
(cell_x_min(rank):cell_x_max(rank),
cell_y_min(rank):cell_y_max(rank))
in 2D. These variables are used internally in the load balancer, where it is
updated, but is also used when calculating distribution functions. Here it is
used to define the extents of the MPI type which is used to write the
distribution function to disk.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>-Useful global parameters exist for tracking the position and size of the fields
stored by each MPI rank. The variables:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>INTERGER :: {x,y,z}_grid_min_local&lt;/code> - These give the position of the
cell-&lt;strong>centre&lt;/strong> which has indices (1,1,1) on the current MPI rank. The grids on
each rank only contain a fraction of the total simulation cells.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: {x,y,z}_{min,max}_boundary&lt;/code> - Logical flags to determine whether
the current rank is on the simulation edge. If &lt;code>x_min_boundary&lt;/code> is true, then
the current MPI rank has no neighbouring ranks on the low-$x$ edge.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="the-timestep">The timestep&lt;/h2>
&lt;p>The timestep is calculated in the subroutine &lt;code>set_dt&lt;/code> in the file
&lt;code>src/housekeeping/setup.F90&lt;/code>. All that the subroutine has to do is set
the variable &lt;code>dt&lt;/code> to set the timestep for the whole code. Any
additional timestep constraints should be coded into this subroutine. This
should be implemented after the existing &lt;code>dt=&lt;/code> lines but before the
line &lt;code>dt = dt_multiplier * dt&lt;/code>. Such a modification should be set so
that it only changes the timestep if the timestep is MORE restrictive than that
calculated from the core code. An example would be:&lt;/p>
&lt;pre>&lt;code class="language-perl"> dt = dx * dy / SQRT(dx**2 + dy**2) / c
dt = MIN(dt, my_new_dt)
&lt;/code>&lt;/pre>
&lt;p>In the core EPOCH code the timestep can be calculated identically on each
processor, so there is no requirement to synchronise the timestep across
multiple processors. If your new timestep restriction uses information local to
each processor then some additional lines must be added to the
&lt;code>set_dt&lt;/code> routine after the timestep has been calculated which
should read:&lt;/p>
&lt;pre>&lt;code class="language-perl"> REAL(num) :: dt_global
.
.
.
CALL MPI_ALLREDUCE(dt_global, dt, 1, mpireal, MPI_MIN, comm, errcode)
dt = dt_global
&lt;/code>&lt;/pre>
&lt;p>This uses another MPI command to determine the most restrictive timestep across
all processors. EPOCH is not written in a way that permits operation with
different timesteps on different processors, and the behaviour of the code is
undefined (and likely wrong) if the code runs with different timesteps on
different processors.&lt;/p>
&lt;h2 id="input-deck-variables">Input deck variables&lt;/h2>
&lt;ul>
&lt;li>&lt;code>CHARACTER(LEN=entry_length) :: blank&lt;/code> - A special string which the input
deck parser uses to indicate that it&amp;rsquo;s passing a blank string rather than a
string read from the deck which just happens to be blank.&lt;/li>
&lt;li>&lt;code>INTEGER :: deck_state&lt;/code> - An integer determining the current sweep of
the input deck by the deck parser.&lt;/li>
&lt;li>&lt;code>INTEGER, PARAMETER :: num_vars_to_dump&lt;/code> - A variable describing the
number of variables which should be selectable in the input deck as possible
variables to dump.&lt;/li>
&lt;li>&lt;code>CHARACTER(LEN=entry_length) :: extended_error_string&lt;/code> - String used by
some error codes in the deck parser to give more user friendly error
messages.&lt;/li>
&lt;li>&lt;code>INTEGER :: data_dir_max_length&lt;/code> - The maximum number of characters in
the name of the output directory.&lt;/li>
&lt;li>&lt;code>INTEGER :: n_zeros&lt;/code> - The number of leading zeros in the output filenames
from EPOCH.&lt;/li>
&lt;/ul>
&lt;h2 id="initial-conditions-autoloader-variables">Initial conditions (autoloader) variables&lt;/h2>
&lt;p>Initial conditions for the autoloader for a given species are described in
EPOCH by the Fortran TYPE &lt;code>initial_conditions_block&lt;/code>. The
definition (in 3D) is:&lt;/p>
&lt;pre>&lt;code class="language-perl">TYPE initial_condition_block
REAL(num), DIMENSION(:,:,:), POINTER :: density
REAL(num), DIMENSION(:,:,:,:), POINTER :: temp
REAL(num), DIMENSION(:,:,:,:), POINTER :: drift
REAL(num) :: density_min
REAL(num) :: density_max
END TYPE initial_condition_block
&lt;/code>&lt;/pre>
&lt;p>In 2D, the arrays have one fewer index, and in 1D they have two fewer.&lt;/p>
&lt;ul>
&lt;li>&lt;code>REAL(num) :: density&lt;/code> - Number density for the particles in the species.
When defined runs (-2:nx+3,-2:ny+3,-2:nz+3).&lt;/li>
&lt;li>&lt;code>REAL(num) :: temp&lt;/code> - Temperature in Kelvin of the species in space. When
defined runs (-2:nx+3,-2:ny+3,-2:nz+3,1:3). The final index of the array
is a direction index, used to give anisotropic thermal distributions.&lt;/li>
&lt;li>&lt;code>REAL(num) :: drift&lt;/code> - Velocity drift in $m/s$ of the species in space.
When defined runs (-2:nx+3,-2:ny+3,-2:nz+3,1:3). The final index of the array
is the velocity direction component.&lt;/li>
&lt;li>&lt;code>density_min&lt;/code> - The minimum density below which the autoloader
should not load particles.&lt;/li>
&lt;li>&lt;code>density_max&lt;/code> - The maximum density above which the autoloader
should clip the density function.&lt;/li>
&lt;/ul>
&lt;p>The initial conditions themselves are in the variable&lt;/p>
&lt;pre>&lt;code class="language-perl">TYPE(initial_condition_block), DIMENSION(:), ALLOCATABLE :: initial_conditions
&lt;/code>&lt;/pre>
&lt;p>which is allocated to an array of size &lt;code>1:n_species&lt;/code>.&lt;/p></description></item><item><title>Boundary Conditions</title><link>/developer/core_structure/boundary_conditions.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/boundary_conditions.html</guid><description>&lt;p>Boundary conditions in EPOCH are split into three types&lt;/p>
&lt;ul>
&lt;li>Simple field boundaries.&lt;/li>
&lt;li>Laser and outflow boundaries.&lt;/li>
&lt;li>Particle boundaries.&lt;/li>
&lt;/ul>
&lt;p>These boundaries can be combined in different ways to give different
effects. From the end user perspective there are 4 boundaries which can be
applied to each edge of the simulation domain. These are&lt;/p>
&lt;ul>
&lt;li>Periodic
&lt;ul>
&lt;li>Particles periodic&lt;/li>
&lt;li>Fields periodic&lt;/li>
&lt;li>Lasers off&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Other
&lt;ul>
&lt;li>Particles reflect&lt;/li>
&lt;li>Fields clamped zero&lt;/li>
&lt;li>Lasers off&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Simple Laser
&lt;ul>
&lt;li>Particles transmissive&lt;/li>
&lt;li>Fields clamped zero&lt;/li>
&lt;li>Lasers applied at half timestep for $B$ field&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Simple outflow
&lt;ul>
&lt;li>Particles transmissive&lt;/li>
&lt;li>Fields clamped zero&lt;/li>
&lt;li>No lasers applied at half timestep, but outflow conditions applied
to $B$ field at half timestep&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>The boundary conditions are applied in too many places in the code to give a
full description of them, but the laser boundaries are only applied in
&lt;code>src/fields.f90&lt;/code>. The boundaries requested by the user are converted
into the conditions on the fields and particles in the routine
&lt;code>setup_particle_boundaries&lt;/code> in
&lt;code>src/boundaries.F90&lt;/code>. For each of the six possible boundaries
(x_min, x_max, y_min, y_max, z_min, z_max) there is a variable which will
be named something like &lt;code>bc_x_min_particle&lt;/code> or
&lt;code>bc_y_max_field&lt;/code> which controls the boundary condition which will
be applied to either the field or the particles.&lt;/p>
&lt;h2 id="simple-field-boundaries">Simple field boundaries&lt;/h2>
&lt;p>There are two subroutines which apply the standard boundary conditions:
&lt;code>field_zero_gradient&lt;/code> and &lt;code>field_clamp_zero&lt;/code>. The
type of boundary condition that the two apply is obvious from the name, but
the two functions have different calling conventions.&lt;/p>
&lt;pre>&lt;code class="language-perl">SUBROUTINE field_zero_gradient
REAL(num), DIMENSION(-2:,-2:,-2:), INTENT(INOUT) :: field
INTEGER, INTENT(IN) :: stagger_type, boundary
&lt;/code>&lt;/pre>
&lt;p>&lt;code>field_zero_gradient&lt;/code> is the routine which applies zero gradient
boundary conditions to a field variable passed in the parameter
&lt;code>field&lt;/code>. The remaining two parameters are the stagger type and
the boundary number. These are named constants defined in
&lt;code>src/shared_data.F90&lt;/code>, &lt;code>c_stagger_*&lt;/code> for the
stagger type and &lt;code>c_bd_*&lt;/code> for the boundary number.
The routine can be used as a global field boundary condition by
setting one of the field boundary conditions to c_bc_zero_gradient in
&lt;code>setup_particle_boundaries&lt;/code>, but it is mostly used to give
boundary conditions for the autoloader.&lt;/p>
&lt;pre>&lt;code class="language-perl">SUBROUTINE field_clamp_zero
REAL(num), DIMENSION(-2:,-2:,-2:), INTENT(INOUT) :: field
INTEGER, INTENT(IN) :: stagger_type, boundary
&lt;/code>&lt;/pre>
&lt;p>&lt;code>field_clamp_zero&lt;/code> is the routine which clamps the field given by
the &lt;code>field&lt;/code> variable to zero on the boundary.
The remaining two parameters are the stagger type and
the boundary number. These are named constants defined in
&lt;code>src/shared_data.F90&lt;/code>, &lt;code>c_stagger_*&lt;/code> for the
stagger type and &lt;code>c_bd_*&lt;/code> for the boundary number.&lt;/p>
&lt;p>Additional boundary conditions should follow the same basic principle as these
routines. Note that all of the routines test for
&lt;code>\{x,y,z\}_\{min,max\}_boundary&lt;/code> to confirm that a given processor is at the
edge of the real domain, and so should have a real boundary condition applied
to it. This also explains why there are no explicit periodic boundary condition
routines, since by connecting the processors cyclically in a periodic direction
the domain boundary effectively becomes another internal processor boundary.&lt;/p>
&lt;h2 id="laser-and-outflow-boundaries">Laser and outflow boundaries&lt;/h2>
&lt;p>The laser boundaries in EPOCH are based on a rewriting of Maxwell&amp;rsquo;s
equations (combining Ampere-Maxwell and Faraday-Lenz) into a new form which
expresses the fields explicitly in terms of waves
propagating in both directions along each co-ordinate axis with both S and P
polarisation states. In the $x$ direction,&lt;/p>
&lt;p>$$
\partial_t(E_y \pm cB_z) \pm \partial_x(E_y \pm cB_z) = \pm \partial_yE_x c + \partial_zB_x c^2 -\frac{j_y}{\epsilon_0}
$$&lt;/p>
&lt;p>$$
\partial_t(E_z \mp cB_y) \pm \partial_x(E_z \mp cB_y) = \pm \partial_zE_x c - \partial_yB_x c^2 -\frac{j_z}{\epsilon_0}
$$&lt;/p>
&lt;p>It is then possible to rewrite these equations to provide a boundary condition
on $B_z$ and $B_y$ to give propagating EM waves at the boundary. For waves
travelling into the boundary, this gives a transmissive boundary, and if the
components for waves propagating out from the boundary are set to be non-zero
then it also introduces an EM wave propagating from the left boundary.&lt;/p>
&lt;p>This boundary condition is found in the file &lt;code>laser.f90&lt;/code> which also
includes the routines for handling the &lt;code>laser_block&lt;/code> objects which
represent how lasers are represented in EPOCH.&lt;/p>
&lt;h2 id="particle-boundaries">Particle boundaries&lt;/h2>
&lt;p>Due to the time that is required to loop over all the particles the particle
boundary conditions in EPOCH combine the inter-processor boundary conditions
with the real boundary conditions. The boundary conditions for particles are in
the routine &lt;code>particle_bcs&lt;/code> in the file &lt;code>boundary.f90&lt;/code>&lt;br>
Currently EPOCH includes only three particle boundary conditions&lt;/p>
&lt;ul>
&lt;li>c_bc_open - Particles pass through the boundary and are destroyed. Total
pseudoparticle number is not conserved in this mode.&lt;/li>
&lt;li>c_bc_periodic - Particles which leave one side of the box reappear on
the other side.&lt;/li>
&lt;li>c_bc_reflect - Particles reflect off the boundary as if it was a hard
boundary.&lt;/li>
&lt;/ul>
&lt;p>Although the routine looks rather messy, it is fairly easy to understand. The
sequence goes:&lt;/p>
&lt;ul>
&lt;li>Loop over all species.&lt;/li>
&lt;li>Create particle list objects for particles to be sent to and received from
other processors.&lt;/li>
&lt;li>Loop over all particles in the species.&lt;/li>
&lt;li>If the particle has crossed a local boundary then it either
has crossed the boundary of the problem domain and needs a boundary condition
to be applied or it has just crossed a processor boundary and
needs to be transferred to a neighbouring process. Set
&lt;code>{x,y,z}bd&lt;/code> which is used to identify which processor relative
to the current processor the particle potentially needs to be moved to and
then test for the domain boundary.&lt;/li>
&lt;li>If the particle has crossed an open domain boundary then either add it to
another list to be dumped to disk if the user has requested this, or
otherwise just deallocate the particle to reclaim memory. Set
&lt;code>out_of_bounds&lt;/code> to indicate that the particle has left the
system.&lt;/li>
&lt;li>If the particle has crossed the domain boundary and that boundary has
reflecting boundary conditions then reflect the particle.&lt;/li>
&lt;li>If the particle has crossed the domain boundary and that boundary has
periodic boundary conditions then move the particle to the opposite side
of the domain.&lt;/li>
&lt;li>End particle loop.&lt;/li>
&lt;li>Remove all the particles which have left the current process.&lt;/li>
&lt;li>Loop over all possible neighbouring processors for the current processor
and exchange particle lists with that processor.&lt;/li>
&lt;li>Add any received particles onto the particle list for the current
species.&lt;/li>
&lt;li>End species loop.&lt;/li>
&lt;/ul>
&lt;p>Note that, unlike for fields, there is explicit periodic boundary code. This is
because although the MPI routines place the particle on the correct processor
after the MPI routines, the particle&amp;rsquo;s position variable still places it beyond
the other end of the domain. The MPI parallelism for exchanging particles is
hidden in the routines which deal with the particle list objects and are
described in the next section.&lt;/p>
&lt;h2 id="mpi-boundaries">MPI Boundaries&lt;/h2>
&lt;p>There are three routines which deal with MPI exchange for field variables in
EPOCH. Two are closely related and will be considered together. The third
deals with using MPI to sum variables at processor boundaries rather than
synchronise ghost cells.&lt;/p>
&lt;pre>&lt;code class="language-perl">SUBROUTINE field_bc
REAL(num), DIMENSION(-2:,-2:,-2:), INTENT(INOUT) :: field
&lt;/code>&lt;/pre>
&lt;p>&lt;code>field_bc&lt;/code> exchanges the information in the ghost cells between
adjacent processors. Any field variable which is used in a calculation that
requires operations involving information from points other than the
current point should call this routine each time the variable is updated. This
will ensure that the ghost cells are populated from adjacent processors.
(i.e. if you only need to access field(ix,iy,iz) there is no need to update
ghost cells, whilst if you use field(ix-1,iy,iz) you do).&lt;/p>
&lt;p>The &lt;code>field_bc&lt;/code> routine just calls the
&lt;code>do_field_mpi_with_lengths&lt;/code> routine which is a more general
routine that allows ghost cell information to be exchanged for fields with
an arbitrary number of cells, rather than fields which are
(-2:nx+3,-2:ny+3,-2:nz+3). This routine is used internally in the load
balancing routine when fields with both the old and new sizes must be handled
at the same time.&lt;/p>
&lt;pre>&lt;code class="language-perl">SUBROUTINE processor_summation_bcs
REAL(num), DIMENSION(-2:,-2:,-2:), INTENT(INOUT) :: field
INTEGER, INTENT(IN), OPTIONAL :: flip_direction
&lt;/code>&lt;/pre>
&lt;p>&lt;code>processor_summation_bcs&lt;/code> is a routine which is used to deal with
variables, like $\vec{j}$ or number density that should be added at boundaries
to include contributions from particles on both sides of a processor boundary.
The routine is used for the current inside the particle pusher and inside most
of the routines for calculating derived variables. If you have a variable
which needs to add contributions from adjacent processors then you should
calculate the quantity on each processor, including contributions from the
particles to the ghost cells and then call this routine. When reflecting
boundary conditions are in operation, the current in the direction crossing
the boundary needs to be flipped over. This is decided upon using the
&lt;code>flip_direction&lt;/code> parameter.&lt;/p>
&lt;p>These routines can be used for most MPI calls required by all but the most
extreme modifications to EPOCH.&lt;/p></description></item><item><title>Current solver</title><link>/developer/core_structure/current_solver.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/current_solver.html</guid><description>&lt;p>EPOCH uses the
&lt;a href="https://www.sciencedirect.com/science/article/abs/pii/001046559290169Y" target="_blank" rel="noopener">Villasenor and Buneman&lt;/a> current calculating scheme which
solves the additional equation
${\partial \rho}/{\partial t} = \nabla\cdot\vec{J}$ to
calculate the current at each timestep. The main advantage of this scheme is
that it conserves charge &lt;em>on the grid&lt;/em> rather than just globally conserving
charge on the particles. This means that the error in the solution to Gauss&amp;rsquo;s
law is conserved, so if Gauss&amp;rsquo;s law is satisfied for $t = 0$ it
remains satisfied for all time.&lt;/p>
&lt;p>The Villasenor and Buneman scheme works because exactly the same charge added
to one cell is subtracted from another cell, which in turn means that exactly
the same current added to one cell is subtracted from another cell. This is
intuitively correct since a point particle crossing a cell boundary would
represent the loss of that particle&amp;rsquo;s contribution to the current from the
source cell and the gain of that particle&amp;rsquo;s contribution to the current by the
destination cell. In fact this simple type of cell boundary crossing
current calculation was used in classical Buneman type PIC codes.&lt;/p>
&lt;p>The scheme is messy, in practise, but simple. After the main particle push, the
particle is advanced a further half timestep into the future to first order
using the velocities calculated at the end of the particle push. The particle
position at $t + dt/2$ were stored earlier, and combined with the newly
calculated particle position at $t + {3dt}/{2}$ this allows a time centred
evaluation of ${\partial \rho}/{\partial t}$ meaning that the current
update is second order accurate in time. The spatial order of the scheme
matches the spatial order of the particle weight function.&lt;/p>
&lt;p>The weight functions for transferring particle properties onto the grid at the
two timesteps are calculated including a shift when necessary to allow for the
particle having crossed a cell boundary. Since the charge associated with the
particle is spatially distributed using the weight function, all that is
necessary to calculate ${\partial \rho}/{\partial t}$ is to subtract the
two functions, multiply by the charge on the pseudoparticle and the
pseudoparticle weight and finally divide by $dt$. The spatial derivative of
$\vec{J}$ is then converted to a one sided finite difference form and solved
directly. In multiple dimensions this is slightly complicated by the effects of
offsets in directions other than the direction that a given current component
is pointing in, with this adding additional weight factors based on the overlap
of the shape functions in other directions. This is explained in full in the
Villasenor and Buneman paper already quoted.&lt;/p>
&lt;p>Currents in ignorable directions are simply calculated using $J = n\rho\vec{v}$
with the correct shape functions to ensure that the current is placed in the
correct places.&lt;/p>
&lt;h2 id="example">Example&lt;/h2>
&lt;p>In EPOCH2D V4.19.2, the source-code for the current update looks like this:&lt;/p>
&lt;pre>&lt;code> jyh = 0.0_num
DO iy = ymin, ymax
cy = cell_y1 + iy
yfac1 = gy(iy) + 0.5_num * hy(iy)
yfac2 = third * hy(iy) + 0.5_num * gy(iy)
hy_iy = hy(iy)
jxh = 0.0_num
DO ix = xmin, xmax
cx = cell_x1 + ix
xfac1 = gx(ix) + 0.5_num * hx(ix)
wx = hx(ix) * yfac1
wy = hy_iy * xfac1
wz = gx(ix) * yfac1 + hx(ix) * yfac2
! This is the bit that actually solves d(rho)/dt = -div(J)
jxh = jxh - fjx * wx
jyh(ix) = jyh(ix) - fjy * wy
jzh = fjz * wz
jx(cx, cy) = jx(cx, cy) + jxh
jy(cx, cy) = jy(cx, cy) + jyh(ix)
jz(cx, cy) = jz(cx, cy) + jzh
END DO
END DO
&lt;/code>&lt;/pre>
&lt;p>At this point in the code, &lt;code>gx&lt;/code> and &lt;code>gy&lt;/code> contain the weight distribution of
the macro-particle at time $t+dt/2$, where the 0 index in these arrays
correspond to the cell containing the macro-particle centre at this time (or
the low-x, low-y corner for TOPHAT shapes). The &lt;code>hx&lt;/code> and &lt;code>hy&lt;/code> parameters contain
the difference of weights in each cell between $t+3dt/2$ and $t+dt/2$. The loop
occurs from &lt;code>gx&lt;/code> index &lt;code>xmin&lt;/code> to &lt;code>xmax&lt;/code>, and &lt;code>gy&lt;/code> index &lt;code>ymin&lt;/code> to &lt;code>ymax&lt;/code>. These
min/max indices will describe an array which has the same size as the number of
cells which the macro-particle shape has touched over the time-step.&lt;/p>
&lt;p>As an example, consider the $j_x$ update. For cell index &lt;code>ix=xmin&lt;/code>, we first
calculate the average y-weight for each &lt;code>iy&lt;/code> using the line:&lt;/p>
&lt;pre>&lt;code> yfac1 = gy(iy) + 0.5_num * hy(iy)
&lt;/code>&lt;/pre>
&lt;p>as &lt;code>gy(iy)&lt;/code> is the initial y-weight, and &lt;code>gy(iy) + hy(iy)&lt;/code> is the final
y-weight. We assume the macro-particle moves at a constant speed when taking the
average. Hence, the change in macro-particle weight due to motion in the $x$
direction from the &lt;code>ix=xmin&lt;/code> cell is &lt;code>hx(xmin) * (gy(iy) + 0.5*hy(iy))&lt;/code>. In the
code, this is &lt;code>wx&lt;/code>. We can multiply this by the macro-particle charge
(charge * weight) to get the charge change due to $x$ motion, divide by &lt;code>dt&lt;/code> to
get a current, and divide by &lt;code>dy&lt;/code> to get the current per unit area
(as &lt;code>dz&lt;/code> = 1m in EPOCH2D). These particle variables and simulation constants are
contained in the &lt;code>fjx&lt;/code> variable.&lt;/p>
&lt;p>Finally, we must remember that this refers to the total current density change
in the cell - we do not know the boundary this current flows through. In the
&lt;code>xmin&lt;/code> cell, we know no macro-particle weight enters &lt;code>xmin-1&lt;/code> by definition of
&lt;code>xmin&lt;/code>, so all the current density flows into the cell with &lt;code>ix=xmin+1&lt;/code>. Hence,
the current change is unambiguous here. If there is no current change in
&lt;code>xmin+1&lt;/code>, then an equal current must flow in and out. We have just calculated
the &lt;code>xmin&lt;/code> to &lt;code>xmin+1&lt;/code> current, so we can subtract this from the new cell to
determine the current on the next boundary. Because we need to remember the
current from the previous calculation, we must subtract &lt;code>jxh&lt;/code> from the
previously calculated &lt;code>jxh&lt;/code> in:&lt;/p>
&lt;pre>&lt;code>jxh = jxh - fjx * wx
&lt;/code>&lt;/pre>
&lt;p>This calculation may then iterate through the particle shape, until the $j_x$
contribution from this macro-particle is recorded in all cells it influences.
The remaining current density components can be calculated using similar logic.&lt;/p></description></item><item><title>Custom Deck</title><link>/developer/input_output/custom_deck.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/custom_deck.html</guid><description>&lt;p>For some types of changes to the code it is more convenient to have the end
user pass new parameters into the code. This can be for several reasons, and
the section on permanent additions to the input deck is given in extensions. At
this stage, we will describe how to temporarily add new
elements to the input deck parser routines, allowing parameterising of
internal and manual initial conditions.&lt;/p>
&lt;p>Custom input deck elements are setup in the file
&lt;code>src/user_interaction/custom_deck.f90&lt;/code>. The function
&lt;code>custom_blocks_handle_element&lt;/code> is called when a new block is
started which the core parser is not familiar with, and once for each element
of a block. The function &lt;code>custom_blocks_check&lt;/code> is called once the
entire deck has been parsed and is used to check that all the elements which
are required for the code to run have been specified.&lt;/p>
&lt;h2 id="custom_blocks_handle_element">custom_blocks_handle_element&lt;/h2>
&lt;p>There are three parameters passed to
&lt;code>custom_blocks_handle_element&lt;/code>, which are:&lt;/p>
&lt;ul>
&lt;li>block_name - The name of the block specified in the
&lt;code>begin:blockname&lt;/code> part of the input deck.&lt;/li>
&lt;li>element - The name of the element in an input deck
&lt;code>element = value&lt;/code> pair.&lt;/li>
&lt;li>value - The string representation of the value in an input deck
&lt;code>element = value&lt;/code> pair.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>custom_blocks_handle_element&lt;/code> is first called when a new block
is begun
using &lt;code>begin:blockname&lt;/code> and &amp;ldquo;blockname&amp;rdquo; is not recognised by the
core input deck parser. The first thing that it does is test whether or not it
is a valid custom block. The code does this by passing in the blockname with
&lt;code>element&lt;/code> and &lt;code>value&lt;/code> set to the special constant called
&amp;ldquo;blank&amp;rdquo;. When extending the input deck, an end user should check if either
&lt;code>element&lt;/code> or &lt;code>value&lt;/code> are set to the special constant
&amp;ldquo;blank&amp;rdquo;, and if they are then test to see whether the blockname is known or
not. If the blockname is known then the code should return the error code
&lt;code>c_err_none&lt;/code> (No error). If the blockname is not known then the
code should return &lt;code>c_err_unknown_block&lt;/code> and the deck parser will
just skip the block. In operation, this looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_blocks_handle_element(block_name, element, value) &amp;amp;
RESULT(errcode)
CHARACTER(LEN=string_length), INTENT(IN) :: block_name, element, value
INTEGER :: errcode
IF (str_cmp(block_name, &amp;quot;custom&amp;quot;)) THEN
IF (element .EQ. blank .OR. value .EQ. blank) THEN
! If element or value are blank then just testing block so
! return c_err_none
errcode = c_err_none
RETURN
ENDIF
ENDIF
! The following line must always be present
errcode = c_err_unknown_block
END FUNCTION custom_blocks_handle_element
&lt;/code>&lt;/pre>
&lt;p>In order to simplify Fortran&amp;rsquo;s rather annoying string handling behaviour,
several helper functions have been defined and the most used one is
&lt;code>str_cmp(string1, string2)&lt;/code>. This is a simple routine which returns
true if string1 == string2 and false otherwise. It is case sensitive but can
deal with differing string lengths etc. The next stage is to deal with the
actual &lt;code>element = value&lt;/code> pairs in the deck. Each time that a new pair
is read from the deck, &lt;code>custom_blocks_handle_element&lt;/code> is called
with &lt;code>element&lt;/code> and &lt;code>value&lt;/code> having the values read from the
deck. To test for known elements they should just be checked against a known
list of names using &lt;code>str_cmp&lt;/code> and return the error code
&lt;code>c_err_unknown_element&lt;/code> if the element isn&amp;rsquo;t a known element. This
looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_blocks_handle_element(block_name, element, value) &amp;amp;
RESULT(errcode)
CHARACTER(LEN=string_length), INTENT(IN) :: block_name, element, value
INTEGER :: errcode
IF (str_cmp(block_name, &amp;quot;custom&amp;quot;)) THEN
IF (element .EQ. blank .OR. value .EQ. blank) THEN
! If element or value are blank then just testing block so
! return c_err_none
errcode = c_err_none
RETURN
ENDIF
errcode = c_err_unknown_element
! Now test for the real elements
IF (str_cmp(element, &amp;quot;int_element&amp;quot;)) THEN
errcode = c_err_none
ENDIF
IF (str_cmp(element, &amp;quot;real_element&amp;quot;)) THEN
errcode = c_err_none
ENDIF
IF (str_cmp(element, &amp;quot;logical_element&amp;quot;)) THEN
errcode = c_err_none
ENDIF
RETURN
ENDIF
! The following line must always be present
errcode = c_err_unknown_block
END FUNCTION custom_blocks_handle_element
&lt;/code>&lt;/pre>
&lt;p>This version of the code will allow you to add a new block called &amp;ldquo;custom&amp;rdquo;
with elements
&amp;ldquo;int_element&amp;rdquo;, &amp;ldquo;real_element&amp;rdquo; and &amp;ldquo;logical_element&amp;rdquo; and the
code will parse them successfully, while any other block or any other element
in the block &amp;ldquo;custom&amp;rdquo; will throw errors. However, at this stage the code
doesn&amp;rsquo;t actually read any of the values from the deck. To make it useful, any
variable which is read from the input deck must be stored in a global
variable. Defining global variables are explained in more detail in the
relevant section of the manual, but in short, any variable defined in the
module &lt;code>shared_data&lt;/code> in the file &lt;code>src/shared_data.F90&lt;/code>
will be a global variable. After the variables have been setup, there are once
again helper functions to make converting the text from the deck into a normal
Fortran90 variable. These helper functions are:&lt;/p>
&lt;ul>
&lt;li>as_integer - Attempts to convert a string to an integer. Invokes the
maths parser.&lt;/li>
&lt;li>as_real - Attempts to convert a string to a REAL(num). Invokes the maths
parser.&lt;/li>
&lt;li>as_logical - Attempts to convert a string to a logical. Does not invoke
the maths parser (must be either &amp;ldquo;T&amp;rdquo; or &amp;ldquo;F&amp;rdquo;).&lt;/li>
&lt;/ul>
&lt;p>They are used pretty much as expected, except that the return value is passed
to the functions so that they can report errors while trying to parse the
string. An example would then be:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_blocks_handle_element(block_name, element, value) &amp;amp;
RESULT(errcode)
CHARACTER(LEN=string_length), INTENT(IN) :: block_name, element, value
INTEGER :: errcode, int_element
REAL(num) :: real_element
LOGICAL :: logical_element
IF (str_cmp(block_name, &amp;quot;custom&amp;quot;)) THEN
IF (element .EQ. blank .OR. value .EQ. blank) THEN
! If element or value are blank then just testing block so
! return c_err_none
errcode = c_err_none
RETURN
ENDIF
errcode = c_err_unknown_element
! Now test for the real elements
IF (str_cmp(element, &amp;quot;int_element&amp;quot;)) THEN
errcode = c_err_none
int_element = as_integer(value, errcode)
ENDIF
IF (str_cmp(element, &amp;quot;real_element&amp;quot;)) THEN
errcode = c_err_none
real_element = as_real(value, errcode)
ENDIF
IF (str_cmp(element, &amp;quot;logical_element&amp;quot;)) THEN
errcode = c_err_none
logical_element = as_logical(value, errcode)
ENDIF
RETURN
ENDIF
! The following line must always be present
errcode = c_err_unknown_block
END FUNCTION custom_blocks_handle_element
&lt;/code>&lt;/pre>
&lt;p>It is possible to perform more advanced types of evaluation of maths
expressions such as reading arrays etc. but this is beyond the scope of this
manual at present.&lt;/p>
&lt;h2 id="custom_blocks_check">custom_blocks_check&lt;/h2>
&lt;p>This function is called when all the blocks in the input deck have been
evaluated and is used to check that all required parameters have been set. If
all required elements have been set then you should just return
&lt;code>c_err_none&lt;/code>, otherwise return
&lt;code>c_err_missing_elements&lt;/code>. How you test that required elements have
been set is up to the developer, and for testing and personal use (which is
all that the custom deck parts of the code should be used for) it is
acceptable to just not check and always return &lt;code>c_err_none&lt;/code>. If
permanently expanding the deck, error trapping should always be written.&lt;/p></description></item><item><title>Custom Maths Parser</title><link>/developer/input_output/custom_maths_parser.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/custom_maths_parser.html</guid><description>&lt;p>Sometimes the complexity in changing the input.deck file is due to the fact that
a function which must be used is fairly complex in form and is not supplied
with the core code. It must therefore be represented in the input deck maths
parser. This can be a significant cause of complexity for some problems, and
in this case, there are three options:&lt;/p>
&lt;ol>
&lt;li>Put up with it and implement in the deck&lt;/li>
&lt;li>Use the internal initial conditions rather than the deck&lt;/li>
&lt;li>Extend the maths parser to include your function&lt;/li>
&lt;/ol>
&lt;p>Extending the maths parser can either
be permanent (described in extensions) or temporary (described
here). All of the routines used in extending the maths parser are in the file
&lt;code>user_interaction/custom_parser.f90&lt;/code>. Temporarily adding elements to the parser
is much easier than a permanent addition. It is
possible to add new constants and functions to the maths parser. It is hoped
that in a future release of EPOCH this will be extended to allow custom
operators as well.&lt;/p>
&lt;p>As an example, lets look at adding a new function (lorentz) for a
Lorentzian distribution, and adding a new constant, phi.&lt;/p>
&lt;h2 id="registering-your-new-constantfunction">Registering your new constant/function&lt;/h2>
&lt;p>Before a new constant or function
can be defined it must be registered. In the registration phase the text
representation of the function or constant is given to the parser subroutines
and the user is returned an integer handle for the registered object. The
numerical handle must be stored so that that all of the functions in this
module can access it, so they should be placed after the &lt;code>IMPLICIT NONE&lt;/code> statement at the top of the file and defined as:&lt;/p>
&lt;pre>&lt;code class="language-perl">INTEGER :: c_func_lorentz
INTEGER :: c_const_phi
&lt;/code>&lt;/pre>
&lt;p>Note that the names given to the constants is obviously at the developers
discretion, but these names comply with the EPOCH style guide.
Actually registering the objects is done in the &lt;code>register_objects&lt;/code>
subroutine which should include lines to register functions and constants.
An example is given below.&lt;/p>
&lt;pre>&lt;code class="language-perl">SUBROUTINE register_objects
c_func_lorentz = register_function(&amp;quot;lorentz&amp;quot;)
c_const_phi = register_constant(&amp;quot;phi&amp;quot;)
END SUBROUTINE register_objects
&lt;/code>&lt;/pre>
&lt;p>Note that the input deck parser is case sensitive, so the strings which are
given to &lt;code>register_function&lt;/code> and &lt;code>register_constant&lt;/code>
should be in the case that they will appear in the input deck. To follow the
EPOCH style guide this should be all lowercase. At this point, the maths
parser would start to recognise the new function/constant, but would still
give error messages since they haven&amp;rsquo;t yet been implemented.&lt;/p>
&lt;h2 id="setting-up-new-constants">Setting up new constants&lt;/h2>
&lt;p>Once a new constant has been registered it must be described using the
&lt;code>custom_constant&lt;/code> function. In 2D this function looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_constant(opcode, ix, iy, errcode)
INTEGER, INTENT(IN) :: opcode, ix, iy
INTEGER, INTENT(INOUT) :: errcode
REAL(num) :: custom_constant
! Leave these lines in place. They cause the code to throw an error if
! The opcode is unknown
custom_constant = 0.0_num
errcode = IOR(errcode, c_err_unknown_element)
END FUNCTION custom_constant
&lt;/code>&lt;/pre>
&lt;p>The parameters are&lt;/p>
&lt;ul>
&lt;li>&lt;code>opcode&lt;/code> - The operator code of the constant requested. This will be the
integer handle returned from &lt;code>register_constant&lt;/code>.&lt;/li>
&lt;li>&lt;code>ix&lt;/code>, &lt;code>iy&lt;/code>, &lt;code>iz&lt;/code> - Some constants are actually evaluated at specific points in
space and ix, iy, iz are the gridpoint number of the location currently being
evaluated. If you are specifying a simple constant then just ignore
these. If your constant does depend upon space then directly subscript your
array with ix, iy, iz as needed to read the correct location.&lt;/li>
&lt;li>&lt;code>errcode&lt;/code> - The error code which should be passed back to the
parser. If for some reason you cannot evaluate your constant then you should
&lt;code>IOR&lt;/code> errcode with the appropriate error code (all the error
codes are listed in appendix A). Note that errcode should never be SET to
any specific error code when extending the parser, since this might
overwrite errors put in place earlier in the parsing sequence. This is
different to extending the input deck where the error code is set.&lt;/li>
&lt;/ul>
&lt;p>The function should just return the evaluated value of the constant requested
by &lt;code>opcode&lt;/code>. This might look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_constant(opcode, ix, iy, errcode)
INTEGER, INTENT(IN) :: opcode, ix, iy
INTEGER, INTENT(INOUT) :: errcode
REAL(num) :: custom_constant
IF (opcode .EQ. c_const_phi) THEN
custom_constant = pi
RETURN
ENDIF
! Leave these lines in place. They cause the code to throw an error if
! The opcode is unknown
custom_constant = 0.0_num
errcode = IOR(errcode, c_err_unknown_element)
END FUNCTION custom_constant
&lt;/code>&lt;/pre>
&lt;p>Note that when &lt;code>opcode&lt;/code> is successfully recognised, the code sets
the return value and returns straight away. This is how all constants should
work, since the last line forces the function to return an error code. This
last line is in place to trap people registering constants but never defining
them. Without this line, it is possible to define a constant which is
never specified and have the code complete OK with a random value for that
constant.&lt;/p>
&lt;p>The constant &amp;ldquo;phi&amp;rdquo; should now work fine when used anywhere in the input deck
and will return a value of $\pi$.&lt;/p>
&lt;h2 id="setting-up-new-functions">Setting up new functions&lt;/h2>
&lt;p>Setting up the new function &lt;code>lorentz&lt;/code> is very similar to setting up
the new constant. The relevant function is &lt;code>custom_function&lt;/code> and
when empty looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_function(opcode, ix, iy, errcode)
INTEGER, INTENT(IN) :: opcode, ix, iy
INTEGER, INTENT(INOUT) :: errcode
REAL(num) :: custom_function
REAL(num) :: values(5)
! Leave these lines in place. They cause the code to throw an error if
! The opcode is unknown
custom_function = 0.0_num
errcode = IOR(errcode, c_err_unknown_element)
END FUNCTION custom_function
&lt;/code>&lt;/pre>
&lt;p>The parameters are&lt;/p>
&lt;ul>
&lt;li>&lt;code>opcode&lt;/code> - The operator code of the constant requested. This will be the
integer handle returned from \inlinecode {register_function}.&lt;/li>
&lt;li>&lt;code>ix&lt;/code>, &lt;code>iy&lt;/code>, &lt;code>iz&lt;/code> - Some functions are evaluated differently at specific points
in space and ix, iy, iz are the gridpoint number of the location currently
being evaluated. If you are specifying a simple function then just
ignore these. If your function does depend upon space then directly
subscript your array with ix, iy, iz as needed to read the correct location.&lt;/li>
&lt;li>&lt;code>errcode&lt;/code> - The error code which should be passed back to the
parser. If for some reason you cannot evaluate your function then you should
&lt;code>IOR&lt;/code> errcode with the appropriate error code. Note that errcode
should never be SET to any specific error code, since this might overwrite
errors put in place earlier in the parsing sequence.&lt;/li>
&lt;/ul>
&lt;p>The function should return the value of your evaluated constant. The
parameters which are passed to the function can be retrieved by the function
&lt;code>get_values(n, values)&lt;/code>, where &lt;code>n&lt;/code> is the number of
parameters to be returned and &lt;code>values&lt;/code> is a &lt;code>REAL(num)&lt;/code>
array of length &lt;code>n&lt;/code> which will hold the returned values . In this
implementation of the Lorentzian function there are three parameters: The
dependent variable, the location parameter and the scale parameter. The code
to implement the function therefore looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_function(opcode, ix, iy, errcode)
INTEGER, INTENT(IN) :: opcode, ix, iy
INTEGER, INTENT(INOUT) :: errcode
REAL(num) :: custom_function
REAL(num) :: values(5)
IF (opcode .EQ. c_func_lorentz) THEN
CALL get_values(3, values(1:3))
! values(1) - Dependent variable
! values(2) - location parameter
! values(3) - scale parameter
custom_function = values(3)**2/((values(1)-values(2))**2+values(3)**2)
RETURN
ENDIF
! Leave these lines in place. They cause the code to throw an error if
! The opcode is unknown
custom_function = 0.0_num
errcode = IOR(errcode, c_err_unknown_element)
END FUNCTION custom_function
&lt;/code>&lt;/pre>
&lt;p>This function is then available at any point in the input deck and if I return
to the previous example ic.deck file, it would be used as follows:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
particle_density = 100.0 # Particle number density
profile_x = lorentz(x,0.0,1.0)
profile_y = lorentz(y,0.0,1.0)
end:constant
begin:species
name = s1
# multiply density by real particle density
density = particle_density * profile_x * profile_y
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum density for this species
density_min = 0.3*particle_density
end:species
begin:species
name = s2
# Just copy the density for species s1
density = density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum density for this species
density_min = 0.3*particle_density
end:species
&lt;/code>&lt;/pre>
&lt;p>It is therefore clear that the new lorentz function is essentially the same as
the built in gauss function. Note that due to the way that the parser works,
the end user is not required to deal with parameters which are themselves
maths expressions. They have been fully evaluated by the time they are
returned by &lt;code>get_values&lt;/code>. Note that the parser is not guaranteed to
be bulletproof. If a user calls &lt;code>get_values&lt;/code> requesting more
parameters than have been passed to the function then it will scramble the
stack which is used by the parser and cause the code to fail. Note that
calling &lt;code>get_values(2, values)&lt;/code> is not the same as calling
&lt;code>get_values(1, values)&lt;/code> twice, in fact calling
&lt;code>get_values(1, values)&lt;/code> multiple times will return the parameters in
&lt;em>reverse&lt;/em> order. This is normal and is a feature of how the maths parser
operates. It is possible to use this property to write functions which have a
variable number of parameters, but this is not recommended.&lt;/p></description></item><item><title>Error Codes</title><link>/developer/input_output/error_codes.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/error_codes.html</guid><description>&lt;p>The input deck and maths parser in EPOCH use various named error codes to
report on errors which occur during the evaluation of the input deck. These
codes are&lt;/p>
&lt;ul>
&lt;li>&lt;code>c_err_none&lt;/code> - No error. Set an error code to c_err_none to state that
no error has occurred.&lt;/li>
&lt;li>&lt;code>c_err_unknown_block&lt;/code> - In the input deck a block has been found which is
not known. This should be returned in
&lt;code>custom_blocks_handle_element&lt;/code> if it is passed any block that it has not been written to handle.&lt;/li>
&lt;li>&lt;code>c_err_unknown_element&lt;/code> - In the input deck an element of a valid block
has been found which is not known. This should be returned in
&lt;code>custom_blocks_handle_element&lt;/code> if an element is requested which is
unknown.&lt;/li>
&lt;li>&lt;code>c_err_preset_element&lt;/code> - An element of the input deck has already been
set and is being set again. Usually this is an indication of a malformed input
deck file, so &lt;code>custom_blocks_handle_element&lt;/code> should try to
identify such situations and return this error message if
subsequent attempts to set the variable are being ignored.&lt;/li>
&lt;li>&lt;code>c_err_preset_element_use_later&lt;/code> - An element of the input deck has
already been set and is being set again. Usually this is an indication of a
malformed input deck file, so &lt;code>custom_blocks_handle_element&lt;/code> should try to
identify such situations and return this error message if
the subsequent attempts to set the variable override previous ones.&lt;/li>
&lt;li>&lt;code>c_err_bad_value&lt;/code> - A value which is being evaluated for the right
hand side of an element assignment is in some way invalid. Internally to the
code this usually means that a string which must be interpreted as a maths
expression or numerical constant is in some way malformed. It is also
acceptable to return this error code when a value has been passed which is
invalid for some other reason (the value is outside an acceptable range, etc.)&lt;/li>
&lt;li>&lt;code>c_err_missing_elements&lt;/code> - This is an error code returned when the
code is testing to make sure that all necessary elements of an input deck
file have been specified. It should be returned when some required parameter
is missing in the subroutine &lt;code>custom_blocks_check&lt;/code>.&lt;/li>
&lt;li>&lt;code>c_err_terminate&lt;/code> - This error code means that the code is in a state
where execution is impossible and the code must terminate once the input deck
has been read. Some other error codes automatically set c_err_terminate,
but it can always be IOR&amp;rsquo;ed with any error code to force the code to exit.
Note that just returning c_err_terminate will cause the code to
silently quit.&lt;/li>
&lt;li>&lt;code>c_err_required_element_not_set&lt;/code> - This means that the code
cannot parse an input deck element since another element which must be known
beforehand has not been set. This is intended for things like setting the
species information where the number of species must be known in
advance. This error code uses the extended error string to give user friendly
feedback. If you return this error code then you should set
extended_error_string to be equal to the name of the required element which
has not been set. If multiple previous elements are required then the code
should be set up so that it checks for the presence of the required elements
in order and reports on missing elements so that the end user can fix them
one by one.&lt;/li>
&lt;li>&lt;code>c_err_pp_options_wrong&lt;/code> - If you&amp;rsquo;ve written a section of the code that
is controlled by preprocessor options then you should return this
error message if someone attempts to set input deck elements which refer to
that part when the correct preprocessor options are not used. This means that
the user is aware of the fact that the requested feature will not be
active. This error code also uses the extended error string to give user
friendly feedback. If you return this error code, you should set the string
extended_error_string to the define command that would turn on the
requested feature of the code (&amp;quot;-DPER_PARTICLE_WEIGHT&amp;quot;, for example).&lt;/li>
&lt;li>&lt;code>c_err_other&lt;/code> - This error code is a catch all error which causes
the code to quit with a sarcastic error message. It&amp;rsquo;s mainly intended for
debugging and is used before the final error code is implemented.&lt;/li>
&lt;/ul></description></item><item><title>Field Solver</title><link>/developer/core_structure/field_solver.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/field_solver.html</guid><description>&lt;p>Each EPOCH MPI rank tracks a separate part of the simulation domain, using
arrays of indices (1:nx, 1:ny, 1:nz) in 3D. The MPI ranks also track a
small number of cells in neighbouring ranks, such that fields can be
interpolated to macro-particle shapes which extend beyond the boundaries of a
single rank. These additional surrounding copy-cells are termed &amp;ldquo;ghost
cells&amp;rdquo;.&lt;/p>
&lt;h2 id="field-variables">Field variables&lt;/h2>
&lt;p>There are nine variables which are used in updating the EM field solver. These
are&lt;/p>
&lt;ul>
&lt;li>ex - Electric field in the X direction.&lt;/li>
&lt;li>ey - Electric field in the Y direction.&lt;/li>
&lt;li>ez - Electric field in the Z direction.&lt;/li>
&lt;li>bx - Magnetic field in the X direction.&lt;/li>
&lt;li>by - Magnetic field in the Y direction.&lt;/li>
&lt;li>bz - Magnetic field in the Z direction.&lt;/li>
&lt;li>jx - Current in the X direction.&lt;/li>
&lt;li>jy - Current in the Y direction.&lt;/li>
&lt;li>jz - Current in the Z direction.&lt;/li>
&lt;/ul>
&lt;p>The EM fields in EPOCH are simple allocatable arrays, which are of size
(-2:nx+3,-2:ny+3,-2:nz+3), although this includes the ghost cells. The length of
the core domain is different for each variable due to the grid stagger.&lt;/p>
&lt;p>The EPOCH field solver is a Yee staggered 2nd order FDTD scheme, directly
based on the scheme in the PSC by Hartmut Ruhl and is contained in the file
&lt;code>fields.f90&lt;/code>. To locate a variable on the grid there is a simple
rule.&lt;/p>
&lt;ul>
&lt;li>Start at the cell centre.&lt;/li>
&lt;li>For an $E$ field component, move the field half a grid point in the
direction that the field points if possible.&lt;/li>
&lt;li>For a $B$ field component, move the field half a grid point in all
directions &lt;em>except&lt;/em> the one it points.&lt;/li>
&lt;/ul>
&lt;p>This is illustrated below for the 2D case.&lt;/p>
&lt;p>&lt;img src="/developer/stagger.png" alt="The Yee grid in 2D">&lt;/p>
&lt;p>The grid stagger means that you have to be careful with boundary conditions
since some variables are defined on the domain boundaries whereas others are
defined on either side of a domain boundary. This is handled automatically by
the built in boundary routines, but must be understood if developing other
boundary conditions. To explain it, consider only the left/right boundary in 1D
and consider $E_x$ and $B_x$.&lt;/p>
&lt;p>$E_x$ is defined on the cell boundary, so &lt;code>ex(0)&lt;/code> is the value of
$E_x$ on the left boundary and similarly &lt;code>ex(nx)&lt;/code> is the
value on the right boundary. Conversely, in the 1D code $B_x$ is cell centred
(in reality, $B_x$ is never used in the field update and is unimportant since
any gradients in $B_x$ in 1D automatically break the solenoidal condition, but
this is still a useful example.). This means that &lt;code>bx(1)&lt;/code> is the
centre of the first cell in the domain, and &lt;code>bx(0)&lt;/code> is the value at
the centre of the first left hand ghost cell. This means the you must do
different things as boundary conditions for the two fields for some boundary
conditions.&lt;/p>
&lt;p>For example, if you want to clamp the value of $E_x$ to be zero on the
boundary, then just set &lt;code>ex(0) = 0.0_num&lt;/code> since &lt;code>ex(0)&lt;/code>
lies on the boundary. To do the same for $B_x$ on the boundary you have to
set &lt;code>bx(0) = -bx(1)&lt;/code>. This is because if you use a linear
reconstruction of $B_x$ (i.e second order) then the point between
&lt;code>bx(0)&lt;/code> and &lt;code>bx(1)&lt;/code> has the value
$B_x(1/2) = \left(B_x(1)+B_x(0)\right)/2$. Similarly, if you want to set zero
gradient on the boundary then for $E_x$ you set &lt;code>ex(-1) = ex(1)&lt;/code>,
whereas for $B_x$ you would set &lt;code>bx(0) = bx(1)&lt;/code>.&lt;/p>
&lt;p>In the particle pusher, time centred field variables are needed for second
order accuracy, so an FDTD scheme is used to advance the fields. This looks
like&lt;/p>
&lt;ul>
&lt;li>$\vec{E}^{n+\frac{1}{2}} = \vec{E}^n + \frac{\Delta t}{2} \left( c^2
\nabla \wedge \vec{B}^{n} -\vec{j}^{n} \right)$&lt;/li>
&lt;li>$\vec{B}^{n+\frac{1}{2}} = \vec{B}^n - \frac{\Delta t}{2} \left( \nabla
\wedge \vec{E}^{n+\frac{1}{2}} \right)$&lt;/li>
&lt;li>Call particle pusher which calculates $j^{n+1}$ currents&lt;/li>
&lt;li>$\vec{B}^{n+1} = \vec{B}^{n+\frac{1}{2}} - \frac{\Delta t}{2} \left(
\nabla \wedge \vec{E}^{n+\frac{1}{2}} \right)$&lt;/li>
&lt;li>$\vec{E}^{n+1} = \vec{E}^{n+\frac{1}{2}} + \frac{\Delta t}{2} \left( c^2
\nabla \wedge \vec{B} ^{n+1} - \vec{j}^{n+1} \right)$&lt;/li>
&lt;/ul>
&lt;p>Note that all spatial derivatives are calculated using the staggered grid, so
the final derivatives in the code appear one sided. However, this is not the
case, and all spatial derivatives are second order accurate. Higher order
spatial derivatives schemes for EPOCH are being developed to improve the
dispersion properties of the code when resolving small timescales.&lt;/p></description></item><item><title>Input Deck</title><link>/developer/extensions/input_deck.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/extensions/input_deck.html</guid><description>&lt;p>While using the &lt;code>custom_deck&lt;/code> subroutine is a good way of passing
parameters into the code or for temporary additions, it is not suitable for
permanent additions to the code. Adding new blocks to the code permanently is
very similar to doing it temporarily, but requires changes to some of the
subroutines in &lt;code>deck.F90&lt;/code>.&lt;/p>
&lt;p>There are six subroutines which may need to be changed to add new blocks to
the deck. These are&lt;/p>
&lt;ul>
&lt;li>&lt;code>deck_initialise&lt;/code> - Called before parsing of the input
deck is begun.&lt;/li>
&lt;li>&lt;code>deck_finalise&lt;/code> - Called after parsing of the input
deck is complete.&lt;/li>
&lt;li>&lt;code>start_block(block_name)&lt;/code> - Called when the deck directive
&lt;code>begin:block_name&lt;/code> appears in a deck file.&lt;/li>
&lt;li>&lt;code>end_block(block_name)&lt;/code> - Called when the deck directive
&lt;code>end:block_name&lt;/code> appears in a deck file.&lt;/li>
&lt;li>&lt;code>handle_block(block_name, block_element, block_value)&lt;/code> -
Called once for each element in a block.&lt;/li>
&lt;li>&lt;code>check_compulsory_blocks(errcode_deck)&lt;/code> - Called once when
the deck file has been read to check that all necessary blocks have been
populated.&lt;/li>
&lt;/ul>
&lt;p>There is one final variable which is important for modifying the input deck,
&lt;code>deck_state&lt;/code>. The input deck parser routine used to read the main
input deck uses the variable &lt;code>deck_state&lt;/code> to
determine which stage of parsing the deck is required. The possible values of
&lt;code>deck_state&lt;/code> are&lt;/p>
&lt;ul>
&lt;li>c_ds_first - The first pass through the deck, before memory has been
allocated.&lt;/li>
&lt;li>c_ds_last - After the initial deck pass, all arrays and lists are
allocated. The deck is then parsed a final time so that allocated memory
can be populated with initial conditions.&lt;/li>
&lt;/ul>
&lt;p>These constants are defined in &lt;code>shared_data.F90&lt;/code>.&lt;/p>
&lt;p>The layout of &lt;code>deck_initialise&lt;/code> and &lt;code>deck_finalise&lt;/code> is
extremely simple. They just call &lt;code>*_deck_initialise&lt;/code> or
&lt;code>*_deck_finalise&lt;/code> for each of the possible block types.
&lt;code>start_block&lt;/code> and &lt;code>end_block&lt;/code> are also fairly
straightforward. They examine the block name and call the
&lt;code>*_block_start&lt;/code> or &lt;code>*_block_end&lt;/code> routine
corresponding to the current block.&lt;/p>
&lt;p>The &lt;code>handle_block&lt;/code> routine acts in a similar manner except
that it also does some error handling.
At the simplest level the routine simply calls another function which
takes the block_element and block_value as
parameters and returns an error code
determining the success or failure of reading the element.&lt;/p>
&lt;p>The final routine is &lt;code>check_compulsory_blocks&lt;/code> which is used to
check that all the needed elements of the input deck have been set. A single
parameter &lt;code>errcode_deck&lt;/code> is passed in. The routine
checks &lt;code>deck_state&lt;/code> to make sure that it is the last pass
through the deck. It then goes through and calls functions to check that
all the necessary parts of a block have been set. The subroutines are contained
in the same file as the routine which is called in &lt;code>handle_block&lt;/code> to
handle elements of the block. The error handler functions should return an
error code, usually
&lt;code>c_err_missing_elements&lt;/code>. The
return code from the error handler function should then be &lt;code>IOR&lt;/code>-ed
with &lt;code>errcode_deck&lt;/code> to allow error codes to be returned from
several different checks with errors occurring.&lt;/p>
&lt;h2 id="the-element-handler-routines-for-deck-elements">The element handler routines for deck elements&lt;/h2>
&lt;p>The exact form of the handler routines is up to the end user. The only
&lt;em>requirements&lt;/em> are that the routine should return an error code detailing
whether or not there are any problems with reading the block and that the error
code should be &lt;code>c_err_none&lt;/code> if either the element name or element
value are the special constant &lt;code>blank&lt;/code>. The typical implementation
of an element handler routine is shown in the file
&lt;code>src/deck/deck_control_block.f90&lt;/code>, and this general layout should
be copied for compatibility if possible.&lt;/p>
&lt;p>Sometimes, it is useful to have each new block correspond to a new instance of
an object in the code. An example of this in EPOCH is in
&lt;code>src/deck/deck_laser_block.f90&lt;/code> where each new laser block in
the input deck corresponds to a new laser being attached to a boundary. This is
accomplished by implementing the lasers as a linked list on each boundary,
with a new laser object being created when a laser block is started, the laser
information being set during the main reader routine, and then the laser being
attached to the linked list by a call to &lt;code>attach_laser&lt;/code> in
&lt;code>src/laser.f90&lt;/code> when the block is ended. When a new laser block is
started the process simply repeats allowing the end user to have as many lasers
as desired.&lt;/p>
&lt;h2 id="adding-elements-to-existing-blocks">Adding elements to existing blocks&lt;/h2>
&lt;p>The existing blocks in the code are read in the files listed in \sect{src_deck}&lt;/p>
&lt;p>The existing structure of the blocks is simple enough in most cases that it
should be fairly easy to add new elements if needed. The most likely change
needed is to change the list of variables to dump in the &lt;code>output&lt;/code>
block. How to do this is detailed in \sect{io}.&lt;/p></description></item><item><title>Library requirements for the EPOCH codes</title><link>/documentation/basic_usage/libraries.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/basic_usage/libraries.html</guid><description>&lt;p>The EPOCH codes are written using MPI for parallelism, but have no other
libraries or dependencies. Currently, the codes are written to only
require MPI1.2 compatible libraries, although this may change to require
full MPI2 compliance in the future. Current versions of both MPICH and
OpenMPI implement the MPI2 standard and are known to work with this
code. The SCALI MPI implementation is only compliant with the MPI1.2
specification and may loose support soon. There are no plans to write a
version of EPOCH which does not require the MPI libraries.&lt;/p>
&lt;p>The code is supplied with a standard GNU make Makefile, which is also
compatible with most other forms of the &lt;em>&lt;code>*make*&lt;/code>&lt;/em> utility.
In theory it is possible to compile the code without a
&lt;em>&lt;code>*make*&lt;/code>&lt;/em> utility, but it is much easier to compile the code
using the supplied makefile.&lt;/p></description></item><item><title>License</title><link>/contact.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/contact.html</guid><description/></item><item><title>License</title><link>/license.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/license.html</guid><description/></item><item><title>Linked Lists</title><link>/developer/core_structure/linked_lists.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/linked_lists.html</guid><description>&lt;p>In EPOCH, different processors are responsible for different cells, and each
MPI rank only tracks the particles which exist with these cells. Hence, as
macro-particles move around the simulation, they must be removed from one
processor and added to another. If macro-particles were stored in arrays, these
would continuously have to be resized as macro-particles moved around. Instead,
EPOCH stores macro-particles in &lt;em>linked lists&lt;/em>.&lt;/p>
&lt;p>Linked lists are a standard computer programming technique which is still
slightly unusual in Fortran, and may well be unfamiliar to many Fortran
programmers. They effectively allow you to have an array of arbitrary length,
although this comes with various trade-offs about memory locality and speed of
accessing elements. The general concept is that of a chain where each link in
the chain only knows about the previous link in the chain and the next link in
the chain. Although there are schemes for doing this in languages which don&amp;rsquo;t
have pointers, the normal method of implementing linked lists is to use
pointers to point to previous and next elements in the list, and this is how
they are implemented in EPOCH. Since both linked lists and Fortran pointers
are slightly esoteric concepts, while being key to the operation of EPOCH a
brief overview of them is presented here.&lt;/p>
&lt;p>The simplest possible form of a linked list element would be a TYPE which
looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">TYPE linked_list
TYPE(linked_list), POINTER :: next
TYPE(linked_list), POINTER :: prev
END TYPE linked_list
&lt;/code>&lt;/pre>
&lt;p>You also have to have a pointer to the start of the list, and to speed up
adding new elements to the list, you normally also keep a pointer to the
last element of the list. Therefore, you would also have variables which look
like:&lt;/p>
&lt;pre>&lt;code class="language-perl">TYPE(linked_list) :: head, tail
&lt;/code>&lt;/pre>
&lt;p>Since Fortran pointers are not initialised in any particular state, you have
to remember to set the head and tail pointers to explicitly point nowhere
(normally called a null pointer by analogy with the older C style
pointers). This is done using the nullify command.&lt;/p>
&lt;pre>&lt;code class="language-perl">NULLIFY(head)
NULLIFY(tail)
&lt;/code>&lt;/pre>
&lt;p>The same thing is important when creating a new linked list element, so you
would normally have a creation function for linked list elements.&lt;/p>
&lt;pre>&lt;code class="language-perl">SUBROUTINE create_element(element)
TYPE(linked_list), POINTER :: element
ALLOCATE(element)
NULLIFY(element%next)
NULLIFY(element%prev)
END SUBROUTINE create_element
&lt;/code>&lt;/pre>
&lt;p>Note that the allocate function can be used on pointers in the same way that
it can be used with variables which have the allocatable attribute. However,
there is one important difference between a pointer and an allocatable
variable. If you attempt to allocate an already allocated variable which has
the allocatable attribute then the code will fail, whereas allocating an
already allocated pointer is perfectly valid, and will allocate the new
variable and point the pointer to it. This does not deallocate the memory that
the pointer previously pointed to, and Fortran does not have a &amp;ldquo;garbage
collector&amp;rdquo; which deallocates memory no longer accessible. So if you
allocate a pointer which already points to a variable, it is very important
that you have another pointer somewhere which points to the same memory. Once
you no longer have a pointer to an area of memory, that area of memory is
completely inaccessible and cannot even be deallocated. This is termed a
memory leak and for programs which run for many cycles and have a memory leak
on each cycle, the entire memory can very quickly be used up.&lt;/p>
&lt;p>So, to add a new element to the list you would have a subroutine which looks
like:&lt;/p>
&lt;pre>&lt;code class="language-perl">SUBROUTINE add_element(element)
TYPE(linked_list), POINTER :: element
IF (.NOT. ASSOCIATED(head)) THEN
! Adding first element to list, so just set
! both head and tail to the element
head=&amp;gt;element
tail=&amp;gt;element
RETURN
ENDIF
tail%next=&amp;gt;element
element%prev=&amp;gt;tail
tail=&amp;gt;element
END SUBROUTINE add_element
&lt;/code>&lt;/pre>
&lt;p>This subroutine adds the new Fortran operator of &lt;code>=&amp;gt;&lt;/code> which means &amp;ldquo;points
to&amp;rdquo;. Unlike C or similar languages, Fortran pointers try to be partially
transparent to the end user, so the following code would fail:&lt;/p>
&lt;pre>&lt;code class="language-perl">PROGRAM test
REAL, TARGET :: a = 10.0
REAL, POINTER :: b
b = a
END PROGRAM test
&lt;/code>&lt;/pre>
&lt;p>This happens because Fortran will try to copy the value of &amp;ldquo;a&amp;rdquo; into &amp;ldquo;b&amp;rdquo;.
However, &amp;ldquo;b&amp;rdquo; is a pointer which hasn&amp;rsquo;t been initialised, so the code will
crash when it tries to copy the data in (in theory, the code may not crash if
the uninitialised &amp;ldquo;b&amp;rdquo; pointer happens to point somewhere in memory which is
a valid target, but this is very unlikely). Note also that &amp;ldquo;a&amp;rdquo; has the
attribute &amp;ldquo;TARGET&amp;rdquo;. The target attribute means that it is possible to point
a pointer to this variable. You can only point a pointer to a variable which
is either a pointer itself or has the target attribute. This is to try and
keep Fortran pointers &amp;ldquo;safer&amp;rdquo; than C style pointers. The correct code would
use &lt;code>b=&amp;gt;a&lt;/code>, at which point &amp;ldquo;b&amp;rdquo; is set to point to &amp;ldquo;a&amp;rdquo; and
can then be used everywhere in place of &amp;ldquo;a&amp;rdquo;.&lt;/p>
&lt;p>So, to set up a linked list of n elements, you would use the following code:&lt;/p>
&lt;pre>&lt;code class="language-perl">TYPE(linked_list), POINTER :: new
NULLIFY(new)
DO i = 1,n
CALL create_element(new)
CALL add_element(new)
ENDDO
&lt;/code>&lt;/pre>
&lt;p>To then run through the elements of your newly created linked list, you would
use code like:&lt;/p>
&lt;pre>&lt;code class="language-perl">TYPE(linked_list), POINTER :: current
current=&amp;gt;head
DO WHILE(ASSOCIATED(current))
! Do stuff
current=&amp;gt;current%next
ENDDO
&lt;/code>&lt;/pre>
&lt;p>This code snippet introduces one new function &amp;ldquo;ASSOCIATED&amp;rdquo;, which tells you
whether a pointer is a null pointer or not (this is why it is so important to
nullify new pointers, because ASSOCIATED on its own doesn&amp;rsquo;t check whether a
pointer is valid, just whether or not it is a null pointer). You can also use
ASSOCIATED to check whether a pointer points to a particular object or not, in
which case the syntax is &lt;code>RESULT = ASSOCIATED(b, TARGET=a)&lt;/code>, which
returns true if &amp;ldquo;b&amp;rdquo; points to &amp;ldquo;a&amp;rdquo;, or false if it doesn&amp;rsquo;t, even if &amp;ldquo;b&amp;rdquo;
is a valid pointer pointing to something else. It also introduces the way in
which you must use linked lists in EPOCH. The execution flow is as follows&lt;/p>
&lt;ul>
&lt;li>Point current to the current element to the start of the linked list
(head).&lt;/li>
&lt;li>Iterate while current points to a valid element.&lt;/li>
&lt;li>Perform whatever actions you want on current.&lt;/li>
&lt;li>Point current to the next element in the chain.&lt;/li>
&lt;/ul>
&lt;p>This leads to the slightly counter intuitive behaviour where even though the
loop only acts on the variable named &amp;ldquo;current&amp;rdquo;, all of the elements in the
list are operated on. Although there are many tricks which can be performed
with linked lists, the only other aspect which needs to be explained is how
to delete elements. A subroutine to remove a single element from a linked list
would look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">SUBROUTINE remove_element(element)
TYPE(linked_list), POINTER :: element
IF (ASSOCIATED(element%prev)) THEN
! Previous element exists
element%prev%next=&amp;gt;element%next
ELSE
! Previous element does not exist therefore element is the head. When
! element is removed the head is the element after the one being removed
head=&amp;gt;element%next
ENDIF
IF (ASSOCIATED(element%next)) THEN
! next element exists
element%next%prev=&amp;gt;element%prev
ELSE
! next element does not exists therefore element is the tail. When element
! is removed the head is the element before the one being removed
tail=&amp;gt;element%prev
ENDIF
END SUBROUTINE remove_element
&lt;/code>&lt;/pre>
&lt;p>Once again, this code looks slightly counter-intuitive, but if you go through
step by step, it&amp;rsquo;s fairly simple. In the following discussion the element
being removed is called &amp;ldquo;C&amp;rdquo;, the element before &amp;ldquo;C&amp;rdquo; (if it exists) is
called &amp;ldquo;P&amp;rdquo; and the element after &amp;ldquo;C&amp;rdquo; (if it exists) is called &amp;ldquo;N&amp;rdquo;&lt;/p>
&lt;ul>
&lt;li>Check whether &lt;code>C&lt;/code>&amp;rsquo;s prev element exists, this means that
&lt;code>P&lt;/code> exists.&lt;/li>
&lt;li>If &lt;code>P&lt;/code> exists then the element to be removed isn&amp;rsquo;t at the
start of the chain. When &lt;code>C&lt;/code> is removed, we need
&lt;code>P&lt;/code>%next to point to &lt;code>C&lt;/code>%next. This leads to the odd
looking element%prev%next=&amp;gt; element%next syntax.&lt;/li>
&lt;li>If &lt;code>P&lt;/code> does not exist then &lt;code>C&lt;/code> is at the the start
of the chain. In order to not leave the chain orphaned when &lt;code>C&lt;/code>
is removed, we need head to point to &lt;code>C&lt;/code>%next.&lt;/li>
&lt;li>Exactly the same logic applies for updating the element after
&lt;code>C&lt;/code>.&lt;/li>
&lt;li>Check whether &lt;code>C&lt;/code>&amp;rsquo;s next element exists, this means that
&lt;code>N&lt;/code> exists.&lt;/li>
&lt;li>If &lt;code>N&lt;/code> exists then the element to be removed isn&amp;rsquo;t at the end
of the chain. When &lt;code>C&lt;/code> is removed, we need &lt;code>N&lt;/code>%prev
to point to &lt;code>C&lt;/code>%prev.&lt;/li>
&lt;li>If &lt;code>P&lt;/code> does not exist then &lt;code>C&lt;/code> is at the the start
of the chain. In order to not leave the chain orphaned when &lt;code>C&lt;/code>
is removed, we need head to point to &lt;code>C&lt;/code>%next.&lt;/li>
&lt;/ul>
&lt;p>Therefore, code to remove some elements from a linked list would look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">TYPE(linked_list), POINTER :: current, next
current=&amp;gt;head
DO WHILE(ASSOCIATED(current))
next=&amp;gt;current%next
IF (dealloc) THEN
CALL remove_element(current)
DEALLOCATE(current)
ENDIF
current=&amp;gt;next
ENDDO
&lt;/code>&lt;/pre>
&lt;p>Note that &amp;ldquo;current&amp;rdquo; must be deallocated explicitly even after it has been
removed from the linked list to prevent a memory leak. Note also that the
pointer to the &amp;ldquo;next&amp;rdquo; element is saved before &amp;ldquo;current&amp;rdquo; is deallocated.
This is not necessary but means that there is only one IF statement rather
than the two otherwise required.&lt;/p></description></item><item><title>Maths Parser</title><link>/developer/extensions/maths_parser.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/extensions/maths_parser.html</guid><description>&lt;p>When an extension is intended for a new release, the temporary custom extensions
are not appropriate. In these cases, it is possible to permanently add functions
and constants to
EPOCH&amp;rsquo;s maths parser. Although adding new operators is possible, it is
sufficiently likely to cause problems with the operation of the maths parser
that it is formally not recommended by the author of the program, and hence is
not documented here.&lt;/p>
&lt;h2 id="adding-the-new-tokenizer-handle">Adding the new tokenizer handle&lt;/h2>
&lt;p>When adding a new function or constant to the maths parser using the temporary
routines, there are two calls (&lt;code>register_function&lt;/code> and
&lt;code>register_constant&lt;/code>) which give a numerical handle. This is the
token used to represent that function or constant after the text has been parsed
(remember that EPOCH&amp;rsquo;s maths parser tokenizes before evaluation!). When
permanently adding objects to the maths parser, the tokenizer handles have to
be set up manually. This takes place in &lt;code>src/shared_data.F90&lt;/code> in
the module &lt;code>shared_parser_data&lt;/code>. There are several lines which
look like:&lt;/p>
&lt;pre>&lt;code class="language-perl"> INTEGER, PARAMETER :: c_const_ix = 40
INTEGER, PARAMETER :: c_const_iy = 41
.
.
.
INTEGER, PARAMETER :: c_func_interpolate = 22
INTEGER, PARAMETER :: c_func_tanh = 23
&lt;/code>&lt;/pre>
&lt;p>Constants beginning with &lt;code>c_const_&lt;/code> are tokenizer handles for
constants, and those beginning with &lt;code>c_func_&lt;/code> are tokenizer handles
for functions. Each number must be unique and has to be less than
the lower bound of values reserved for temporary or deck
specified values. This means that any tokenizer handle for a function has to be
less than the value of the variable &lt;code>c_func_custom_lowbound&lt;/code> and
any handle for a constant must be less than
&lt;code>c_const_deck_lowbound&lt;/code>. It is acceptable to simply increase the
value of &lt;code>c_func_custom_lowbound&lt;/code> and
&lt;code>c_const_deck_lowbound&lt;/code> to
allow the use of more values for internal constants and functions, although
care should be taken since this could lead to performance issues.
If &lt;code>c_const_deck_lowbound&lt;/code> is increased then the constant
&lt;code>c_constant_custom_lowbound&lt;/code> should be increased by the same
amount (the values between &lt;code>c_const_deck_lowbound&lt;/code> and
&lt;code>c_constant_custom_lowbound-1&lt;/code> are used for constants specified
inside the input deck while values greater than or equal to
&lt;code>c_constant_custom_lowbound&lt;/code> are used for constants specified
by &lt;code>register_constant&lt;/code>.&lt;/p>
&lt;p>Once the tokenizer handle is specified in &lt;code>shared_parser_data&lt;/code>, it
is now possible to extend the main areas of the maths parser. Note that from
here on, you MUST always use the constant named handle, NEVER the numerical
value that you specified for the value of the handle. If this is not done
then combining functions and constants from several sources becomes much harder.&lt;/p>
&lt;h2 id="adding-the-new-function-or-constant-to-the-tokenizer">Adding the new function or constant to the tokenizer&lt;/h2>
&lt;p>The next stage is to add the string representation of your constant or function
to the tokenizer routines in
&lt;code>src/parser/tokenizer_blocks.f90&lt;/code>. This is very simple to do, just
find either the function &lt;code>as_constant&lt;/code> or &lt;code>as_function&lt;/code>
and look at the existing code. These functions are just long lists of
&lt;code>str_cmp&lt;/code> commands followed by code to deal with custom
functions/constants. To add the new code, create an additional line such as:&lt;/p>
&lt;pre>&lt;code class="language-perl"> IF (str_cmp(name, &amp;quot;my_const&amp;quot;)) as_constant = c_const_my_const
.
.
.
IF (str_cmp(name, &amp;quot;my_func&amp;quot;)) as_function = c_func_my_func
&lt;/code>&lt;/pre>
&lt;p>Note that neither routine returns immediately after recognising the name of the
function/constant. This allows users to override built in constants or
functions with custom versions using &lt;code>register_constant}&lt;/code>
and &lt;code>register_function&lt;/code>. This is not significant, since tokenizing
should never be used in a speed critical part of the code.&lt;/p>
&lt;h2 id="implementing-the-function-or-constant-in-the-evaluator">Implementing the function or constant in the evaluator&lt;/h2>
&lt;p>The evaluator is the part of the code that actually takes the streams of tokens
produced by the tokenizer and evaluates them into a number. The relevant parts
of the evaluator for adding new constants or functions are in
&lt;code>src/parser/evaluator_blocks.f90&lt;/code> and the functions which may need
changing are &lt;code>do_constant&lt;/code> and &lt;code>do_functions&lt;/code>. These are
both passed up to five parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>INTEGER :: opcode&lt;/code> - The operation code, this is the tokenizer handle
which was defined in &lt;code>shared_parser_data&lt;/code>.&lt;/li>
&lt;li>&lt;code>INTEGER :: ix, iy, iz&lt;/code> - The position of the current evaluation in the
domain. If your function or constant behaves differently at different points
in space then you should use these parameters to reference the correct point
of an array.&lt;/li>
&lt;li>&lt;code>INTEGER :: errcode&lt;/code> - This should be set to an error code, usually
&lt;code>c_err_bad_value&lt;/code> if for some reason it is not possible to evaluate your
constant or function.&lt;/li>
&lt;/ul>
&lt;p>The rest of the routine to set a constant is as simple as testing for the
tokenizer handle already set up in &lt;code>shared_parser_data&lt;/code> and then
calling the subroutine &lt;code>push_on_eval&lt;/code>. This pushes the final
constant onto the evaluation stack which is used by the RPN parser. The basic
sequence for functions is similar except for the addition of a code to read
the values that the function takes. This is again the subroutine
&lt;code>get_values&lt;/code> which is also used in custom_function. The calling
sequence in &lt;code>do_function&lt;/code> looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl"> IF (opcode .EQ. c_func_gauss) THEN
CALL get_values(3, values)
CALL push_on_eval(EXP(-((values(1)-values(2))/values(3))**2))
RETURN
ENDIF
&lt;/code>&lt;/pre>
&lt;p>Simply call the &lt;code>get_values&lt;/code> subroutine, passing the number of
required parameters and an array of type &lt;code>REAL(num)&lt;/code> which is at
least as long as the number of required parameters. The array is populated
by the values passed into the function. Constants and maths expressions are
already evaluated by the time that this section of code is reached, so there is
no need to deal with further parsing. Next, simply call
&lt;code>push_on_eval&lt;/code> to push the result of your function onto the
evaluation stack.&lt;/p></description></item><item><title>New Module</title><link>/developer/extensions/new_modules.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/extensions/new_modules.html</guid><description>&lt;p>Adding a new module or physics package can turn out to be a very complicated
process, but plugging it into the existing PIC-loop is usually quite
straightforward. In this page, we will assume you have the source-code for a new
module, and we will explain how to add it to EPOCH&amp;rsquo;s calculations.&lt;/p>
&lt;h2 id="the-main-driver-routine">The main driver routine&lt;/h2>
&lt;p>When adding completely new routines to the code, they should be added to the
file &lt;code>src/epochnd.F90&lt;/code>. This routine simply calls other routines
to perform the actual execution of the code. The first section of the code
controls basic setup, MPI initialisation and
initial conditions. If you wish to add new startup conditions then
you should find the location in this routine where the
initial conditions are setup. The code is fairly complicated, but
there are a few key points at which the code significantly changes state.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>After the call to &lt;code>read_deck&lt;/code> the code has read the basic
information from the input deck files and any tests or changes which have to
be made to input deck values should be made immediately after this line. Note
that although the variables from the deck have been set,
none of these values have been used so allocatable
variables have yet to be allocated. The grid does not exist at this point.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>After the call to &lt;code>open_files&lt;/code> the code has finished
allocating all field variables, although particles may not yet have been set
up. The grid now exists.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>There are now a series of &lt;code>IF&lt;/code> statements which test for
things like &lt;code>IF (IOR(ictype, c_ic_autoload) .NE. 0)&lt;/code>.
These are the lines which test for all possible states of the
initial conditions. The last test is for the manual load routine
(&lt;code>c_ic_manual&lt;/code>). After this test all the particles have been
loaded and are now on their correct processor. The load balancer has now been
called at least once so the domains may no longer be identical.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The main loop is a simple do loop beginning with just the single command
&lt;code>DO&lt;/code>. Inside this loop there are several calls to routines which
actually advance the system. Most routines which can change currents should
take place after the particle pusher but before the final update for the $E$
and $B$ fields. These routines are&lt;/p>
&lt;ul>
&lt;li>&lt;code>set_dt&lt;/code> - This routine sets the timestep.&lt;/li>
&lt;li>&lt;code>update_eb_fields_half&lt;/code> - Time centre the $E$ and $B$
fields.&lt;/li>
&lt;li>&lt;code>push_particles&lt;/code> - The particle pusher.&lt;/li>
&lt;li>&lt;code>reorder_particles_to_grid&lt;/code> - Groups particles into
linked lists at each grid point. Used for the particle splitting routine,
and binary collisions. Any routine
which needs to have nearby particles grouped together should take place
after the call to this routine.&lt;/li>
&lt;li>&lt;code>split_particles&lt;/code> - The particle
splitting operator.&lt;/li>
&lt;li>&lt;code>reattach_particles_to_mainlist&lt;/code> - Undoes the
particle grouping and rebuilds the main list of particles used by the
particle pusher. Any routine which needs to have nearby particles grouped
together should take place before the call to this routine.&lt;/li>
&lt;li>&lt;code>update_eb_fields_final&lt;/code> - Updates the $E$ and $B$
fields to the full timestep.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>After the call to &lt;code>update_eb_fields_final&lt;/code> the code is
ready for another timestep. Any routines which do not change the time
integrated properties of the code (like the moving window) should come after
this call.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="the-particle-reordering-routine">The particle reordering routine&lt;/h2>
&lt;p>After &lt;code>reorder_particles_to_grid&lt;/code>, the particles have been moved to
particle-lists unique to each cell. The main list
&lt;code>species(ispecies)%attached_list&lt;/code> is empty and cannot be used
during this period. The particles should now be accessed using the variable
&lt;code>species(ispecies)%secondary_list(ix,iy,iz)&lt;/code> which is the array of
linked lists. This array is allocated on the call to
&lt;code>reorder_particles_to_grid&lt;/code> and deallocated on the call to
&lt;code>reattach_particles_to_mainlist&lt;/code>, and should not be used outside
the section of code between these two calls. The particles themselves remain
unchanged. No attempt is made to check that particles do not cross processor
boundaries in this section, so if a particle&amp;rsquo;s position is changed, it is up to
the user to ensure that the particle is transferred to another processor if
required. However, if a particle is transferred to another processor, it is
acceptable to relink it to &lt;code>species(ispecies)%attached_list&lt;/code> since
the other lists are simply appended to that list when the particles are
reattached to the main list.&lt;/p>
&lt;p>You should avoid using these routines if possible, as they have a significant
impact on performance. However, this remains the best method for cycling through
processes which require particles to interact with other particles within the
same cell, such as collisions or collisional ionisation. It is likely that new
physics modules for two-body interactions between incident and target particles
will also need to use this method (especially if the target particle changes).&lt;/p></description></item><item><title>New Particle Variable</title><link>/developer/extensions/new_particle_variable.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/extensions/new_particle_variable.html</guid><description>&lt;p>Sometimes you may wish to output a new variable associated with a
particle. Such extensions may be specific to a
particular task, and may be too niche to be added to the core EPOCH code.
Alternatively, users may wish to quickly add new particle variables, without
submitting a request to the developers and waiting for a new release. This
section will detail how to define a new particle variable, and how to dump it
to SDF files.&lt;/p>
&lt;p>There are multiple parts of the code which need to be modified to create and print
a new particle variable, these are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Makefile&lt;/code>: New pre-compiler option to deactivate new variable when not needed (for speed)&lt;/li>
&lt;li>&lt;code>shared_data.F90&lt;/code>: Give the particle datatype a new variable&lt;/li>
&lt;li>&lt;code>housekeeping/welcome.F90&lt;/code>: Alert the user when the code is compiled with your new option&lt;/li>
&lt;li>&lt;code>housekeeping/partlist.F90&lt;/code>: As particles move between MPI ranks, move your new variable with them&lt;/li>
&lt;li>&lt;code>constants.F90&lt;/code>: Create tags for the new output and compiler flag&lt;/li>
&lt;li>&lt;code>deck/deck_io_block.F90&lt;/code>: Lets the output block see the new output variable&lt;/li>
&lt;li>&lt;code>io/diagnostics.F90&lt;/code>: Writes the new variable to the SDF file&lt;/li>
&lt;li>&lt;code>io/iterators.F90&lt;/code>: Gives diagnostics.F90 variables to write to file&lt;/li>
&lt;li>&lt;strong>Extra&lt;/strong>: The user should set the value of the new variable to something&lt;/li>
&lt;/ul>
&lt;p>On this page, we provide an example of how to add and output a new particle
variable, which has actually been requested by an EPOCH user.
When electrons emit photons in the QED package, the photon macro-particle
contains no information about the electron which generated it. In this
example, let us output the Lorentz $\gamma$ factor of the radiating electron
for each emitted photon, at the time of photon emission. We will use EPOCH2D,
although this methodology would work for any dimension of the code. In these
examples, we will include some of the neighbouring lines of code, so you can
get a sense of where to insert the new code for your variable.&lt;/p>
&lt;h2 id="makefile">Makefile&lt;/h2>
&lt;p>We want a new pre-compiler flag for the new addition. As macro-particles move
around the simulation, they are passed between MPI ranks. The more particle
variables to transfer, the slower the code runs. Hence, if we don&amp;rsquo;t need to use
the new particle variables, the code should be compiled without them. This
is achieved with new pre-compiler variables.&lt;/p>
&lt;p>In the Makefile, there is a section with multiple commented-out pre-compiler
flags. Let us add a new one called &amp;ldquo;extended_io&amp;rdquo;. To do this, insert a line
such that the Makefile reads like:&lt;/p>
&lt;pre>&lt;code># Use second order particle weighting (default is third order).
#DEFINES += $(D)PARTICLE_SHAPE_TOPHAT
# Use fifth order particle weighting (default is third order).
#DEFINES += $(D)PARTICLE_SHAPE_BSPLINE3
# Include a unique global particle ID. The first flag defines the ID using
# an 8-byte integer, the second uses 4-bytes.
#DEFINES += $(D)PARTICLE_ID
#DEFINES += $(D)PARTICLE_ID4
# Include QED routines
DEFINES += $(D)PHOTONS
# Extended I/O for QED routines
DEFINES += $(D)EXTENDED_IO
# Use the Trident process for pair production
#DEFINES += $(D)TRIDENT_PHOTONS
# Include bremsstrahlung routines
#DEFINES += $(D)BREMSSTRAHLUNG
&lt;/code>&lt;/pre>
&lt;p>Note that we have un-commented the new extended_io flag, and the photons flag,
as we will have to run the code with both for the new output in this example.&lt;/p>
&lt;h2 id="constantsf90">Constants.F90&lt;/h2>
&lt;p>Let us make new global integer flags for both the pre-compiler flag, and the
new output.&lt;/p>
&lt;p>For the &lt;code>EXTENDED_IO&lt;/code> pre-compiler flag, find the &lt;code>c_def...&lt;/code> list and append a
new &lt;code>c_def_extended_io&lt;/code> variable to the end:&lt;/p>
&lt;pre>&lt;code> INTEGER(i8), PARAMETER :: c_def_use_mpi3 = 2**25
INTEGER(i8), PARAMETER :: c_def_bremsstrahlung = 2**26
INTEGER(i8), PARAMETER :: c_def_probe_time = 2**27
INTEGER(i8), PARAMETER :: c_def_extended_io = 2**28 ! New line
&lt;/code>&lt;/pre>
&lt;p>Next, let us make a new output flag: &lt;code>c_dump_qed_el_gamma&lt;/code>. Find the list of
&lt;code>c_dump...&lt;/code> parameters, and add our new one to the end. Remember to update the
&lt;code>num_vars_to_dump&lt;/code> variable with the new number of dump flags.&lt;/p>
&lt;pre>&lt;code> INTEGER, PARAMETER :: c_dump_probe_time = 72
INTEGER, PARAMETER :: c_dump_cou_log = 73
INTEGER, PARAMETER :: c_dump_qed_el_gamma = 74 ! New line
INTEGER, PARAMETER :: num_vars_to_dump = 74 ! Modified line
&lt;/code>&lt;/pre>
&lt;p>Note, you may wish to introduce multiple outputs with one pre-compiler flag.
For example, the &lt;code>WORK_DONE_INTEGRATED&lt;/code> pre-compiler flag introduces &lt;em>six&lt;/em> new
outputs.&lt;/p>
&lt;h2 id="shared_dataf90">Shared_data.F90&lt;/h2>
&lt;p>Here we declare a new variable for the particle data-type. Be sure to wrap this
inside your new pre-compiler flag using &lt;code>#ifdef&lt;/code> commands (note these cannot be
indented - the first character of these lines must be &lt;code>#&lt;/code>). In our example, we
have called the new variable &lt;code>electron_gamma&lt;/code>.&lt;/p>
&lt;pre>&lt;code> ! Object representing a particle
! If you add or remove from this section then you *must* update the
! particle pack and unpack routines
TYPE particle
REAL(num), DIMENSION(3) :: part_p
REAL(num), DIMENSION(c_ndims) :: part_pos
#ifdef EXTENDED_IO
REAL(num) :: electron_gamma ! New line, and the surrounding ifdef, endif
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="welcomef90">Welcome.F90&lt;/h2>
&lt;p>For consistency with the other EPOCH pre-compiler options, we should print a
message when the code has been compiled with our new &lt;code>EXTENDED_IO&lt;/code>.&lt;/p>
&lt;p>The first part of the module scans through all possible pre-compiler variables,
and checks if any are present. Add new lines for the new pre-compiler flag.&lt;/p>
&lt;pre>&lt;code>#ifdef PHOTONS
found = .TRUE.
#ifdef TRIDENT_PHOTONS
found = .TRUE.
#endif
#endif
#ifdef EXTENDED_IO
found = .TRUE. ! New line
#endif
&lt;/code>&lt;/pre>
&lt;p>Next, a message is printed for each present module. Here we have written a
generic message for our extended_io pre-compiler flag.&lt;/p>
&lt;pre>&lt;code>#ifdef PHOTONS
defines = IOR(defines, c_def_photons)
WRITE(*,*) 'QED Effects -DPHOTONS'
#ifdef TRIDENT_PHOTONS
defines = IOR(defines, c_def_trident_photons)
WRITE(*,*) 'Pair production by Trident process -DTRIDENT_PHOTONS'
#endif
#endif
#ifdef EXTENDED_IO
defines = IOR(defines, c_def_extended_io) ! New line
WRITE(*,*) 'Additional particle variables for output -DEXTENDED_IO' ! New line
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="partlistf90">Partlist.F90&lt;/h2>
&lt;p>Each MPI rank only tracks particles present within its section of the domain.
As macro-particles move around the simulation, they can pass between cells
controlled by different ranks. When this happens, a new particle is created on
the new rank, its properties are set to match the properties on the old rank,
and the particle on the old rank is destroyed. New particle variables must
also be transferred when particles move between ranks, and this is done here.&lt;/p>
&lt;p>There are 4 steps here:&lt;/p>
&lt;ul>
&lt;li>Tell the code how many variables are associated with the particle&lt;/li>
&lt;li>Copy the variables on the old rank to an array for transfer&lt;/li>
&lt;li>Set variables on the new rank from the transferred array&lt;/li>
&lt;li>For new particles, initialise the particle variable&lt;/li>
&lt;/ul>
&lt;p>To tell the code how many variables are present, find the &lt;code>set_partlist_size&lt;/code>
subroutine. The count of particle variables is stored in the &lt;code>nvar&lt;/code> integer.
In this example, we only introduce one more particle variable when the code
is compiled with &lt;code>EXTENDED_IO&lt;/code>, so add 1 to &lt;code>nvar&lt;/code> if we have compiled with
&lt;code>EXTENEDED_IO&lt;/code>:&lt;/p>
&lt;pre>&lt;code>#ifdef BREMSSTRAHLUNG
nvar = nvar+1
#endif
#ifdef EXTENDED_IO
nvar = nvar+1 ! New line
#endif
#ifdef PROBE_TIME
nvar = nvar+1
#endif
&lt;/code>&lt;/pre>
&lt;p>Next, navigate to &lt;code>pack_particle&lt;/code> - the subroutine responsible for collecting
particle variables to transfer to neighbouring ranks. Now we can add our new
variable to the transfer array. Make a note of the position here - variables
must be read in the same order they are stored.&lt;/p>
&lt;pre>&lt;code>#ifdef BREMSSTRAHLUNG
array(cpos) = a_particle%optical_depth_bremsstrahlung
cpos = cpos+1
#endif
#ifdef EXTENDED_IO
array(cpos) = a_particle%electron_gamma ! New line
cpos = cpos+1 ! Only 1 new variable, so add 1
#endif
#ifdef PROBE_TIME
array(cpos) = a_particle%probe_time
cpos = cpos+1
#endif
&lt;/code>&lt;/pre>
&lt;p>Once the particle variables are packed into an array, this is sent to the
neighbouring ranks. These call &lt;code>unpack_particle&lt;/code> to set the properties of new
particles. The syntax for this with our new variable would be:&lt;/p>
&lt;pre>&lt;code>#ifdef BREMSSTRAHLUNG
a_particle%optical_depth_bremsstrahlung = array(cpos)
cpos = cpos+1
#endif
#ifdef EXTENDED_IO
a_particle%electron_gamma = array(cpos) ! New line
cpos = cpos+1 ! Note this is also between optical_depth_bremsstrahlung and probe_time
#endif
#ifdef PROBE_TIME
a_particle%probe_time = array(cpos)
cpos = cpos+1
#endif
&lt;/code>&lt;/pre>
&lt;p>Finally, we must set the initial values for these variables. If we don&amp;rsquo;t do
this, the code can act unpredictably. In the &lt;code>init_particle&lt;/code> subroutine, add
the lines:&lt;/p>
&lt;pre>&lt;code>#ifdef EXTENDED_IO
new_particle%electron_gamma = 0.0_num ! New line
#endif
#ifdef PROBE_TIME
new_particle%probe_time = 0.0_num
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="deck_io_blockf90">Deck_io_block.F90&lt;/h2>
&lt;p>Unless you want to make a new physics package, a new particle variable is only
useful if you can output it. This is done using the standard EPOCH output block.
Recall we&amp;rsquo;ve already defined a &lt;code>c_dump_qed_el_gamma&lt;/code> flag - now we just need
to tell EPOCH how it will appear in the input deck.&lt;/p>
&lt;p>Navigate to &lt;code>io_block_handle_element&lt;/code>, find the &lt;code>str_cmp&lt;/code> lines which interpret
the the deck lines, and add:&lt;/p>
&lt;pre>&lt;code>#ifdef BREMSSTRAHLUNG
ELSE IF (str_cmp(element, 'bremsstrahlung_optical_depth')) THEN
elementselected = c_dump_part_opdepth_brem
#endif
#ifdef EXTENDED_IO
ELSE IF (str_cmp(element, 'electron_gamma')) THEN ! New line
elementselected = c_dump_qed_el_gamma ! New line
#endif
&lt;/code>&lt;/pre>
&lt;p>Whatever you write as the second argument to &lt;code>str_cmp&lt;/code> is how you will
have to write the variable in the EPOCH output block. As we are keeping things
simple in this example, we will not bother with restart dumps. The value of
&lt;code>electron_gamma&lt;/code> will not be re-loaded when you restart the code from a
restart dump.&lt;/p>
&lt;h2 id="diagnosticsf90">Diagnostics.F90&lt;/h2>
&lt;p>At this point we have declared a new particle variable, wrapped it in
pre-compiler flags, made it visible to MPI routines, and told EPOCH it can be
dumped. Now we actually have to write the variable to file.&lt;/p>
&lt;p>There is a section in the &lt;code>output_routines&lt;/code> subroutine which contains lines
with &lt;code>write_particle_variable&lt;/code> calls. Add a new one for our variable:&lt;/p>
&lt;pre>&lt;code>#ifdef BREMSSTRAHLUNG
CALL write_particle_variable(c_dump_part_opdepth_brem, code, &amp;amp;
'Bremsstrahlung Depth', '', it_output_real)
#endif
#ifdef EXTENDED_IO
CALL write_particle_variable(c_dump_qed_el_gamma, code, &amp;amp;
'Emitting Electron Gamma', '', it_output_real)
#endif
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>'Emitting Electron Gamma'&lt;/code> string controls how the variable will be
labelled in the SDF file.&lt;/p>
&lt;h2 id="iteratorsf90">Iterators.F90&lt;/h2>
&lt;p>One of the arguments of the &lt;code>write_particle_variable&lt;/code> subroutine is a call to
the &lt;code>it_output_real&lt;/code> function. We need to modify this function to give our new
variable, when requested. To do this, add the following case to the
&lt;code>it_output_real&lt;/code> function:&lt;/p>
&lt;pre>&lt;code>#ifdef EXTENDED_IO
CASE (c_dump_qed_el_gamma)
DO WHILE (ASSOCIATED(cur) .AND. (part_count &amp;lt; npoint_it))
part_count = part_count + 1
array(part_count) = cur%electron_gamma
cur =&amp;gt; cur%next
END DO
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="setting-your-variable">Setting your variable&lt;/h2>
&lt;p>All the previous steps are required whatever your particle
variable is. All we need to do now is figure out how to set it. This may be
straightforward or complicated, depending on what the variable is. We can&amp;rsquo;t
cover every possible particle variable here, but you may find it useful if we
finish our example, to see how one would go about it.&lt;/p>
&lt;p>Here, we want to save the electron gamma factor when a photon has been emitted.
Photon emission occurs in the &lt;code>generate_photon&lt;/code> subroutine of &lt;code>photons.F90&lt;/code>.
When in this subroutine, the generating electron information can be accessed
through the &lt;code>generating_electron&lt;/code> particle pointer. Fortunately for us, the
electron $\gamma$ factor has already been calculated in this subroutine, and is
given by &lt;code>generating_gamma&lt;/code>. Let us set our new particle variable to this
value, as soon as the photon macro-particle has been created.&lt;/p>
&lt;pre>&lt;code> CALL create_particle(new_photon)
new_photon%part_pos = generating_electron%part_pos
#ifdef EXTENDED_IO
new_photon%electron_gamma = generating_gamma ! New line
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="testing">Testing&lt;/h2>
&lt;p>If all has gone well, we have a new particle variable ready for printing.
Compile EPOCH (you may need to run &lt;code>make clean&lt;/code> first if you have changed the
pre-compiler flags).&lt;/p>
&lt;p>It&amp;rsquo;s best to run with a small input deck for code testing. We have shrank the
qed_rese.deck found in the source code, such that it can run in a few seconds.
This tiny deck has been included at the end of this section.&lt;/p>
&lt;p>When running, the code correctly generates the compiler-flag messages:&lt;/p>
&lt;pre>&lt;code> Welcome to EPOCH2D version 4.19.1 (commit v4.19.1-7-g6a1bfa99-dirty)
The code was compiled with the following compile time options
*************************************************************
QED Effects -DPHOTONS
Additional particle variables for output -DEXTENDED_IO
*************************************************************
&lt;/code>&lt;/pre>
&lt;p>When we inspect &lt;code>0001.sdf&lt;/code>, we find that 21798 macro-photons have been created,
and all of them have an emitting electron gamma value. These range from 20 to
1896 in this example. The input deck used for this example is given below. A
new particle variable has been successfully created!&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 50 # in x
ny = 50
nparticles = nx * ny * 2
t_end = 100e-15
x_min = 0
x_max = 50 * 10.0e-9
y_min = 0
y_max = 50 * 10.0e-9
dt_multiplier = 0.8
end:control
begin:qed
use_qed = T
qed_start_time = 0
produce_photons = T
photon_energy_min = 50 * kev
produce_pairs = F
photon_dynamics = F
end:qed
begin:boundaries
bc_x_min = simple_laser
bc_x_max = reflect
bc_y_max = reflect
bc_y_min = reflect
end:boundaries
begin:species
name = Electron
fraction = 0.5
dump = T
temperature = 0
number_density = if (x gt 0.1*x_max, 1.0e20, 0)
identify:electron
end:species
begin:species
name = Ion
fraction = 0.5
dump = T
number_density = number_density(Electron)
temperature = 0
identify:proton
end:species
begin:species
name = Photon
frac = 0
dump = T
identify:photon
end:species
begin:output
dt_snapshot = t_end
electron_gamma = always
end:output
begin:laser
boundary = x_min
intensity = 1.0e21 * 1.0e4
lambda = 1.0e-6
polarisation = 0.0
phase = 0.0
t_profile = 1
profile = 1
end:laser
&lt;/code>&lt;/pre></description></item><item><title>Parallelism</title><link>/developer/core_structure/parallelism.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/parallelism.html</guid><description>&lt;p>EPOCH is a massively parallel code written using standard MPI. Due to the
massively parallel nature
of EPOCH, there are MPI commands scattered throughout many parts of the code,
although the MPI has been hidden as far as possible from the end user. The main
use of MPI occurs during I/O, in the boundary conditions and during load
balancing. The MPI setup routines are all in
&lt;code>src/housekeeping/mpi_routines.F90&lt;/code>, and the routines which are
used to create the MPI types used by MPI-IO are in
&lt;code>src/housekeeping/mpi_subtype_control.f90&lt;/code>.&lt;/p>
&lt;h2 id="general-mpi-in-epoch">General MPI in EPOCH&lt;/h2>
&lt;p>EPOCH uses Cartesian domain decomposition for parallelism and creates an MPI
Cartesian topology using &lt;code>MPI_CART_CREATE&lt;/code>. The use of MPI in
EPOCH is deliberately kept as simple as possible, but there are some points
which must be made and some variables which must be explained.&lt;/p>
&lt;ul>
&lt;li>MPI decomposition is reversed compared to array ordering. Due to the
layout of arrays in Fortran, you get slightly faster performance if you split
arrays so that the first index remains as long as possible. Since EPOCH
uses &lt;code>MPI_DIMS_CREATE&lt;/code> to do array subdivision, this means that
the MPI coordinate system is ordered backwards compared to the main arrays.
This means that the &lt;code>coordinates&lt;/code> array which holds the
coordinates of the current processor in the Cartesian topology is ordered
as {coord_z, coord_y, coord_x}.&lt;/li>
&lt;li>To make this easier, there are some helper variables. The simplest of
these just gives the processors attached to each face of the domain on the
current processor. These variables are named &lt;code>x_min, x_max,&lt;/code>
&lt;code>y_min, y_max, z_min&lt;/code> and &lt;code>z_max&lt;/code>.&lt;/li>
&lt;li>Since it is possible for particles to cross boundaries diagonally there
is another variable &lt;code>neighbour&lt;/code> which identifies every possible
neighbouring processor including those meeting at single edges and at
corners. &lt;code>neighbour&lt;/code> is an array which runs (-1:1,-1:1,-1:1) and,
perhaps inconsistently, is ordered in normal order rather than reversed
order. This means that &lt;code>x_min == neighbour(-1,0,0)&lt;/code> and
&lt;code>z_max == neighbour(0,0,1)&lt;/code>.&lt;/li>
&lt;li>The variable &lt;code>comm&lt;/code> is the handle for the Cartesian
communicator returned from MPI_CART_CREATE.&lt;/li>
&lt;li>The variable &lt;code>errcode&lt;/code> is the standard error variable for all
MPI communications. However, EPOCH uses the standard
MPI_ERRORS_ARE_FATAL error handler so this variable is never tested.&lt;/li>
&lt;li>EPOCH uses a single variable, &lt;code>status&lt;/code>, to hold all MPI
status calls. Since there is no non-blocking communication this variable
is never checked.&lt;/li>
&lt;li>The rank of the current processor is stored in the variable
&lt;code>rank&lt;/code>.&lt;/li>
&lt;li>The number of processors is stored in &lt;code>nproc&lt;/code>.&lt;/li>
&lt;li>The number of processors assigned to any given direction of the Cartesian
topology is given by &lt;code>nproc{x,y,z}&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>There are some other variables which are not technically part of the MPI
implementation, but which only exist because the code is running in
parallel. These are&lt;/p>
&lt;ul>
&lt;li>&lt;code>REAL(num) :: {x,y,z}_min_local&lt;/code> - The location of the start of the
domain on the local processor in real units.&lt;/li>
&lt;li>&lt;code>REAL(num) :: {x,y,z}_max_local&lt;/code> - The location of the end of the
domain on the local processor in real units.&lt;/li>
&lt;li>&lt;code>INTEGER, DIMENSION(1:nproc{x,y,z}) :: cell_{x,y,z}_min&lt;/code> - The cell
number for the start of the local part of the global array in each direction.&lt;/li>
&lt;li>&lt;code>INTEGER, DIMENSION(1:nproc{x,y,z}) :: cell_{x,y,z}_max&lt;/code>&lt;/li>
&lt;li>The cell number for the end of the local part of the global array in each
direction.&lt;/li>
&lt;/ul>
&lt;h2 id="mpi_routinesf90">&lt;code>mpi_routines.F90&lt;/code>&lt;/h2>
&lt;p>&lt;code>mpi_routines.F90&lt;/code> is the file which contains all the MPI setup
code. It contains the following routines:&lt;/p>
&lt;ul>
&lt;li>mpi_minimal_init - Contains code to start MPI enough to
allow the input deck reader to work. The default EPOCH code setup means
that it needs to initialise MPI, obtain the rank and the number of processors.&lt;/li>
&lt;li>setup_communicator - Routine which creates the Cartesian communicator
used by the code after the input deck has been parsed. It also populates
&lt;code>x_min, x_max&lt;/code> etc. It is in its own subroutine so that it can be
recalled after the start of the window move when the code is using a moving
window. This is needed since it is valid to have a non-periodic boundary
before the window starts to move and a periodic boundary afterwards.&lt;/li>
&lt;li>mpi_initialise - This routine calls &lt;code>setup_communicator&lt;/code> and
then allocates all the arrays to do with fields, etc. It also sets up the
particle list objects for each species. If the code is running with only
manual initial conditions then this routine loads the requested number of
particles on each processor. Otherwise either the restart or the autoloader
code load the particles.&lt;/li>
&lt;li>mpi_close - This routine performs all the needed cleanup before the
final call to &lt;code>MPI_FINALIZE&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h2 id="mpi_subtype_controlf90">&lt;code>mpi_subtype_control.f90&lt;/code>&lt;/h2>
&lt;p>This file contains all the routines which are used to create the MPI types
which are used in the SDF I/O system. Most of the routines in this section are
used to create the types used for writing the default variables and,
when modifying the code, it is possible to output anything which has the same
shape and size on disk as the default variables without ever having to use the
routines in this file. However, if you are creating more general modifications
which can include variables of different sizes with different layouts across
processors then you may wish to use these routines to create new MPI types which
match your data layout. Any valid MPI type describing the data layout will work
with the SDF library, so there is no absolute need to use these routines. Only
the general purpose subroutines are described here, since most of the other
routines are fairly clear and use these routines internally.&lt;/p>
&lt;h2 id="create_particle_subtype">create_particle_subtype&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION create_particle_subtype(npart_local)
INTEGER(KIND=8), INTENT(IN) :: npart_local
&lt;/code>&lt;/pre>
&lt;p>&lt;code>create_particle_subtype&lt;/code> is a routine which creates an MPI type
representing particles which are spread across different processors with
&lt;code>npart_local&lt;/code> particles on each
processor. &lt;code>npart_local&lt;/code> does not have to be the same number on all
processors.&lt;/p>
&lt;p>Currently this is only used for reading particle data from restart snapshots.
It is likely to go away in the near future.&lt;/p>
&lt;h2 id="create_ordered_particle_offsets">create_ordered_particle_offsets&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE create_ordered_particle_offsets(n_dump_species,&amp;amp;
npart_local)
INTEGER, INTENT(IN) :: n_dump_species
INTEGER(KIND=8), DIMENSION(n_dump_species), &amp;amp;
INTENT(IN) :: npart_local
&lt;/code>&lt;/pre>
&lt;p>&lt;code>create_ordered_particle_offsets&lt;/code> is a routine which creates an
array of offsets representing particles from &lt;code>n_dump_species&lt;/code>
which are spread across different processors with
&lt;code>npart_local(ispecies)&lt;/code> particles of each species on each
processor. &lt;code>npart_local&lt;/code> does not
have to be the same number on all processors and does not have to be the same
number for each species.&lt;/p>
&lt;h2 id="create_field_subtype">create_field_subtype&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION create_field_subtype(n{x,y,z}_local, &amp;amp;
cell_start_{x,y,z}_local)
INTEGER, INTENT(IN) :: nx_local, ny_local, nz_local
INTEGER, INTENT(IN) :: cell_start_x_local
INTEGER, INTENT(IN) :: cell_start_y_local
INTEGER, INTENT(IN) :: cell_start_z_local
&lt;/code>&lt;/pre>
&lt;p>&lt;code>create_field_subtype&lt;/code> is a routine which creates an MPI type
representing a field that is defined across some or all of the processors. The
&lt;code>n{x,y,z}_local&lt;/code> parameters are the number of points in the x,
y, z directions (if they exist in the version of the code that you are working
on) that are on the local processor. The
&lt;code>cell_start_{x,y,z}_local&lt;/code> parameters are the offset of the
top, left, back corner of the local subarray in the global array that would
exist if the code was running on one processor. This is an &lt;em>offset&lt;/em>, not a
position and so it begins at {0,0,0} NOT {1,1,1}.&lt;/p>
&lt;p>In EPOCH3D there is also a routine called
&lt;code>create_field_subtype_2d&lt;/code> which is exactly equivalent to
&lt;code>create_field_subtype&lt;/code> in EPOCH2D and is used for writing the 2D
distribution functions. At present, there are not equivalent 1D functions
except in EPOCH1D, but these could easily by added if required.&lt;/p>
&lt;h2 id="the-load-balancer">The load balancer&lt;/h2>
&lt;p>One of the major limiting factors in the scalability of PIC codes is load
balancing. Due to the synchronisation of the currents required for the update
of the EM fields the entire code runs at the speed of the slowest
process. Since most of the time in the main EPOCH cycle is taken by the
particle pusher, this equates to the process with the highest number of
particles being the slowest. Since the location of particles is dependent upon
the solution of the problem under consideration, in general the code will not
have exactly the same number of particles on each processor. The load balancer
is used to move the inter-processor boundaries so that the number of particles
is as close to the same on each processor as possible. The load balancer is
invoked at the start of the code and when the ratio of the least loaded
processor to the most loaded processor falls below a user specified critical
point.&lt;/p>
&lt;p>EPOCH&amp;rsquo;s load balancer works by rearranging the processor boundaries in 1D
sweeps in each direction, rather than attempting to perform multidimensional
optimisation. Also, at present the MPI in EPOCH requires each processor to be
simply connected at every point, so it must have one processor to the left, one
to the front etc. which introduces a further restriction on the load
balancer. Otherwise, the load balancer is fully general. The load balancing
sweep is illustrated here:&lt;/p>
&lt;p>&lt;img src="/developer/sweep.png" alt="Illustration of the load balancing sweep">&lt;/p>
&lt;p>The load balancer is
implemented in the file &lt;code>src/housekeeping/balance.F90&lt;/code> and is called
by the routine &lt;code>balance_workload(override)&lt;/code>. The parameter
&lt;code>override&lt;/code> is used to force the code to perform a load balancing
sweep even when it would normally determine that the imbalance is not large
enough to force a load balancing sweep. Although the load balancer is hard
coded to load balance in all available directions, the code is written in such
a way that it is possible to modify the code to load balance in only one
direction, or to automatically determine which single direction gives the best
performance.&lt;/p>
&lt;p>The details of the load balancer are fairly intricate, and if major
modification to the load balancer is required, it is recommended that the
original authors be contacted for detailed advice on how to proceed. However,
the general layout of the routine is as follows.&lt;/p>
&lt;ul>
&lt;li>Use MPI_ALLREDUCE to determine the global minimum and maximum number of
particles. If the ratio of the minimum to the maximum is above the load
balance threshold then just return from the subroutine.&lt;/li>
&lt;li>The code uses the routines &lt;code>get_load_in_{x,y,z}&lt;/code> to
determine the work load along each direction of the domain.
The &lt;code>get_load_in_x&lt;/code> routine uses the x-coordinate of every
particle to create a 1D particle density in the x-direction. This is then
combined with the total number of grid cells in the y-z plane to give
a 1D array of the work load in the x-direction. Similarly for
&lt;code>get_load_in_{y,z}&lt;/code>.&lt;/li>
&lt;li>Next the load array is passed to the &lt;code>calculate_breaks&lt;/code>
routine which fills the arrays &lt;code>starts_{x,y,z}&lt;/code>
and &lt;code>ends_{x,y,z}&lt;/code>. These arrays contain the starting and
ending cell numbers of the hypothetical global array in each direction for
each processor.&lt;/li>
&lt;li>The routine &lt;code>redistribute_fields&lt;/code> is then called to move the
information about field variables which cannot be recalculated. If new field
variables are created that cannot be recalculated after the load balancing is
completed then &lt;code>redistribute_fields&lt;/code> has to be modified for these
new variables.&lt;/li>
&lt;li>The next section of the routine deals with those variables which can be
recalculated after the load balance sweep is complete, such as the coordinate
axes and the arrays which hold the particle kinetic energy.&lt;/li>
&lt;li>The penultimate section of the routine then changes the variables which
tell the code where the edges of its domain lie in real space to reflect the
changed shape of the domains.&lt;/li>
&lt;li>The final part is the call to &lt;code>distribute_particles&lt;/code> which
moves the particles to the new processor. Once this is
finished, the code should have as near as possible the same number of
particles on each processor.&lt;/li>
&lt;/ul>
&lt;p>Most of the load balancer is purely mechanical and should only be changed if
the way in which the code is to perform load balancing is fundamentally
altered. The redistribution of particles that takes place in
&lt;code>distribute_particles&lt;/code> uses the standard particle_list objects, so
that if the necessary changes have been made to the routines in
&lt;code>src/housekeeping/partlist.F90&lt;/code> to allow correct
boundary swaps of particles then the load balancer should work with no further
modification. The only part of the load balancer which should need changing is
&lt;code>redistribute_fields&lt;/code> which requires explicit modification if new
field variables are required. For fields which are the same shape as the main
array there is significant assistance provided within the code to make the
re-balancing simpler. There are also routines which can help with re-balancing
variables which are the size of only one edge or face of the domain. Variables
which are of a completely different size but still need to be rebalanced when
coordinate axes move have to have full load balancing routines implemented by
the developer. This is beyond the scope of this manual and any developer who
needs assistance with development such a modification should contact the
original author of the code. The field balancer is fairly simple and mostly
calls one of three routines: &lt;code>redistribute_field&lt;/code> and either
&lt;code>redistribute_field_2d&lt;/code> or &lt;code>redistribute_field_1d&lt;/code>
depending on the dimensionality of your code. To redistribute full field
variables the routine to use is &lt;code>redistribute_field&lt;/code>, and an
example of using the code looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl"> temp = 0.0_num
CALL redistribute_field(new_domain, bz, temp)
DEALLOCATE(bz)
ALLOCATE(bz(-2:nx_new+3,-2:ny_new+3))
bz = temp
&lt;/code>&lt;/pre>
&lt;p>In this calling sequence the
&lt;code>redistribute_field&lt;/code> subroutine is used to redistribute the field
&lt;code>bz&lt;/code>, and the newly redistributed field is copied
into &lt;code>temp&lt;/code>; an array which is already allocated to the
correct size. The &lt;code>new_domain&lt;/code> parameter is an array indicating the
location of the start and end points of the new domain for the current processor
in gridpoints offset from the start of the global array. It is passed into the
&lt;code>redistribute_fields&lt;/code> subroutine as a parameter from the
&lt;code>balance_workload&lt;/code> subroutine and should not be changed. The
&lt;code>temp&lt;/code> variable is needed since Fortran standards before Fortran2000
do not allow the deallocation and reallocation of parameters passed to a
subroutine. There is a more elegant solution, where &lt;code>temp&lt;/code> is
hidden inside the &lt;code>redistribute_field&lt;/code> subroutine. However, support
for this in current Fortran2000 implementations is unreliable.&lt;/p>
&lt;p>The routine for re-balancing variables which lie along an edge of the domain are
very similar and are demonstrated in the &lt;code>redistribute_fields&lt;/code>
subroutine for lasers attached to different boundaries. It is
recommended that a developer examine this code when developing new routines.&lt;/p></description></item><item><title>Particle Pusher</title><link>/developer/core_structure/particle_pusher.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/particle_pusher.html</guid><description>&lt;p>EPOCH&amp;rsquo;s particle pusher is based on the one from the PSC by Hartmut Ruhl, and
is a Birdsall and Landon type PIC scheme using Villasenor and Buneman current
weighting. It is contained in the file &lt;code>particles.F90&lt;/code>. The
operation of the particle pusher is fairly simple, but there are a few elements
which need some clarification.&lt;/p>
&lt;ul>
&lt;li>The update to the particle momenta etc. does not explicitly include the
particle weight function. This means that the pseudoparticle momenta etc. are
the momentum for a single real particle of the collection of real particles
represented by that pseudoparticle, NOT the momentum of the whole collection
of real particles.&lt;/li>
&lt;li>&lt;code>gamma&lt;/code> - The variable gamma which appears in various places
is the relativistic $\gamma$ which is needed to convert the particle momentum
into the particle velocity using the relation $\vec{p} = \gamma m \vec{v}$.
Here, $\vec{p}$ is the particle momentum, $\vec{v}$ is the particle
velocity and $m$ is the particle rest mass.
If EPOCH was not relativistic then this would simply be $1$. Since
EPOCH is relativistic, gamma is defined as
$\left(\vec{p}.\vec{p}/m c^2 + 1\right)^{1/2}$.&lt;/li>
&lt;li>&lt;code>cell_x1=cell_x1+1&lt;/code> - There are lines like this after all
the sections of the routine where the cell a particle is in is
calculated. This is because, for a cell centred variable, the domain runs
(1:nx,1:ny,1:nz) rather than (0:nx-1,0:ny-1,0:nz-1).&lt;/li>
&lt;/ul>
&lt;p>The most complicated parts of the particle pusher are interpolating the grid
electric and magnetic fields over the
&lt;a href="/developer/core_structure/shape_functions.html">macro-particle shape&lt;/a>, and the
&lt;a href="/developer/core_structure/current_solver.html">current density solver&lt;/a>.&lt;/p></description></item><item><title>Particles</title><link>/developer/core_structure/macro_particles.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/macro_particles.html</guid><description>&lt;p>In the PIC method, the simulation grid is filled with macro-particles, which
respresent a large number of &lt;em>real&lt;/em> particles. They are described primarily by a
position on the grid, and a momentum, charge, mass and weight. In EPOCH, the
first few variables describe a &lt;em>single&lt;/em> real particle within the macro-particle,
and the weight describes how many real particles the macro-particle represents.&lt;/p>
&lt;p>Macro-particles are split between different species, set by the species blocks
in the input deck. All macro-particles present on a single rank are contained
within the &lt;code>species_list&lt;/code> variable, which contains lists of particles for all
species present, along with information about each species.&lt;/p>
&lt;p>In short, the data is distributed among types as follows:&lt;/p>
&lt;ul>
&lt;li>Particle type: contains information about a single macro-particle.&lt;/li>
&lt;li>Particle list: a linked list object, containing a list of macro-particles.&lt;/li>
&lt;li>Particle species: contains information about a set of particles as a whole,
and a corresponding particle list.&lt;/li>
&lt;li>Species list: an array containing all the particle species.&lt;/li>
&lt;/ul>
&lt;h2 id="the-particle-data-type">The particle data-type&lt;/h2>
&lt;p>Particles are represented as linked lists of Fortran TYPES. The definition can
be found in &lt;code>shared_data.F90&lt;/code>, which is shared globally among all modules.
Hence, any module can use a particle data-type.&lt;/p>
&lt;p>In this data-type, you will
notice that many parameters are locked behind pre-processor flags, and must
be manually switched on through the Makefile. This is because as particles move
around the grid, they must be transferred from processor to processor as they
move in and out of cells controlled by each rank. This MPI transfer is a major
bottleneck for the code, so by default, EPOCH assigns the minimum amount of
information to each particle, to minimise the rank-to-rank data transfer.&lt;/p>
&lt;p>The datatype is shown here:&lt;/p>
&lt;pre>&lt;code class="language-perl">TYPE particle
REAL(num), DIMENSION(3) :: part_p
REAL(num), DIMENSION(c_ndims) :: part_pos
#if !defined(PER_SPECIES_WEIGHT) || defined(PHOTONS)
REAL(num) :: weight
#endif
#ifdef DELTAF_METHOD
REAL(num) :: pvol
#endif
#ifdef PER_PARTICLE_CHARGE_MASS
REAL(num) :: charge
REAL(num) :: mass
#endif
TYPE(particle), POINTER :: next, prev
#ifdef PARTICLE_DEBUG
INTEGER :: processor
INTEGER :: processor_at_t0
#endif
#ifdef PARTICLE_ID4
INTEGER :: id
#elif PARTICLE_ID
INTEGER(i8) :: id
#endif
#ifdef WORK_DONE_INTEGRATED
REAL(num) :: work_x
REAL(num) :: work_y
REAL(num) :: work_z
REAL(num) :: work_x_total
REAL(num) :: work_y_total
REAL(num) :: work_z_total
#endif
#ifdef PHOTONS
REAL(num) :: optical_depth
#endif
#if defined(PHOTONS) || defined(BREMSSTRAHLUNG)
REAL(num) :: particle_energy
#endif
#if defined(PHOTONS) &amp;amp;&amp;amp; defined(TRIDENT_PHOTONS)
REAL(num) :: optical_depth_tri
#endif
#ifdef BREMSSTRAHLUNG
REAL(num) :: optical_depth_bremsstrahlung
#endif
#if defined(PROBE_TIME)
REAL(num) :: probe_time
#endif
END TYPE particle
&lt;/code>&lt;/pre>
&lt;p>And the descriptions are&lt;/p>
&lt;ul>
&lt;li>&lt;code>REAL(num) :: part_p(3)&lt;/code> - The particle momentum. Always dimension 3 even
in 1D and 2D codes. Describes the momentum of a single particle within the
macro-particle.&lt;/li>
&lt;li>&lt;code>REAL(num) :: part_pos(ndims)&lt;/code> - The particle position. Has
the same dimensions as that of the code.&lt;/li>
&lt;li>&lt;code>REAL(num) :: weight&lt;/code> - The particle weight if the code is running with
per particle weighting (otherwise weight is a species parameter).&lt;/li>
&lt;li>&lt;code>REAL(num) :: charge&lt;/code> - The particle charge in Coulombs if the code is
running with per particle charge (otherwise charge is a species parameter).&lt;/li>
&lt;li>&lt;code>REAL(nun) :: mass&lt;/code> - The particle mass in kilograms if the code is
running with per particle mass (otherwise mass is a species parameter).&lt;/li>
&lt;li>&lt;code>TYPE(particle), POINTER :: next, prev&lt;/code> - The pointers to the next and
previous elements of the linked list.&lt;/li>
&lt;li>&lt;code>INTEGER :: processor&lt;/code> - The rank of the processor that the particle
thinks it is on. Used for debugging.&lt;/li>
&lt;li>&lt;code>INTEGER :: processor_at_t0&lt;/code> - The rank of the processor that the
particle started on. Used for debugging.&lt;/li>
&lt;li>&lt;code>INTEGER :: id&lt;/code> - A unique integer assigned to each particle, only set for
species which output the id, and only when the code is compiled with ID
support.&lt;/li>
&lt;li>&lt;code>REAL(num) :: work_{x,y,z}&lt;/code> - Work done by the electric field on the
particle during the last particle push, in each direction.
Describes work done to a single particle within the macro-particle.&lt;/li>
&lt;li>&lt;code>REAL(num) :: work_{x,y,z}_total&lt;/code> - Work done by the electric fields on the
particle over the full simulation, in each direction.
Describes work done to a single particle within the macro-particle.&lt;/li>
&lt;li>&lt;code>REAL(num) :: optical_depth&lt;/code> - For some secondary-particle emission processes,
a particle is assigned an &amp;ldquo;optical depth of emission&amp;rdquo;, related to how far the
particle has moved, and the cross section of emission. The total optical depth
is tracked, and an emission is sampled once the optical_depth goes negative.
The original &lt;code>optical_depth&lt;/code> here describes the remaining optical depth to
travel
before photon emission through the QED non-linear Compton scatter process for
electrons. For photons, this describes the remaining optical depth before
Breit-Wheeler pair production.&lt;/li>
&lt;li>&lt;code>REAL(num) :: particle_energy&lt;/code> - Contains the relativistic particle energy,
primarily for use in the QED routines.&lt;/li>
&lt;li>&lt;code>REAL(num) :: optical_depth_tri&lt;/code> - Remaining optical depth before emission of
a pair through the electron trident process.&lt;/li>
&lt;li>&lt;code>REAL(num) :: optical_depth_bremsstrahlung&lt;/code> - Remaining optical depth before
emission of a bremsstrahlung photon for electrons, or a Bethe-Heitler pair
for photons.&lt;/li>
&lt;li>&lt;code>REAL(num) :: probe_time&lt;/code> - If a particle passes a probe, a copy of the
particle is stored in a new list. This parameter is set to the time the
particle passes the probe, for the particle copy.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>WARNING&lt;/strong>: Simply adding a new parameter to the definition of the particle
type is NOT
sufficient to extend the particle type, since the communications when the
particle crosses a processor boundary do not know about the new parameter and
it will not be transmitted with the particle. How to add new properties to the
particle communication layer is described later.&lt;/p>
&lt;h2 id="particle-list-type">Particle list type&lt;/h2>
&lt;p>The entire linked list of particles is encapsulated in another Fortran TYPE,
called &lt;code>particle_list&lt;/code>, which is defined as:&lt;/p>
&lt;pre>&lt;code class="language-perl">TYPE particle_list
TYPE(particle), POINTER :: head
TYPE(particle), POINTER :: tail
INTEGER(KIND=8) :: count
! Pointer is safe if the particles in it are all unambiguously linked
LOGICAL :: safe
TYPE(particle_list), POINTER :: next, prev
END TYPE particle_list
&lt;/code>&lt;/pre>
&lt;p>And its properties are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>TYPE(particle), POINTER :: head&lt;/code> - The first particle in the linked list.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(particle), POINTER :: tail&lt;/code> - The last particle in the linked
list. New particles added to the end of the list are added onto the end of
the tail element, and the new last particle becomes the new tail element.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER(KIND=8) :: count&lt;/code> - The number of particles in this particle
list. Note that the &lt;code>particle_list&lt;/code> type is not
directly MPI aware, so this is literally the number of particles in
&lt;em>this&lt;/em> particle list, not the number of particles of this species on all
processors.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: safe&lt;/code> - A particle list &lt;em>safe&lt;/em> if the particles in it
are unambiguously linked. That is that the &lt;code>count&lt;/code>th particle is
guaranteed to have its &lt;code>next&lt;/code> property be null. Most particle
lists within EPOCH are safe, but sometimes it is useful to be able to have
particle lists which are subsets of longer particles lists, and these
particle lists are not &lt;em>safe&lt;/em>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(particle_list), POINTER :: next, prev&lt;/code> - At present, EPOCH does
not use these pointers, which are intended to allow multiple particle lists to
be attached together. Certain parts of EPOCH, such as the I/O system are
aware of these pointers and will automatically use them if they are ever
set. They are reserved for future use.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The &lt;code>particle_list&lt;/code> objects are used to abstract all the functions
of the linked list, including adding and removing particles and transporting
particles between processors.&lt;/p>
&lt;h2 id="particle-species-type">Particle species type&lt;/h2>
&lt;p>The particle species are represented by yet another Fortran TYPE, this time
called &lt;code>particle_species&lt;/code>, which in 2D is defined as:&lt;/p>
&lt;pre>&lt;code class="language-perl">TYPE particle_species
! Core properties
CHARACTER(string_length) :: name
TYPE(particle_species), POINTER :: next, prev
INTEGER :: id
INTEGER :: dumpmask
INTEGER :: count_update_step
REAL(num) :: charge
REAL(num) :: mass
REAL(num) :: weight
INTEGER(i8) :: count
TYPE(particle_list) :: attached_list
TYPE(particle_pointer_list), POINTER :: boundary_particles =&amp;gt; NULL()
LOGICAL :: immobile
LOGICAL :: fill_ghosts
! Parameters for relativistic and arbitrary particle loader
INTEGER :: ic_df_type
REAL(num) :: fractional_tail_cutoff
TYPE(primitive_stack) :: dist_fn
TYPE(primitive_stack) :: dist_fn_range(3)
#ifndef NO_TRACER_PARTICLES
LOGICAL :: zero_current
#endif
INTEGER :: atomic_no
LOGICAL :: atomic_no_set = .FALSE.
! Specify if species is background species or not
LOGICAL :: background_species = .FALSE.
! Background density
REAL(num), DIMENSION(:,:), POINTER :: background_density
! Do we need to make secondary lists for this species?
LOGICAL :: make_secondary_list = .FALSE.
! Has species list been randomised in order?
LOGICAL :: is_shuffled
! Specifiy if species is background for collisions
LOGICAL :: coll_background = .FALSE.
LOGICAL :: coll_fast = .FALSE.
LOGICAL :: coll_pairwise = .FALSE.
! ID code which identifies if a species is of a special type
INTEGER :: species_type
! particle cell division
INTEGER(i8) :: global_count
LOGICAL :: split
INTEGER(i8) :: npart_max
! Secondary list
TYPE(particle_list), DIMENSION(:,:), POINTER :: secondary_list
! Loading of particles
REAL(num) :: npart_per_cell
TYPE(primitive_stack) :: density_function, temperature_function(3)
TYPE(primitive_stack) :: drift_function(3)
! Thermal boundaries
REAL(num), DIMENSION(:,:), POINTER :: ext_temp_x_min, ext_temp_x_max
REAL(num), DIMENSION(:,:), POINTER :: ext_temp_y_min, ext_temp_y_max
! Species_ionisation
LOGICAL :: electron
LOGICAL :: ionise
INTEGER :: ionise_to_species
INTEGER :: release_species
INTEGER :: n
INTEGER :: l
REAL(num) :: ionisation_energy
REAL(num), ALLOCATABLE :: coll_ion_incident_ke(:)
REAL(num), ALLOCATABLE :: coll_ion_cross_sec(:)
REAL(num), ALLOCATABLE :: coll_ion_mean_bind(:,:)
REAL(num), ALLOCATABLE :: coll_ion_secondary_ke(:,:)
REAL(num), ALLOCATABLE :: coll_ion_secondary_cdf(:,:)
! Attached probes for this species
#ifndef NO_PARTICLE_PROBES
TYPE(particle_probe), POINTER :: attached_probes
#endif
! Particle migration
TYPE(particle_species_migration) :: migrate
! Initial conditions
TYPE(initial_condition_block) :: initial_conditions
! Per-species boundary conditions
INTEGER, DIMENSION(2*c_ndims) :: bc_particle
END TYPE particle_species
&lt;/code>&lt;/pre>
&lt;p>Again, most of these properties are self explanatory, but they are detailed
below.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>CHARACTER(LEN=entry_length) :: name&lt;/code> - The name of the particle
species. Used when constructing things like &amp;ldquo;ekbar_electron&amp;rdquo; and similar
names.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(particle_species), POINTER :: next, prev&lt;/code> - Particle species are
connected to each other as a linked list using pointers as well as being
available through a simple array. These pointers are used behind the scenes
in the I/O.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: id&lt;/code> - The number of the species, so for the species
&lt;code>species_list(1)&lt;/code>, the id field would be 1. For
&lt;code>species_list(2)&lt;/code>, the id field would be 2 etc.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: dumpmask&lt;/code> - Bitmask to determine when this species should be
dumped in diagnostic output.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: count_update_step&lt;/code> - The last step where the &lt;code>count&lt;/code> parameter
was updated.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num) :: charge&lt;/code> - The charge on a single particle of the species in
Coulombs.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num) :: mass&lt;/code> - The mass of a single particle of the species in
kilograms.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num) :: weight&lt;/code> - The per-species particle weight.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER(KIND=8) :: count&lt;/code> - The number of particles of this species on
all processors. NOTE that this is only accurate if the code is compiled with
the correct preprocessor options. Without the correct preprocessor options,
this will be accurate at the start of the code runtime, but will not be if
any particles enter or leave the domain. This is mainly a debugging
parameter.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(particle_list) :: attached_list&lt;/code> - This is the
&lt;code>particle_list&lt;/code> object which holds the particles assigned to this
species on this processor. Particles are attached to this list except between
the calls to &lt;code>reorder_particles_to_grid&lt;/code> and
&lt;code>reattach_particles_to_mainlist&lt;/code> in
&lt;code>epoch{1,2,3}d.F90&lt;/code> where the particles are instead attached to
&lt;code>secondary_list&lt;/code>. This is explained later.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(particle_pointer_list), POINTER :: boundary_particles&lt;/code> - A list of
particles which have been pushed out of the simulation boundaries.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: immobile&lt;/code> - These particles skip the particle push if true.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: fill_ghosts&lt;/code> - Loads particles into ghost cells surrounding the
simulation if true.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: ic_df_type&lt;/code> - Sets temperature calculation for the delta-f loader.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num) :: fractional_tail_cutoff&lt;/code> - Sets a cut-off for the relativistic
temperature to momentum calculation in
&lt;code>src/user_interaction/particle_temperature.F90&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(primitive_stack) :: dist_fn&lt;/code> - Arbitrary momentum distribution function
for particle loading.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(primitive_stack) :: dist_fn_range(3)&lt;/code> - Set upper and lower ranges to
the momentum distribution functions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: zero_current&lt;/code> - Whether or not this species is a tracer particle.
If
a species is a tracer species then it moves under the fields as normal for a
particle with its mass and charge but contributes no current.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: atomic_no&lt;/code> - Set atomic number of species. Used for bremsstrahlung
and ionisation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: atomic_no_set&lt;/code> - Identifies is an atomic number has been set for
the species.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: background_species&lt;/code> - If true, the species is not to load any
particles. Instead, this is represented with a density value in each cell,
and it can only act as a target species for bremsstrahlung radiation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num), DIMENSION(:,:,:), POINTER :: background_density&lt;/code> - The number
density of a background species (for bremsstrahlung radiation).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: make_secondary_list&lt;/code> - Checks if this species will ever need to
create a secondary list (see &lt;code>secondary_list&lt;/code>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: is_shuffled&lt;/code> - Checks if the order of particles in secondary lists
has been randomised&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: coll_background&lt;/code>- Checks if this species forms the background
species in a fast-background pair for background particle collisions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: coll_fast&lt;/code> - Checks if this species describes the fast species in
a fast-background pair for background particle collisions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: coll_pairwise&lt;/code> - Checks if this species undergoes binary
collisions with another species.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: species_type&lt;/code> - Tag the species as a particular type of particle,
using constants like &lt;code>c_species_id_electron&lt;/code>. This is required for the
physics packages.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER(i8) :: global_count&lt;/code> - The number of particles from this species
summed over all ranks.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: split&lt;/code> - EPOCH includes a very early version of a particle
splitting operator. It works mechanically but has undesirable properties at
present. If this flag is true then the code attempts to split the particles
when the pseudoparticle number density drops too low.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER(KIND=8) :: npart_max&lt;/code> - Used with the particle splitting
operator. When the total number of particles equals this number, further
particle splitting is suppressed.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(particle_list), DIMENSION(:,:,:), POINTER :: secondary_list&lt;/code> - This
describes an array of particle lists. The subroutine
&lt;code>reorder_particles_to_grid&lt;/code> allocates
&lt;code>secondary_list(0:nx+1,0:ny+1,0:nz+1)&lt;/code> and then loops over all
particles. It calculates the cell in which each particle is and moves the
particle from &lt;code>attached_list&lt;/code> to the correct element of
&lt;code>secondary_list&lt;/code> for that cell. This means the particles which
are nearby in space are now linked together in an array of linked lists.
This allows things such as collision operators which require direct
interaction between nearby particles.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER(KIND=8) :: npart_per_cell&lt;/code> - The number of pseudoparticles per
cell in the initial conditions. This is used with the moving window function
to ensure that the same number of particles per cell are used for the new
material introduced at the leading edge of the window.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num), DIMENSION(:,:), POINTER :: density&lt;/code> - The density of the
plasma at the leading edge of the window at the start of the simulation. This
is used to structure the density of the new material introduced at the leading
edge of the plasma.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num), DIMENSION(:,:,:), POINTER :: temperature&lt;/code> - The temperature
in of the plasma at the leading edge of a moving window at the start of the
simulation. The final index of the array is the direction in which the
temperature is set (1=x, 2=y, 3=z).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num), DIMENSION(:,:,:), POINTER :: ext_temp_{x,y,z}_{min,max}&lt;/code> - Sets
the temperature on the boundary for this particle species if &lt;code>thermal&lt;/code>
boundaries have been used.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: electron&lt;/code> - Species is tagged as an electron for the ionisation
routines.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LOGICAL :: ionise&lt;/code> - If the ionisation model is activated then this
species should ionise.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: ionise_to_species&lt;/code> - The species number for the next ionised
state of this species.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: release_species&lt;/code> - Specifies what type of particle should be
released when this species ionises (i.e. which species is the electron).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num) :: ionisation_energy&lt;/code> - The ionisation energy for the next
ionisation of this species.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER :: n, l&lt;/code> - The principle and angular quantum numbers of the
outermost electron for this species, assuming a ground-state electron
configuration. This is used for field ionisation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num), ALLOCATABLE :: coll_ion_incident_ke(:)&lt;/code> - A table of
logarithmically spaced kinetic energy values for incident electrons in
collisional ionisation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num), ALLOCATABLE :: coll_ion_cross_sec(:)&lt;/code> - The collisional
ionisation cross sections corresponding to incident electrons with kinetic
energies given by &lt;code>coll_ion_incident_ke(:)&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num), ALLOCATABLE :: coll_ion_mean_bind(:,:)&lt;/code> - For each
incident/ejected electron energy pair for collisional ionisation,
this gives the mean bound electron energy, weighted by the ionisation cross
section of each bound shell.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num), ALLOCATABLE :: coll_ion_secondary_ke(:,:)&lt;/code> - An array of possible
ejected electron energies for each incident electron kinetic energy in the
&lt;code>coll_ion_incident_ke(:)&lt;/code> table.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(num), ALLOCATABLE :: coll_ion_secondary_cdf(:,:)&lt;/code> - The cumulative
distribution function for the probability of emission of an ejected electron
energy for a given incident energy during collisional ionisation,
corresponding to the energies in &lt;code>coll_ion_secondary_ke&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(particle_probe), POINTER :: attached_probes&lt;/code> - A pointer pointing to
the head of an attached linked list of particle probe diagnostics.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(particle_species_migration) :: migrate&lt;/code> - Determines the criteria for
particles being moved to other species, using the particle migration routines.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TYPE(initial_condition_block) :: initial_conditions&lt;/code> - Stores parameters
read from the species block, describing the initial conditions of the species.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INTEGER, DIMENSION(2*c_ndims) :: bc_particle&lt;/code> - Boundary conditions for
particles in this species, which override the global boundaries set in the
input deck boundary block.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Partlist</title><link>/developer/core_structure/partlist.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/partlist.html</guid><description>&lt;p>Collections of particles in EPOCH are represented by the &lt;code>particle_list&lt;/code>
object. These objects abstract much of the operation of the linked lists,
including adding and removing particles and sending particles to other
processors. This page details the functions present in
&lt;code>src/housekeeping/partlist.F90&lt;/code>, which details how particle lists are formed.&lt;/p>
&lt;h2 id="create_empty_partlist">create_empty_partlist&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE create_empty_partlist(partlist)
TYPE(particle_list), INTENT(INOUT) :: partlist
&lt;/code>&lt;/pre>
&lt;p>&lt;code>create_empty_partlist&lt;/code> is a routine which takes a particle_list
object and sets it up so that it points to no particles at all. It should be
used on newly allocated particle_list objects and when a particle_list has
served its purpose. It DOES NOT destroy the particles linked in the list at
the point that it is called. If the user wishes to delete all the particles in a
particle_list then the routine &lt;code>destroy_partlist&lt;/code> should be used
instead.&lt;/p>
&lt;h2 id="create_unsafe_partlist">create_unsafe_partlist&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE create_unsafe_partlist(partlist, a_particle, &amp;amp;
n_elements)
TYPE(particle_list), INTENT(INOUT) :: partlist
TYPE(particle), POINTER :: a_particle
INTEGER(KIND=8), INTENT(IN) :: n_elements
&lt;/code>&lt;/pre>
&lt;p>&lt;code>create_unsafe_partlist&lt;/code> is a routine which allows the creation of
a particle_list which represents a subset of another particle list. This subset
is defined as starting at the particle pointed to by &lt;code>a_particle&lt;/code>
and extending for &lt;code>n_elements&lt;/code> elements. The new particle_list is
then flagged as &amp;ldquo;unsafe&amp;rdquo; because if it is destroyed for any reason then it
will affect other particle lists. Many particle_list functions can only work
on safe particle lists.&lt;/p>
&lt;h2 id="create_unsafe_partlist_by_tail">create_unsafe_partlist_by_tail&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE create_unsafe_partlist_by_tail(partlist, head, &amp;amp;
tail)
TYPE(particle_list), INTENT(INOUT) :: partlist
TYPE(particle), POINTER :: head, tail
&lt;/code>&lt;/pre>
&lt;p>&lt;code>create_unsafe_partlist_by_tail&lt;/code> is almost identical to
&lt;code>create_unsafe_partlist&lt;/code>, but instead of specifying the first
particle and a number of elements, the user specifies the first and last
elements in the subset of the particle list. If the particle objects specified
for head and tail are not in the same partlist or tail actually comes before
head then the routine will fail in an undefined manner.&lt;/p>
&lt;h2 id="create_allocated_partlist">create_allocated_partlist&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE create_allocated_partlist(partlist, n_elements)
TYPE(particle_list), INTENT(INOUT) :: partlist
INTEGER(KIND=8), INTENT(IN) :: n_elements
&lt;/code>&lt;/pre>
&lt;p>&lt;code>create_allocated_partlist&lt;/code> is a helper routine to setup a new
particle_list and create &lt;code>n_elements&lt;/code> new particle objects already
in place in the list.&lt;/p>
&lt;p>You should always use this routine when creating large numbers of new particle
objects since there is no guarantee that the internal structure of the
particle_list objects will not change in the future. This routine will
be modified to reflect any changes in the underlying code.&lt;/p>
&lt;h2 id="create_filled_partlist">create_filled_partlist&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE create_filled_partlist(partlist, data_in, &amp;amp;
n_elements)
TYPE(particle_list), INTENT(INOUT) :: partlist
REAL(num), DIMENSION(:), INTENT(IN) :: data_in
INTEGER(KIND=8), INTENT(IN) :: n_elements
&lt;/code>&lt;/pre>
&lt;p>&lt;code>create_filled_partlist&lt;/code> is a helper routine to setup a new
particle_list and create &lt;code>n_elements&lt;/code> new particle objects already
in place in the list. These new particle objects are then assigned properties
from the array &lt;code>data_in&lt;/code> where the particle properties are contained
in packed form. The particle data is unpacked from the array using the
&lt;code>unpack_particle&lt;/code> routine.&lt;/p>
&lt;p>You should always use this routine, if possible, when copying particles out of
packed format since there is no guarantee that the internal structure of the
particle_list objects will not change in the future. This routine will
be modified to reflect any changes in the underlying code.&lt;/p>
&lt;h2 id="test_partlist">test_partlist&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION test_partlist(partlist)
TYPE(particle_list), INTENT(INOUT) :: partlist
&lt;/code>&lt;/pre>
&lt;p>&lt;code>test_partlist&lt;/code> is a routine which tests for various possible types
of error within a particle_list object. It has a number of possible return
codes for different errors, using negative values for errors so severe that
the main tests cannot be run, or with a bitmask for errors in the main tests.
The return codes are:&lt;/p>
&lt;ul>
&lt;li>0 - No error, particle_list has passed all tests.&lt;/li>
&lt;li>-1 - Either the head or tail of the particle_list object is NULL. This is
a serious error and usually means that there is a serious error inside the
particle_list routines.&lt;/li>
&lt;/ul>
&lt;p>The other error codes are returned as a bitmask and mean the following&lt;/p>
&lt;ul>
&lt;li>1 - A particle_list marked as safe has a head element which is linked to
a preceding particle object.&lt;/li>
&lt;li>2 - A particle_list marked as safe has a tail element which is linked to
a proceding particle object.&lt;/li>
&lt;li>4 - The count property of a particle_list does not correspond to the
actual number of objects linked between the head and tail objects. This error
code on its own usually means that the count property has been modified
improperly.&lt;/li>
&lt;/ul>
&lt;p>Note that this routine is only intended for debugging and is very slow. It
should never be used by the code in normal operation and all routines should be
written in such a way that it is impossible for a particle_list object to
become corrupted.&lt;/p>
&lt;h2 id="destroy_partlist">destroy_partlist&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE destroy_partlist(partlist)
TYPE(particle_list), INTENT(INOUT) :: partlist
&lt;/code>&lt;/pre>
&lt;p>&lt;code>destroy_partlist&lt;/code> is a helper routine to delete all the particles
attached to a particle_list and free up the memory that they use. It also
guarantees to leave the particle_list object itself in a blank state where new
particles can be added to it. It DOES NOT delete the particle_list object
itself, since it does not know whether or not the particle_list is dynamically
allocated. If using dynamically allocated particle_list objects then it is up
to the user to deallocate them AFTER the attached particles are destroyed using
&lt;code>destroy_partlist&lt;/code>.&lt;/p>
&lt;p>If a particle_list is deleted without deleting the attached particle objects,
either using this routine or explicitly by the user, then the particles will
become orphaned and sit around using memory until the code ends. If this
happens regularly then the code will quickly crash, usually with a SIG_SEGV
error.&lt;/p>
&lt;h2 id="copt_partlist">copt_partlist&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE copy_partlist(partlist1, partlist2)
TYPE(particle_list), INTENT(INOUT) :: partlist1, partlist2
&lt;/code>&lt;/pre>
&lt;p>&lt;code>copy_partlist&lt;/code> is a routine which sets &lt;code>partlist2&lt;/code> to
point to the same linked list of particles as &lt;code>partlist1&lt;/code>. It does
not copy the particles, just sets the head and tail pointers of
&lt;code>partlist1&lt;/code> to point to the same particle objects as
&lt;code>partlist1&lt;/code>.&lt;/p>
&lt;h2 id="append_partlist">append_partlist&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE append_partlist(head, tail)
TYPE(particle_list), INTENT(INOUT) :: head, tail
&lt;/code>&lt;/pre>
&lt;p>&lt;code>append_partlist&lt;/code> is a routine which takes the particles
attached to the particle_list object &lt;code>tail&lt;/code> and adds them to the
end of the linked list for particle_list &lt;code>head&lt;/code>. The particle_list
&lt;code>tail&lt;/code> is then set to be an empty particle_list.&lt;/p>
&lt;p>This routine can only append one safe particle_list to another safe
particle_list.&lt;/p>
&lt;h2 id="add_particle_to_partlist">add_particle_to_partlist&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE add_particle_to_partlist(partlist, new_particle)
TYPE(particle_list), INTENT(INOUT) :: partlist
TYPE(particle), POINTER :: new_particle
&lt;/code>&lt;/pre>
&lt;p>&lt;code>add_particle_to_partlist&lt;/code> adds a new
particle (&lt;code>new_particle&lt;/code>) to the end of the linked list of
particles in the particle_list object &lt;code>partlist&lt;/code>. It deals with
cases of empty particle_list objects automatically.&lt;/p>
&lt;p>If you want to add a new particle to the end of a particle list you should
always use this routine.&lt;/p>
&lt;h2 id="remove_particle_from_partlist">remove_particle_from_partlist&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE remove_particle_from_partlist(partlist, &amp;amp;
a_particle)
TYPE(particle_list), INTENT(INOUT) :: partlist
TYPE(particle), POINTER :: a_particle
&lt;/code>&lt;/pre>
&lt;p>&lt;code>remove_particle_from_partlist&lt;/code> removes the particle object
specified by &lt;code>a_particle&lt;/code> from the particle_list object given by
&lt;code>partlist&lt;/code>. Be very careful that &lt;code>a_particle&lt;/code> is indeed
in the linked list pointed to by &lt;code>partlist&lt;/code>, otherwise it is possible
for the particle_list object which really does contain &lt;code>a_particle&lt;/code>
to be left with an invalid pointer as its head or tail element if
&lt;code>a_particle&lt;/code> is either the head or tail element.&lt;/p>
&lt;p>Although this routine does work with unsafe particle_list objects, you should
be very careful using it in this case as it can break the head or tail element
of the primary particle_list which the unsafe particle_list is a subset of.
As a general rule, you should only use this routine to remove particles from a
simple particle_list which is a singly referenced primary, safe particle_list.&lt;/p>
&lt;h2 id="setup_partlists">setup_partlists&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE setup_partlists()
&lt;/code>&lt;/pre>
&lt;p>&lt;code>setup_partlists&lt;/code> is a routine which is called once when EPOCH
first starts. It sets the variable &lt;code>nvars&lt;/code> which is the number of
REAL(num) values required to contain all the information about a
single particle object needed when a particle is transferred to another
processor. How the information is packed and unpacked from the particle object
into an array of REAL(num) values is controlled in the functions
&lt;code>pack_particle&lt;/code> and &lt;code>unpack_particle&lt;/code>.&lt;/p>
&lt;p>If the particle type gains additional properties as the result of preprocessor
directives then there should be a line which increments &lt;code>nvars&lt;/code> by
the correct number when that preprocessor directive is active. For example:&lt;/p>
&lt;pre>&lt;code class="language-perl">#ifdef PER_PARTICLE_CHARGE_MASS
nvar = nvar+2
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="pack_particle-and-unpack_particle">pack_particle and unpack_particle&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE pack_particle(array, a_particle)
SUBROUTINE unpack_particle(array, a_particle)
REAL(num), DIMENSION(:), INTENT(INOUT) :: array
TYPE(particle), POINTER :: a_particle
&lt;/code>&lt;/pre>
&lt;p>&lt;code>pack_particle&lt;/code> and &lt;code>unpack_particle&lt;/code> are subroutines
which are used to copy all the information about a particle
necessary for the particle to be transferred to another processor into a
temporary array before sending to another processor. If a new particle property
has been added to the particle then these routines must be modified to allow
the copying of the new data into the array. The parameter &lt;code>array&lt;/code> is
a REAL(num) array of length &lt;code>nvars&lt;/code> and is the array into which the
data either must be packed or from which it must be
unpacked. &lt;code>a_particle&lt;/code> is the particle object which must either have
its data copied into the array or be
populated with data from the array. No restriction is placed on how the
data should be packed into the data array, but obviously
&lt;code>pack_particle&lt;/code> and &lt;code>unpack_particle&lt;/code> must be inverse
operations so that particles packed by one processor can be unpacked correctly
by another processor.&lt;/p>
&lt;p>Since it is very unlikely that EPOCH will be run on anything other than a
homogeneous cluster, it is acceptable to use the Fortran &lt;code>TRANSFER&lt;/code>
function to pack incompatible data types into the &lt;code>array&lt;/code> array. Just
make sure that &lt;code>nvars&lt;/code> is defined in &lt;code>setup_partlists&lt;/code>
to be long enough to contain all the information. More documentation on the
&lt;code>TRANSFER&lt;/code> function (which is rarely used and dangerous!) can be
found
&lt;a href="http://www.macresearch.org/%advanced_fortran_90_callbacks_with_the_transfer_function" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;h2 id="display_particle">display_particle&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE display_particle(a_particle)
TYPE(particle), POINTER :: a_particle
&lt;/code>&lt;/pre>
&lt;p>Displays the key information about a particle given by the parameter
&lt;code>a_particle&lt;/code>. Used by &lt;code>compare_particles&lt;/code>.&lt;/p>
&lt;h2 id="compare_particles">compare_particles&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION compare_particles(particle1, particle2)
TYPE(particle), POINTER :: particle1, particle2
LOGICAL :: compare_particles
&lt;/code>&lt;/pre>
&lt;p>Compares all the properties of two particle objects and displays the
information if they don&amp;rsquo;t match. Used internally by
&lt;code>test_packed_particles&lt;/code>. If the particle object is extended then
this routine should also be modified to test for equivalence of the new
properties.&lt;/p>
&lt;h2 id="test_packed_particles">test_packed_particles&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION test_packed_particles(partlist, array, &amp;amp;
npart_in_data)
TYPE(particle_list), INTENT(IN) :: partlist
REAL(num), DIMENSION(:), INTENT(IN) :: array
INTEGER(KIND=8), INTENT(IN) :: npart_in_data
LOGICAL :: test_packed_particles
&lt;/code>&lt;/pre>
&lt;p>&lt;code>test_packed_particles&lt;/code> is a routine which checks that a packed
array of particles can be successfully unpacked back into particle objects. The
parameters are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>partlist&lt;/code> - The particle_list corresponding to the original
unpacked particles.&lt;/li>
&lt;li>&lt;code>array&lt;/code> - The REAL(num) array containing the packed data.&lt;/li>
&lt;li>&lt;code>npart_in_data&lt;/code> - The number of particles which were packed
into &lt;code>array&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>The routine tests that the number of particles in the particle_list match the
number believed to be in the data array, that the length of the data array is
correct and then unpacks each particle in turn from the data array and uses the
&lt;code>compare_particles&lt;/code> function to compare the particles with the
original versions in the particle_list. If any particles fail the comparison
then an error is output to stdout and the function returns a value of
&lt;code>.FALSE.&lt;/code>. The error message includes the processor
rank on which the problem occurs but the routine does not specifically include
any MPI commands, so it is possible to call the routine on a subset of
processors.&lt;/p>
&lt;h2 id="partlist_send">partlist_send&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE partlist_send(partlist, dest)
TYPE(particle_list), INTENT(INOUT) :: partlist
INTEGER, INTENT(IN) :: dest
&lt;/code>&lt;/pre>
&lt;p>&lt;code>partlist_send&lt;/code> is a routine for sending all the particles in the
particle_list object &lt;code>partlist&lt;/code> to another processor. The
destination processor is identified by its rank which is given by the
&lt;code>dest&lt;/code> parameter. The routine does not destroy the particle_list
object which is given to it.&lt;/p>
&lt;p>&lt;code>partlist_send&lt;/code> uses MPI blocking sends, so unless a matching
&lt;code>partlist_recv&lt;/code> has been posted on &lt;code>dest&lt;/code> then the
routine will deadlock. It would be fairly simple to write a non-blocking
version of &lt;code>partlist_send&lt;/code>, but at present no need for such a
routine has been found.&lt;/p>
&lt;h2 id="partlist_recv">partlist_recv&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE partlist_recv(partlist, src)
TYPE(particle_list), INTENT(INOUT) :: partlist
INTEGER, INTENT(IN) :: src
&lt;/code>&lt;/pre>
&lt;p>&lt;code>partlist_recv&lt;/code> is a routine for receiving particles sent by a call
to &lt;code>partlist_send&lt;/code> and loading them into the particle_list object
&lt;code>partlist&lt;/code>. The source processor is identified by its rank which is
given by the &lt;code>src&lt;/code> parameter. The routine destroys the particle_list
which it is given and indeed will leave orphaned particles if it is not given
an empty particle_list to receive the data.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>partlist_recv&lt;/code> uses MPI blocking receives, so unless a
matching &lt;code>partlist_send&lt;/code> has been posted on &lt;code>src&lt;/code> then
the routine will deadlock. It would be fairly simple to write a non-blocking
version of &lt;code>partlist_recv&lt;/code>, but at present no need for such a
routine has been found.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Although it is not possible to directly use &lt;code>partlist_recv&lt;/code>
to add new particles onto an existing particle_list, it is only two lines to
do this. First call &lt;code>partlist_recv&lt;/code> with a temporary
particle_list to receive the data and then use &lt;code>append_partlist&lt;/code>
to attach the particles to the end of the already populated list.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="partlist_send_recv">partlist_send_recv&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE partlist_send_recv(partlist_send, &amp;amp;
partlist_recv, dest, src)
TYPE(particle_list), INTENT(INOUT) :: partlist_send
TYPE(particle_list), INTENT(INOUT) :: partlist_recv
INTEGER, INTENT(IN) :: dest, src
&lt;/code>&lt;/pre>
&lt;p>&lt;code>partlist_sendrecv&lt;/code> is a routine equivalent to
&lt;code>MPI_SENDRECV&lt;/code> in that it allows overlapping sends and receives to
be written in a single line rather than the end user having to split processors
into red/black ordered pairs for communication. It sends the particle data in
&lt;code>partlist_send&lt;/code> to the processor with rank &lt;code>dest&lt;/code> and
receives particle data sent by processor &lt;code>src&lt;/code> and stores it in the
particle_list &lt;code>partlist_recv&lt;/code>. The routine is destructive to both
sending and receiving particle_lists, and can lead to orphaned particles if a
filled particle_list is passed as &lt;code>partlist_recv&lt;/code>. this is the
routine which is used in the particle boundary conditions.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>partlist_sendrecv&lt;/code> uses MPI blocking sendrecv commands, so
should be used in matching pairs or the routine will deadlock.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Although it is not possible to directly use
&lt;code>partlist_sendrecv&lt;/code> to add new particles onto an existing
particle_list, it is only two lines to do this. First call
&lt;code>partlist_sendrecv&lt;/code> with a temporary particle_list to receive the
data and then use &lt;code>append_partlist&lt;/code> to attach the particles to
the end of the already populated list.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Pre-compilation Flags</title><link>/developer/core_structure/precompiler_flags.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/precompiler_flags.html</guid><description>&lt;p>EPOCH uses precompiler directives to switch certain features of the code on
or off. The precompiler directives all begin with a &amp;ldquo;#&amp;rdquo; character and look
like:&lt;/p>
&lt;pre>&lt;code class="language-perl">#ifdef MY_PRECOMPILER_DIRECTIVE
some_fortran_of_some_kind
#else
some_other_fortran
#endif
&lt;/code>&lt;/pre>
&lt;p>They behave in a very simple manner. The precompiler runs BEFORE the
Fortran compiler and, until it reaches a precompiler directive, it just creates
a temporary file which is an exact copy of the source file. When it reaches a
precompiler directive of this kind it treats the #ifdef commands as
if/then/else statements. If
&lt;code>MY_PRECOMPILER_DIRECTIVE&lt;/code> was defined in the makefile then
&lt;code>some_fortran_of_some_kind&lt;/code> is pushed out to the temporary
file. Otherwise &lt;code>some_other_fortran&lt;/code> is written instead.
The precompiler directives themselves are never output to the temporary
file. Once then preprocessor has finished, it passes this temporary file
to the Fortran compiler which can then compile it just like any other
standard Fortran file.&lt;/p>
&lt;h2 id="when-to-use-precompiler-directives">When to use precompiler directives&lt;/h2>
&lt;ul>
&lt;li>When adding properties to the &lt;code>particle&lt;/code> structure.&lt;/li>
&lt;li>When adding time consuming calculations to the particle pusher.&lt;/li>
&lt;/ul>
&lt;p>Precompiler directives should be avoided when there is no significant
performance gain or memory reduction to be made. Wherever possible, optional
features should be controlled by parameters in the input deck.&lt;/p>
&lt;h2 id="the-directive-printing-routine-on-code-startup">The directive printing routine on code startup&lt;/h2>
&lt;p>When EPOCH starts it prints the precompiler directives that it was built with
and what they mean. This isn&amp;rsquo;t required, but has proved very useful and is
implemented in a very simple way. Just open the file
&lt;code>src/housekeeping/welcome.F90&lt;/code> and find the subroutine
&lt;code>compiler_directives&lt;/code>. There are a large block of precompiler
directives which read:&lt;/p>
&lt;pre>&lt;code class="language-perl">#ifdef TRACER_PARTICLES
defines = IOR(defines, c_def_tracer_particles)
WRITE(*, *) &amp;quot;Tracer particle support -DTRACER_PARTICLES&amp;quot;
#endif
&lt;/code>&lt;/pre>
&lt;p>Simply add a new element to the end of the list.&lt;/p>
&lt;pre>&lt;code class="language-perl">#ifdef MY_PRECOMPILER_DIRECTIVE
defines = IOR(defines, c_def_my_precompiler_directive)
WRITE(*,*) &amp;quot;My new physics -DMY_PRECOMPILER_DIRECTIVE&amp;quot;
#endif
&lt;/code>&lt;/pre>
&lt;p>You will also need to add &lt;code>c_def_my_precompiler_directive&lt;/code> to the list of
constants in &lt;code>src/shared_data.F90&lt;/code>.&lt;/p></description></item><item><title>String Handling</title><link>/developer/input_output/string_handling.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/string_handling.html</guid><description>&lt;p>Fortran is not a language famous for its string handling capabilities, but due
to the presence of the input deck EPOCH has fairly extensive string handling
routines. Strings used are all of the standard Fortran &lt;code>CHARACTER&lt;/code>
type and are defined as:&lt;/p>
&lt;pre>&lt;code class="language-perl">CHARACTER(LEN=string_length) :: string
&lt;/code>&lt;/pre>
&lt;p>&lt;code>string_length&lt;/code> is a global constant defined in
&lt;code>src/constants.F90&lt;/code> which can be increased to allow EPOCH to
handle longer strings. There may be reasons to increase this length if you wish
to use long complex expressions in the input deck. Note that many Fortran
compilers do not allow strings to exceed 512 characters in length.&lt;/p>
&lt;p>Listed here are the string handling routines (other than those in the core
maths parser routine which are documented elsewhere) which are currently used
in EPOCH. These functions can be found in &lt;code>src/deck/strings.f90&lt;/code> and
&lt;code>src/deck/strings_advanced.f90&lt;/code>&lt;/p>
&lt;h2 id="str_cmp">str_cmp&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION str_cmp(str_in, str_test)
CHARACTER(LEN=*), INTENT(IN) :: str_in, str_test
LOGICAL :: str_cmp
&lt;/code>&lt;/pre>
&lt;p>&lt;code>str_cmp&lt;/code> is the routine which does all the string comparisons in
EPOCH. It deals with leading and trailing whitespace automatically and
tests for length differences. It does not test for strings being
valid substrings of each other, only for full equality.&lt;/p>
&lt;p>A developer should always use &lt;code>str_cmp&lt;/code> rather than doing their own
string testing to ensure consistent behaviour across the entire EPOCH code
base.&lt;/p>
&lt;h2 id="as_real_simple">as_real_simple&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_real_simple(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
REAL(num) :: as_real_simple
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_real_simple&lt;/code> is a routine to convert a string into a real
number without invoking the maths parser. It can cope with standard form as
well as simple decimal reals. It is significantly faster than the maths parser,
but should only be used when the user explicitly &lt;em>shouldn&amp;rsquo;t&lt;/em> be able to use
a mathematical expression. If the string cannot be parsed then the routine sets
the bitmask &lt;code>c_err_bad_value&lt;/code> on the parameter &lt;code>err&lt;/code>&lt;/p>
&lt;p>If you have a string which has to be converted into a real quickly then this is
the routine to use. You probably shouldn&amp;rsquo;t use it when parsing a string from
the input deck, since there is no reason to restrict the user from specifying a
mathematical expression. The routine is used inside the maths parser to parse
simple numbers.&lt;/p>
&lt;h2 id="as_integer_simple">as_integer_simple&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_integer_simple(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER :: as_integer_simple
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_integer_simple&lt;/code> is a routine to convert a string into an
integer without invoking the maths parser. It can cope with standard form as
well as simple decimal integers. It is significantly faster than the maths
parser, but should only be used when the user explicitly &lt;em>shouldn&amp;rsquo;t&lt;/em> be
able to use a mathematical expression. If the string cannot be parsed then the
routine sets the bitmask &lt;code>c_err_bad_value&lt;/code> on the parameter
&lt;code>err&lt;/code>&lt;/p>
&lt;p>This routine is used internally in several parts of the code when parsing
things like numbers which are parts of strings (i.e. the 1 in
&lt;code>direction1&lt;/code> for distribution functions). It probably shouldn&amp;rsquo;t
be used to directly parse input deck parameters, since there is no reason to
restrict the user from specifying mathematical expressions.&lt;/p>
&lt;h2 id="as_long_integer_simple">as_long_integer_simple&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_long_integer_simple(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER(KIND=8) :: as_long_integer_simple
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_long_integer_simple&lt;/code> is equivalent to
&lt;code>as_integer_simple&lt;/code>, but returns the larger
&lt;code>INTEGER(KIND=8)&lt;/code> rather than a normal &lt;code>INTEGER(KIND=4)&lt;/code>.&lt;/p>
&lt;h2 id="as_boundary">as_boundary&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_boundary(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER :: as_boundary
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_direction&lt;/code> is used when assigning a laser to a boundary and
recognises the strings&lt;/p>
&lt;ul>
&lt;li>x_min or left - c_bd_x_min.&lt;/li>
&lt;li>x_max or right - c_bd_x_max.&lt;/li>
&lt;li>y_min or down - c_bd_y_min.&lt;/li>
&lt;li>y_max or up - c_bd_y_max.&lt;/li>
&lt;li>z_min or back - c_bd_z_min.&lt;/li>
&lt;li>z_max or front - c_bd_z_max.&lt;/li>
&lt;/ul>
&lt;p>It returns the associated direction code (given after the dash in the
definition).&lt;/p>
&lt;p>If you&amp;rsquo;re writing code which requires attaching something to a boundary,
whether a boundary condition, a diagnostic or some other routine, then this is
the routine that should be used. Note that in order to prevent confusion when
moving input decks between different dimension versions of EPOCH, each code
only recognises the strings for boundaries that it actually has.&lt;/p>
&lt;h2 id="as_logical">as_logical&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_logical(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
Logical :: as_logical
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_logical&lt;/code> simply tests for the strings &amp;ldquo;T&amp;rdquo; and &amp;ldquo;F&amp;rdquo; to
determine a boolean value. The default behaviour of &lt;code>as_logical&lt;/code> is
to treat any string that isn&amp;rsquo;t &amp;ldquo;T&amp;rdquo; as a false value.&lt;/p>
&lt;p>You should use this rather than using a 0/1 boolean flag in the input deck for
consistency.&lt;/p>
&lt;h2 id="split_off_int">split_off_int&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE split_off_int(str_in, str_out, int_out, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
CHARACTER(LEN=*), INTENT(OUT) :: str_out
INTEGER, INTENT(OUT) :: int_out
INTEGER, INTENT(INOUT) :: err
&lt;/code>&lt;/pre>
&lt;p>&lt;code>split_off_int&lt;/code> is a routine which splits a string of the format
&lt;code>string n&lt;/code> into a string &lt;code>string&lt;/code> and an integer &lt;code>n&lt;/code> which are
returned separately in the &lt;code>str_out&lt;/code> and &lt;code>int_out&lt;/code>
parameters respectively. If it can&amp;rsquo;t split the string successfully then it
sets the &lt;code>c_err_bad_value&lt;/code> bitfield of the err parameter.&lt;/p>
&lt;p>This is used in the core of the deck parser to deal with blocks like the
numbered species blocks in the initial conditions, and also in some of the
specific block parsers. Again, this routine should be used to split strings
like this rather than coding a new routine.&lt;/p>
&lt;h2 id="split_range">split_range&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE split_range(str_in, real1, real2, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
REAL(num), INTENT(OUT) :: real1, real2
INTEGER, INTENT(INOUT) :: err
&lt;/code>&lt;/pre>
&lt;p>&lt;code>split_range&lt;/code> is a routine which splits a string of the format
&lt;code>(n, m)&lt;/code> into two reals &lt;code>n&lt;/code> and &lt;code>m&lt;/code> which are returned
separately in the &lt;code>real1&lt;/code> and &lt;code>real2&lt;/code> parameters
respectively. If it can&amp;rsquo;t split the string successfully then it sets the
&lt;code>c_err_bad_value&lt;/code> bitfield of the err parameter.&lt;/p>
&lt;p>This is used when specifying ranges in the input decks at present. Any
ranges which should be specified in a single parameter should be specified in
this form and this routine used to split the string.&lt;/p>
&lt;h2 id="as_integer">as_integer&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_integer(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER :: as_integer
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_integer&lt;/code> is the routine which returns integers from strings
using the maths parser. If a mathematical expression resolves to a non-integer
result then this routine rounds to the NEAREST integer. There are explicit
rounding routines in the maths parser to force other behaviour.&lt;/p>
&lt;p>This routine should be used when evaluating most strings into integers. Note
that this routine evaluates spatially dependent quantities at (0,0) on each
processor, so will give unpredictable results when spatially dependent
quantities are given to it (like density, bx etc.). To evaluate a spatially
varying quantity use &lt;code>evaluate_string_in_space&lt;/code>.&lt;/p>
&lt;h2 id="as_long_integer">as_long_integer&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_long_integer(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER(KIND=8) :: as_long_integer
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_long_integer&lt;/code> is the routine which returns long integers from
strings using the maths parser. If a mathematical expression resolves to a
non-integer result then this routine rounds to the NEAREST integer. There are
explicit rounding routines in the maths parser to force other behaviour.&lt;/p>
&lt;p>This routine should be used when evaluating strings which are likely to be too
large to be stored in an INTEGER(KIND=4).&lt;/p>
&lt;h2 id="as_real">as_real&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_real(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
REAL(num) :: as_real
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_real&lt;/code> is the routine which returns reals from strings using the
maths parser.&lt;/p>
&lt;p>This routine should be used when evaluating most strings into reals. Note that
this routine evaluates spatially dependent quantities at (0,0) on each
processor, so will give unpredictable results when spatially dependent
quantities are given to it (like density, bx etc.). To evaluate a spatially
varying quantity use &lt;code>evaluate_string_in_space&lt;/code>.&lt;/p>
&lt;h2 id="evaluate_string_in_space">evaluate_string_in_space&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE evaluate_string_in_space(str_in, data_out, &amp;amp;
x1, x2, \{y1, y2, z1, z2,\} err)
CHARACTER(*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER, INTENT(IN) :: x1, x2\{, y1, y2, z1, z2\}
REAL(num), DIMENSION(1:,1:,1:), INTENT(OUT) :: data_out
&lt;/code>&lt;/pre>
&lt;p>&lt;code>evaluate_string_in_space&lt;/code> is a routine which is used to evaluate
a tokenized maths expression over a region of the domain. The dimensionality of
&lt;code>data_out&lt;/code>, and the presence or absence of &lt;code>y1, y2&lt;/code> and
&lt;code>z1, z2&lt;/code> depend on the dimensionality of the code being used. The
&lt;code>x1, x2, ...&lt;/code> parameters represent the indices in that
direction over which the expression should be evaluated. For example, in 2D to
evaluate an expression over the entire domain, the code would look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">REAL(num), DIMENSION(:,:), ALLOCATABLE :: data
ALLOCATE(data(-2:nx+3,-2:ny+3))
CALL evaluate_string_in_space(string, data, -2, nx+3, -2, ny+3, err)
&lt;/code>&lt;/pre>
&lt;p>This routine is suitable to evaluate expressions over a subsection or all of
the domain, and is used in this way in the initial condition deck parser
routines. However, the routine does have one significant weakness, which is
that it tokenizes the string each time it is called. Tokenizing the string is a
time consuming process, so if the string is to be evaluated several times for
different reasons (for example, the time profile for the laser) then a
different procedure should be followed using the lower level parser routines.&lt;/p></description></item><item><title>Weighting Functions</title><link>/developer/core_structure/shape_functions.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/core_structure/shape_functions.html</guid><description>&lt;p>The key feature of a PIC code controlling the smoothness of the solution is the
particle shape function. That is the function that describes the assumed
distribution of the real particles making up a macro-particle. The simplest
solution is to assume that the macro-particles uniformly fill the cell in which
the macro-particle is located. This has the advantages of speed and simplicity
but produces very noisy solutions. The next simplest approach is to assume a
triangular shape function with the peak of the triangle located at the position
of the macro-particle and a width of $ 2 \Delta x$, as illustrated below.&lt;/p>
&lt;p>&lt;img src="/developer/shape.png" alt="Second order particle shape function">&lt;/p>
&lt;p>&lt;img src="/developer/tri_eq.png" alt="Triangular shape function">&lt;/p>
&lt;p>This is the approach used
in EPOCH and is a good trade-off between cleanness of solution and
speed. Higher order methods based on spline interpolation can be used and do
produce smoother solutions, but they are significantly slower and the benefits
of the schemes can easily be overstated. EPOCH does now include an option to
use 3rd order b-spline interpolation in all parts of the code. This option is
enabled with the &lt;code>-DPARTICLE_SHAPE_BSPLINE3&lt;/code> compile time option
in the makefile.&lt;/p>
&lt;p>Functions derived from the particle shape function appear in two places in the
core solver: when the EM fields are interpolated to the position of the
macro-particle and when the current is updated and properties of the
macro-particle are copied onto the grid. These two uses of the shape function
are conceptually similar, but have different forms.&lt;/p>
&lt;h2 id="interpolating-grid-variables-to-macro-particles">Interpolating grid variables to macro-particles&lt;/h2>
&lt;p>To derive the equations for calculating the field acting on a particle,
you calculate the overlap of the particle shape function with the function
representing the fields on the grid. In EPOCH, the fields are approximated at
first order so that the field is constant over each cell. Consider a particle
with position $X$, where $X$ lies in the cell centred at $x_i$ and grid
spacing $\Delta x$. The integral is split into four parts; that part of the
shape function which overlaps with the cell $x_{i-1}$, the part of the shape
function from the left boundary of $x_i$ to the point of the triangle, the part
of the shape function from the point of the triangle to the right hand edge of
$x_i$ and finally that part of the shape function which overlaps cell
$x_{i+1}$. Assuming that fields are constant inside each cell ($F_i$), this
takes the form&lt;/p>
&lt;p>&lt;img src="/developer/shape_weight.png" alt="Fields interpolated to particle position">&lt;/p>
&lt;p>Performing these integrals and remembering that $x_{i-1}+\frac{\Delta x}{2}$ is
equal to $x_i-\frac{\Delta x}{2}$ since the grid is uniformly spaced with
spacing $\Delta x$, this gives a final formula for the field at a particle of&lt;/p>
&lt;p>&lt;img src="/developer/shape_weight_final.png" alt="Simplified fields interpolated to particle position">&lt;/p>
&lt;p>In the code calculating the strength of a cell centred field on the particle
is done as follows.&lt;/p>
&lt;pre>&lt;code class="language-perl"> REAL(num) :: cell_x_r, cell_frac_x
INTEGER :: cell_x1
REAL(num) :: gx(-2:2)
TYPE(particle), POINTER :: current
part_x = current%part_pos(1) - x_min_local
! Work out the grid cell number for the particle.
! Not an integer in general.
cell_x_r = part_x / dx
! Round cell position to nearest cell
cell_x1 = FLOOR(cell_x_r + 0.5_num)
! Calculate fraction of cell between nearest cell boundary and particle
cell_frac_x = REAL(cell_x1, num) - cell_x_r
cell_x1 = cell_x1 + 1
cf2 = cell_frac_x**2
gx(-1) = 0.25_num + cf2 + cell_frac_x
gx( 0) = 1.5_num - 2.0_num * cf2
gx( 1) = 0.25_num + cf2 - cell_frac_x
f_part = &amp;amp;
gx(-1) * F(cell_x1-1) &amp;amp;
+ gx( 0) * F(cell_x1 ) &amp;amp;
+ gx( 1) * F(cell_x1+1)
&lt;/code>&lt;/pre>
&lt;p>where &lt;code>f_part&lt;/code> is the field at the particle location. Note that
this has been simplified a little for brevity. Just the triangle shape
function is given.
In 2D or 3D, you just calculate gy
in the same manner as gx and calculate the weight over all the cells affected
by the individual 1D shape functions. In 2D this looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl"> f_part = 0.0_num
DO iy = sf_min, sf_max
DO ix = sf_min, sf_max
f_part = f_part + f(cell_x+ix, cell_y+iy) * gx(ix) * gy(iy)
ENDDO
ENDDO
&lt;/code>&lt;/pre>
&lt;p>The variables &lt;code>sf_min&lt;/code> and &lt;code>sf_max&lt;/code> contain the shape
function order parameters which indicate the cells each side of the cell
containing the particle which are overlapped by the particle shape function.
They are defined in &lt;code>shared_data.F90&lt;/code> and should only be changed
by the developer if a new particle shape function is being added.
Although provided here as pseudo-code for the particle push, it should be
noted that the actual particle push unrolls these loops for the sake of speed.&lt;/p>
&lt;p>Inside the particle pusher the $E$ and $B$ fields are not cell centred fields,
but Yee staggered. This means that there is a small change to the above
mentioned example. In 1D this change looks like&lt;/p>
&lt;pre>&lt;code class="language-perl"> REAL(num) :: cell_x_r, cell_frac_x
INTEGER :: cell_x1, cell_x2
REAL(num) :: gx(-2:2), hx(-2:2)
TYPE(particle), POINTER :: current
part_x = current%part_pos(1) - x_min_local
! Work out the grid cell number for the particle.
! Not an integer in general.
cell_x_r = part_x / dx
! Round cell position to nearest cell
cell_x1 = FLOOR(cell_x_r + 0.5_num)
! Calculate fraction of cell between nearest cell boundary and particle
cell_frac_x = REAL(cell_x1, num) - cell_x_r
cell_x1 = cell_x1 + 1
! Calculate weights
INCLUDE 'include/triangle/gx.inc'
! Now redo shifted by half a cell due to grid stagger.
! Use shifted version for ex in X, ey in Y, ez in Z
! And in Y&amp;amp;Z for bx, X&amp;amp;Z for by, X&amp;amp;Y for bz
cell_x2 = FLOOR(cell_x_r)
cell_frac_x = REAL(cell_x2, num) - cell_x_r + 0.5_num
cell_x2 = cell_x2 + 1
! Calculate weights
INCLUDE 'include/triangle/hx_dcell.inc'
! bx is cell centred
bx_part = 0.0_num
DO ix = sf_min, sf_max
bx_part = bx_part + bx(cell_x1+ix) * gx(ix)
ENDDO
! ex is staggered 1/2 a cell to the right
ex_part = 0.0_num
DO ix = sf_min, sf_max
ex_part = ex_part + ex(cell_x2+ix) * hx(ix)
ENDDO
&lt;/code>&lt;/pre>
&lt;p>In 2D and 3D, you just combine the shifted and unshifted shape functions and
associated cell positions depending on the position of the variable in the
cell. Therefore, in 3D and using the loop notation for clarity you would get:&lt;/p>
&lt;pre>&lt;code class="language-perl"> DO iz = sf_min, sf_max
DO iy = sf_min, sf_max
DO ix = sf_min, sf_max
ex_part = ex_part + hx(ix) * gy(iy) * gz(iz) * &amp;amp;
ex(cell_x2+ix, cell_y1+iy, cell_z1+iz)
ENDDO
ENDDO
ENDDO
DO iz = sf_min, sf_max
DO iy = sf_min, sf_max
DO ix = sf_min, sf_max
bx_part = bx_part + gx(ix) * hy(iy) * hz(iz) * &amp;amp;
bx(cell_x2+ix, cell_y1+iy, cell_z1+iz)
ENDDO
ENDDO
ENDDO
&lt;/code>&lt;/pre>
&lt;p>Since $E_x$ is staggered half a grid cell in the x direction, whereas $B_x$ is
staggered by half a grid cell in the y and z directions.&lt;/p>
&lt;h2 id="writing-macro-particle-properties-on-the-grid">Writing macro-particle properties on the grid&lt;/h2>
&lt;p>The next stage is to consider how to copy macro-particle
properties on the grid. This is very similar to the function for calculating
grid variables at the particle location and, for each grid point $x_i$,
consists of integrating the part of the particle shape function which overlaps
the $i^{th}$ cell. That is&lt;/p>
&lt;p>$$
F(i) = Data \int^{x_i+\frac{\Delta x}{2}}_{x_i-\frac{\Delta x}{2}} S(X-x) dx
$$&lt;/p>
&lt;p>Where $Data$ is the particle property to be copied onto the grid. In EPOCH,
since the particle shape function is known to go to zero outside a distance of
$2 \Delta x$ from the maximum, the maximum number of cells that can possibly be
overlapped by a given particle shape function is 3; the cell containing the
particle maximum and the two cells to either side. Performing the integration
using the triangular shape function given above gives the result&lt;/p>
&lt;p>&lt;img src="/developer/part_to_grid.png" alt="Particle weight to grid">&lt;/p>
&lt;p>When this is translated into the code, it looks very similar to that presented
for the case where grid properties are interpolated to the particle
position. This form is used in the particle pusher to perform the current
update and in the routines in &lt;code>src/io/calc_df.F90&lt;/code> to copy particle
properties onto the grid for output. The form from calc_df is rather clearer
and easier to see in operation. In 1D it looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl"> cell_x_r = (current%part_pos - x_min_local) / dx + 1.5_num
cell_x = FLOOR(cell_x_r)
cell_frac_x = REAL(cell_x, num) - cell_x_r + 0.5_num
CALL particle_to_grid(cell_frac_x, gx)
wdata = part_m * fac
DO ix = sf_min, sf_max
data_array(cell_x+ix) = data_array(cell_x+ix) + gx(ix) * wdata
ENDDO
&lt;/code>&lt;/pre>
&lt;p>Once again multi-dimensional codes just have the weighting functions multiplied
together.&lt;/p>
&lt;pre>&lt;code class="language-perl"> DO iy = sf_min, sf_max
DO ix = sf_min, sf_max
data_array(cell_x+ix, cell_y+iy) = &amp;amp;
data_array(cell_x+ix, cell_y+iy) + gx(ix) * gy(iy) * wdata
ENDDO
ENDDO
&lt;/code>&lt;/pre>
&lt;h2 id="other-particle-shapes">Other particle shapes&lt;/h2>
&lt;p>The previous sections dealt with the default macro-particle shape (triangular).
EPOCH also supports TOPHAT and BSPLINE particle shapes, although the
implementation of these can be different. Interpolating fields to particles and
writing particle properties to the grid is performed using the same method as
before, but for an altered shape function for TOPHAT:&lt;/p>
&lt;p>&lt;img src="/developer/tophat.png" alt="TOPHAT shape">&lt;/p>
&lt;p>and for BSPLINE:&lt;/p>
&lt;p>&lt;img src="/developer/bspline.png" alt="BSPLINE shape">&lt;/p>
&lt;p>In the TRIANGLE and BSPLINE set-ups, the particle shape extends over a size of
$2\Delta x$ and $4\Delta x$. Unless the paricle centre is on a cell boundary,
the shape will always extend over 3 or 5 cells respectively. However, the TOPHAT
shape has a size of $1 \Delta x$, which is an odd number of cell-sizes. If we
evaluate this shape at the particle centre, the shape may extend over the
cell on the low-$x$ side, or the high-$x$ side. To simplify the code, we
evaluate the TOPHAT shape position from the low-$x$, low-$y$, low-$z$ corner of
the shape, such that the shape always extends over the current cell and the
higher cell only. This is why the cell-calculation for TOPHAT differs from the
other shapes, in lines like:&lt;/p>
&lt;pre>&lt;code>#ifdef PARTICLE_SHAPE_TOPHAT
cell_x_r = part_x * idx - 0.5_num
cell_y_r = part_y * idy - 0.5_num
#else
cell_x_r = part_x * idx
cell_y_r = part_y * idy
#endif
&lt;/code>&lt;/pre></description></item></channel></rss>